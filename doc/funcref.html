<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <LINK REL="stylesheet" TYPE="text/css" HREF="doc.css">
 <META NAME="GENERATOR" CONTENT="LinuxDoc-Tools 0.9.66">
 <TITLE>cc65 function reference</TITLE>
</HEAD>
<BODY>
<H1>cc65 function reference</H1>

<H2>
<A HREF="mailto:uz@cc65.org">Ullrich von Bassewitz</A></H2>2014-05-26
<HR>
<EM>cc65 is a C compiler for 6502 based systems. This function reference describes
the C functions available in the standard library.</EM>
<HR>
<P>
<H2><A NAME="toc1">1.</A> <A HREF="funcref.html#s1">Introduction</A></H2>

<P>
<H2><A NAME="toc2">2.</A> <A HREF="funcref.html#s2">Functions by header file</A></H2>

<UL>
<LI><A NAME="toc2.1">2.1</A> <A HREF="funcref.html#ss2.1"><CODE>6502.h</CODE></A>
<LI><A NAME="toc2.2">2.2</A> <A HREF="funcref.html#ss2.2"><CODE>apple2.h</CODE></A>
<LI><A NAME="toc2.3">2.3</A> <A HREF="funcref.html#ss2.3"><CODE>apple2enh.h</CODE></A>
<LI><A NAME="toc2.4">2.4</A> <A HREF="funcref.html#ss2.4"><CODE>assert.h</CODE></A>
<LI><A NAME="toc2.5">2.5</A> <A HREF="funcref.html#ss2.5"><CODE>atari.h</CODE></A>
<LI><A NAME="toc2.6">2.6</A> <A HREF="funcref.html#ss2.6"><CODE>atmos.h</CODE></A>
<LI><A NAME="toc2.7">2.7</A> <A HREF="funcref.html#ss2.7"><CODE>c128.h</CODE></A>
<LI><A NAME="toc2.8">2.8</A> <A HREF="funcref.html#ss2.8"><CODE>c16.h</CODE></A>
<LI><A NAME="toc2.9">2.9</A> <A HREF="funcref.html#ss2.9"><CODE>c64.h</CODE></A>
<LI><A NAME="toc2.10">2.10</A> <A HREF="funcref.html#ss2.10"><CODE>cbm.h</CODE></A>
<LI><A NAME="toc2.11">2.11</A> <A HREF="funcref.html#ss2.11"><CODE>cbm510.h</CODE></A>
<LI><A NAME="toc2.12">2.12</A> <A HREF="funcref.html#ss2.12"><CODE>cbm610.h</CODE></A>
<LI><A NAME="toc2.13">2.13</A> <A HREF="funcref.html#ss2.13"><CODE>cc65.h</CODE></A>
<LI><A NAME="toc2.14">2.14</A> <A HREF="funcref.html#ss2.14"><CODE>conio.h</CODE></A>
<LI><A NAME="toc2.15">2.15</A> <A HREF="funcref.html#ss2.15"><CODE>ctype.h</CODE></A>
<LI><A NAME="toc2.16">2.16</A> <A HREF="funcref.html#ss2.16"><CODE>dbg.h</CODE></A>
<LI><A NAME="toc2.17">2.17</A> <A HREF="funcref.html#ss2.17"><CODE>dio.h</CODE></A>
<LI><A NAME="toc2.18">2.18</A> <A HREF="funcref.html#ss2.18"><CODE>dirent.h</CODE></A>
<LI><A NAME="toc2.19">2.19</A> <A HREF="funcref.html#ss2.19"><CODE>em.h</CODE></A>
<LI><A NAME="toc2.20">2.20</A> <A HREF="funcref.html#ss2.20"><CODE>errno.h</CODE></A>
<LI><A NAME="toc2.21">2.21</A> <A HREF="funcref.html#ss2.21"><CODE>fcntl.h</CODE></A>
<LI><A NAME="toc2.22">2.22</A> <A HREF="funcref.html#ss2.22"><CODE>geos.h</CODE></A>
<LI><A NAME="toc2.23">2.23</A> <A HREF="funcref.html#ss2.23"><CODE>joystick.h</CODE></A>
<LI><A NAME="toc2.24">2.24</A> <A HREF="funcref.html#ss2.24"><CODE>locale.h</CODE></A>
<LI><A NAME="toc2.25">2.25</A> <A HREF="funcref.html#ss2.25"><CODE>lynx.h</CODE></A>
<LI><A NAME="toc2.26">2.26</A> <A HREF="funcref.html#ss2.26"><CODE>modload.h</CODE></A>
<LI><A NAME="toc2.27">2.27</A> <A HREF="funcref.html#ss2.27"><CODE>mouse.h</CODE></A>
<LI><A NAME="toc2.28">2.28</A> <A HREF="funcref.html#ss2.28"><CODE>nes.h</CODE></A>
<LI><A NAME="toc2.29">2.29</A> <A HREF="funcref.html#ss2.29"><CODE>o65.h</CODE></A>
<LI><A NAME="toc2.30">2.30</A> <A HREF="funcref.html#ss2.30"><CODE>peekpoke.h</CODE></A>
<LI><A NAME="toc2.31">2.31</A> <A HREF="funcref.html#ss2.31"><CODE>pet.h</CODE></A>
<LI><A NAME="toc2.32">2.32</A> <A HREF="funcref.html#ss2.32"><CODE>plus4.h</CODE></A>
<LI><A NAME="toc2.33">2.33</A> <A HREF="funcref.html#ss2.33"><CODE>serial.h</CODE></A>
<LI><A NAME="toc2.34">2.34</A> <A HREF="funcref.html#ss2.34"><CODE>setjmp.h</CODE></A>
<LI><A NAME="toc2.35">2.35</A> <A HREF="funcref.html#ss2.35"><CODE>signal.h</CODE></A>
<LI><A NAME="toc2.36">2.36</A> <A HREF="funcref.html#ss2.36"><CODE>stdarg.h</CODE></A>
<LI><A NAME="toc2.37">2.37</A> <A HREF="funcref.html#ss2.37"><CODE>stdbool.h</CODE></A>
<LI><A NAME="toc2.38">2.38</A> <A HREF="funcref.html#ss2.38"><CODE>stddef.h</CODE></A>
<LI><A NAME="toc2.39">2.39</A> <A HREF="funcref.html#ss2.39"><CODE>stdio.h</CODE></A>
<LI><A NAME="toc2.40">2.40</A> <A HREF="funcref.html#ss2.40"><CODE>stdlib.h</CODE></A>
<LI><A NAME="toc2.41">2.41</A> <A HREF="funcref.html#ss2.41"><CODE>string.h</CODE></A>
<LI><A NAME="toc2.42">2.42</A> <A HREF="funcref.html#ss2.42"><CODE>tgi.h</CODE></A>
<LI><A NAME="toc2.43">2.43</A> <A HREF="funcref.html#ss2.43"><CODE>time.h</CODE></A>
<LI><A NAME="toc2.44">2.44</A> <A HREF="funcref.html#ss2.44"><CODE>unistd.h</CODE></A>
<LI><A NAME="toc2.45">2.45</A> <A HREF="funcref.html#ss2.45"><CODE>vic20.h</CODE></A>
<LI><A NAME="toc2.46">2.46</A> <A HREF="funcref.html#ss2.46"><CODE>zlib.h</CODE></A>
</UL>
<P>
<H2><A NAME="toc3">3.</A> <A HREF="funcref.html#s3">Alphabetical function reference</A></H2>

<UL>
<LI><A NAME="toc3.1">3.1</A> <A HREF="funcref.html#ss3.1">_DE_ISDIR</A>
<LI><A NAME="toc3.2">3.2</A> <A HREF="funcref.html#ss3.2">_DE_ISLBL</A>
<LI><A NAME="toc3.3">3.3</A> <A HREF="funcref.html#ss3.3">_DE_ISLNK</A>
<LI><A NAME="toc3.4">3.4</A> <A HREF="funcref.html#ss3.4">_DE_ISREG</A>
<LI><A NAME="toc3.5">3.5</A> <A HREF="funcref.html#ss3.5">_heapadd</A>
<LI><A NAME="toc3.6">3.6</A> <A HREF="funcref.html#ss3.6">_heapblocksize</A>
<LI><A NAME="toc3.7">3.7</A> <A HREF="funcref.html#ss3.7">_heapmaxavail</A>
<LI><A NAME="toc3.8">3.8</A> <A HREF="funcref.html#ss3.8">_heapmemavail</A>
<LI><A NAME="toc3.9">3.9</A> <A HREF="funcref.html#ss3.9">_poserror</A>
<LI><A NAME="toc3.10">3.10</A> <A HREF="funcref.html#ss3.10">_randomize</A>
<LI><A NAME="toc3.11">3.11</A> <A HREF="funcref.html#ss3.11">_stroserror</A>
<LI><A NAME="toc3.12">3.12</A> <A HREF="funcref.html#ss3.12">_swap</A>
<LI><A NAME="toc3.13">3.13</A> <A HREF="funcref.html#ss3.13">_sys</A>
<LI><A NAME="toc3.14">3.14</A> <A HREF="funcref.html#ss3.14">BRK</A>
<LI><A NAME="toc3.15">3.15</A> <A HREF="funcref.html#ss3.15">CLI</A>
<LI><A NAME="toc3.16">3.16</A> <A HREF="funcref.html#ss3.16">PEEK</A>
<LI><A NAME="toc3.17">3.17</A> <A HREF="funcref.html#ss3.17">PEEKW</A>
<LI><A NAME="toc3.18">3.18</A> <A HREF="funcref.html#ss3.18">POKE</A>
<LI><A NAME="toc3.19">3.19</A> <A HREF="funcref.html#ss3.19">POKEW</A>
<LI><A NAME="toc3.20">3.20</A> <A HREF="funcref.html#ss3.20">SEI</A>
<LI><A NAME="toc3.21">3.21</A> <A HREF="funcref.html#ss3.21">abort</A>
<LI><A NAME="toc3.22">3.22</A> <A HREF="funcref.html#ss3.22">abs</A>
<LI><A NAME="toc3.23">3.23</A> <A HREF="funcref.html#ss3.23">assert</A>
<LI><A NAME="toc3.24">3.24</A> <A HREF="funcref.html#ss3.24">atexit</A>
<LI><A NAME="toc3.25">3.25</A> <A HREF="funcref.html#ss3.25">atmos_load</A>
<LI><A NAME="toc3.26">3.26</A> <A HREF="funcref.html#ss3.26">atmos_save</A>
<LI><A NAME="toc3.27">3.27</A> <A HREF="funcref.html#ss3.27">atoi</A>
<LI><A NAME="toc3.28">3.28</A> <A HREF="funcref.html#ss3.28">atol</A>
<LI><A NAME="toc3.29">3.29</A> <A HREF="funcref.html#ss3.29">bgcolor</A>
<LI><A NAME="toc3.30">3.30</A> <A HREF="funcref.html#ss3.30">bordercolor</A>
<LI><A NAME="toc3.31">3.31</A> <A HREF="funcref.html#ss3.31">bsearch</A>
<LI><A NAME="toc3.32">3.32</A> <A HREF="funcref.html#ss3.32">bzero</A>
<LI><A NAME="toc3.33">3.33</A> <A HREF="funcref.html#ss3.33">c64mode</A>
<LI><A NAME="toc3.34">3.34</A> <A HREF="funcref.html#ss3.34">calloc</A>
<LI><A NAME="toc3.35">3.35</A> <A HREF="funcref.html#ss3.35">cbm_k_acptr</A>
<LI><A NAME="toc3.36">3.36</A> <A HREF="funcref.html#ss3.36">cbm_k_basin</A>
<LI><A NAME="toc3.37">3.37</A> <A HREF="funcref.html#ss3.37">cbm_k_bsout</A>
<LI><A NAME="toc3.38">3.38</A> <A HREF="funcref.html#ss3.38">cbm_k_chkin</A>
<LI><A NAME="toc3.39">3.39</A> <A HREF="funcref.html#ss3.39">cbm_k_ciout</A>
<LI><A NAME="toc3.40">3.40</A> <A HREF="funcref.html#ss3.40">cbm_k_ckout</A>
<LI><A NAME="toc3.41">3.41</A> <A HREF="funcref.html#ss3.41">cbm_k_clall</A>
<LI><A NAME="toc3.42">3.42</A> <A HREF="funcref.html#ss3.42">cbm_k_close</A>
<LI><A NAME="toc3.43">3.43</A> <A HREF="funcref.html#ss3.43">cbm_k_clrch</A>
<LI><A NAME="toc3.44">3.44</A> <A HREF="funcref.html#ss3.44">cbm_k_getin</A>
<LI><A NAME="toc3.45">3.45</A> <A HREF="funcref.html#ss3.45">cbm_k_iobase</A>
<LI><A NAME="toc3.46">3.46</A> <A HREF="funcref.html#ss3.46">cbm_k_listen</A>
<LI><A NAME="toc3.47">3.47</A> <A HREF="funcref.html#ss3.47">cbm_k_load</A>
<LI><A NAME="toc3.48">3.48</A> <A HREF="funcref.html#ss3.48">cbm_k_open</A>
<LI><A NAME="toc3.49">3.49</A> <A HREF="funcref.html#ss3.49">cbm_k_readst</A>
<LI><A NAME="toc3.50">3.50</A> <A HREF="funcref.html#ss3.50">cbm_k_save</A>
<LI><A NAME="toc3.51">3.51</A> <A HREF="funcref.html#ss3.51">cbm_k_setlfs</A>
<LI><A NAME="toc3.52">3.52</A> <A HREF="funcref.html#ss3.52">cbm_k_setnam</A>
<LI><A NAME="toc3.53">3.53</A> <A HREF="funcref.html#ss3.53">cbm_k_talk</A>
<LI><A NAME="toc3.54">3.54</A> <A HREF="funcref.html#ss3.54">cbm_k_unlsn</A>
<LI><A NAME="toc3.55">3.55</A> <A HREF="funcref.html#ss3.55">cclear</A>
<LI><A NAME="toc3.56">3.56</A> <A HREF="funcref.html#ss3.56">cclearxy</A>
<LI><A NAME="toc3.57">3.57</A> <A HREF="funcref.html#ss3.57">cgetc</A>
<LI><A NAME="toc3.58">3.58</A> <A HREF="funcref.html#ss3.58">chline</A>
<LI><A NAME="toc3.59">3.59</A> <A HREF="funcref.html#ss3.59">chlinexy</A>
<LI><A NAME="toc3.60">3.60</A> <A HREF="funcref.html#ss3.60">clearerr</A>
<LI><A NAME="toc3.61">3.61</A> <A HREF="funcref.html#ss3.61">clock</A>
<LI><A NAME="toc3.62">3.62</A> <A HREF="funcref.html#ss3.62">clrscr</A>
<LI><A NAME="toc3.63">3.63</A> <A HREF="funcref.html#ss3.63">close</A>
<LI><A NAME="toc3.64">3.64</A> <A HREF="funcref.html#ss3.64">closedir</A>
<LI><A NAME="toc3.65">3.65</A> <A HREF="funcref.html#ss3.65">creat</A>
<LI><A NAME="toc3.66">3.66</A> <A HREF="funcref.html#ss3.66">cprintf</A>
<LI><A NAME="toc3.67">3.67</A> <A HREF="funcref.html#ss3.67">cputc</A>
<LI><A NAME="toc3.68">3.68</A> <A HREF="funcref.html#ss3.68">cputcxy</A>
<LI><A NAME="toc3.69">3.69</A> <A HREF="funcref.html#ss3.69">cputs</A>
<LI><A NAME="toc3.70">3.70</A> <A HREF="funcref.html#ss3.70">cputsxy</A>
<LI><A NAME="toc3.71">3.71</A> <A HREF="funcref.html#ss3.71">cursor</A>
<LI><A NAME="toc3.72">3.72</A> <A HREF="funcref.html#ss3.72">cvline</A>
<LI><A NAME="toc3.73">3.73</A> <A HREF="funcref.html#ss3.73">cvlinexy</A>
<LI><A NAME="toc3.74">3.74</A> <A HREF="funcref.html#ss3.74">div</A>
<LI><A NAME="toc3.75">3.75</A> <A HREF="funcref.html#ss3.75">em_commit</A>
<LI><A NAME="toc3.76">3.76</A> <A HREF="funcref.html#ss3.76">em_copyfrom</A>
<LI><A NAME="toc3.77">3.77</A> <A HREF="funcref.html#ss3.77">em_copyto</A>
<LI><A NAME="toc3.78">3.78</A> <A HREF="funcref.html#ss3.78">em_install</A>
<LI><A NAME="toc3.79">3.79</A> <A HREF="funcref.html#ss3.79">em_load_driver</A>
<LI><A NAME="toc3.80">3.80</A> <A HREF="funcref.html#ss3.80">em_map</A>
<LI><A NAME="toc3.81">3.81</A> <A HREF="funcref.html#ss3.81">em_pagecount</A>
<LI><A NAME="toc3.82">3.82</A> <A HREF="funcref.html#ss3.82">em_uninstall</A>
<LI><A NAME="toc3.83">3.83</A> <A HREF="funcref.html#ss3.83">em_unload</A>
<LI><A NAME="toc3.84">3.84</A> <A HREF="funcref.html#ss3.84">em_use</A>
<LI><A NAME="toc3.85">3.85</A> <A HREF="funcref.html#ss3.85">exit</A>
<LI><A NAME="toc3.86">3.86</A> <A HREF="funcref.html#ss3.86">exec</A>
<LI><A NAME="toc3.87">3.87</A> <A HREF="funcref.html#ss3.87">fast</A>
<LI><A NAME="toc3.88">3.88</A> <A HREF="funcref.html#ss3.88">feof</A>
<LI><A NAME="toc3.89">3.89</A> <A HREF="funcref.html#ss3.89">ferror</A>
<LI><A NAME="toc3.90">3.90</A> <A HREF="funcref.html#ss3.90">fileno</A>
<LI><A NAME="toc3.91">3.91</A> <A HREF="funcref.html#ss3.91">free</A>
<LI><A NAME="toc3.92">3.92</A> <A HREF="funcref.html#ss3.92">get_ostype</A>
<LI><A NAME="toc3.93">3.93</A> <A HREF="funcref.html#ss3.93">getcpu</A>
<LI><A NAME="toc3.94">3.94</A> <A HREF="funcref.html#ss3.94">getenv</A>
<LI><A NAME="toc3.95">3.95</A> <A HREF="funcref.html#ss3.95">getopt</A>
<LI><A NAME="toc3.96">3.96</A> <A HREF="funcref.html#ss3.96">gotox</A>
<LI><A NAME="toc3.97">3.97</A> <A HREF="funcref.html#ss3.97">gotoxy</A>
<LI><A NAME="toc3.98">3.98</A> <A HREF="funcref.html#ss3.98">gotoy</A>
<LI><A NAME="toc3.99">3.99</A> <A HREF="funcref.html#ss3.99">isalnum</A>
<LI><A NAME="toc3.100">3.100</A> <A HREF="funcref.html#ss3.100">isalpha</A>
<LI><A NAME="toc3.101">3.101</A> <A HREF="funcref.html#ss3.101">isascii</A>
<LI><A NAME="toc3.102">3.102</A> <A HREF="funcref.html#ss3.102">isblank</A>
<LI><A NAME="toc3.103">3.103</A> <A HREF="funcref.html#ss3.103">iscntrl</A>
<LI><A NAME="toc3.104">3.104</A> <A HREF="funcref.html#ss3.104">isdigit</A>
<LI><A NAME="toc3.105">3.105</A> <A HREF="funcref.html#ss3.105">isgraph</A>
<LI><A NAME="toc3.106">3.106</A> <A HREF="funcref.html#ss3.106">islower</A>
<LI><A NAME="toc3.107">3.107</A> <A HREF="funcref.html#ss3.107">isprint</A>
<LI><A NAME="toc3.108">3.108</A> <A HREF="funcref.html#ss3.108">ispunct</A>
<LI><A NAME="toc3.109">3.109</A> <A HREF="funcref.html#ss3.109">isspace</A>
<LI><A NAME="toc3.110">3.110</A> <A HREF="funcref.html#ss3.110">isupper</A>
<LI><A NAME="toc3.111">3.111</A> <A HREF="funcref.html#ss3.111">isxdigit</A>
<LI><A NAME="toc3.112">3.112</A> <A HREF="funcref.html#ss3.112">itoa</A>
<LI><A NAME="toc3.113">3.113</A> <A HREF="funcref.html#ss3.113">joy_count</A>
<LI><A NAME="toc3.114">3.114</A> <A HREF="funcref.html#ss3.114">joy_install</A>
<LI><A NAME="toc3.115">3.115</A> <A HREF="funcref.html#ss3.115">joy_load_driver</A>
<LI><A NAME="toc3.116">3.116</A> <A HREF="funcref.html#ss3.116">joy_read</A>
<LI><A NAME="toc3.117">3.117</A> <A HREF="funcref.html#ss3.117">joy_uninstall</A>
<LI><A NAME="toc3.118">3.118</A> <A HREF="funcref.html#ss3.118">joy_unload</A>
<LI><A NAME="toc3.119">3.119</A> <A HREF="funcref.html#ss3.119">kbhit</A>
<LI><A NAME="toc3.120">3.120</A> <A HREF="funcref.html#ss3.120">labs</A>
<LI><A NAME="toc3.121">3.121</A> <A HREF="funcref.html#ss3.121">ltoa</A>
<LI><A NAME="toc3.122">3.122</A> <A HREF="funcref.html#ss3.122">localeconv</A>
<LI><A NAME="toc3.123">3.123</A> <A HREF="funcref.html#ss3.123">longjmp</A>
<LI><A NAME="toc3.124">3.124</A> <A HREF="funcref.html#ss3.124">malloc</A>
<LI><A NAME="toc3.125">3.125</A> <A HREF="funcref.html#ss3.125">memchr</A>
<LI><A NAME="toc3.126">3.126</A> <A HREF="funcref.html#ss3.126">memcmp</A>
<LI><A NAME="toc3.127">3.127</A> <A HREF="funcref.html#ss3.127">memcpy</A>
<LI><A NAME="toc3.128">3.128</A> <A HREF="funcref.html#ss3.128">memmove</A>
<LI><A NAME="toc3.129">3.129</A> <A HREF="funcref.html#ss3.129">memset</A>
<LI><A NAME="toc3.130">3.130</A> <A HREF="funcref.html#ss3.130">mod_free</A>
<LI><A NAME="toc3.131">3.131</A> <A HREF="funcref.html#ss3.131">mod_load</A>
<LI><A NAME="toc3.132">3.132</A> <A HREF="funcref.html#ss3.132">mouse_setbox</A>
<LI><A NAME="toc3.133">3.133</A> <A HREF="funcref.html#ss3.133">mouse_getbox</A>
<LI><A NAME="toc3.134">3.134</A> <A HREF="funcref.html#ss3.134">mouse_buttons</A>
<LI><A NAME="toc3.135">3.135</A> <A HREF="funcref.html#ss3.135">mouse_geterrormsg</A>
<LI><A NAME="toc3.136">3.136</A> <A HREF="funcref.html#ss3.136">mouse_hide</A>
<LI><A NAME="toc3.137">3.137</A> <A HREF="funcref.html#ss3.137">mouse_info</A>
<LI><A NAME="toc3.138">3.138</A> <A HREF="funcref.html#ss3.138">mouse_install</A>
<LI><A NAME="toc3.139">3.139</A> <A HREF="funcref.html#ss3.139">mouse_ioctl</A>
<LI><A NAME="toc3.140">3.140</A> <A HREF="funcref.html#ss3.140">mouse_load_driver</A>
<LI><A NAME="toc3.141">3.141</A> <A HREF="funcref.html#ss3.141">mouse_move</A>
<LI><A NAME="toc3.142">3.142</A> <A HREF="funcref.html#ss3.142">mouse_pos</A>
<LI><A NAME="toc3.143">3.143</A> <A HREF="funcref.html#ss3.143">mouse_show</A>
<LI><A NAME="toc3.144">3.144</A> <A HREF="funcref.html#ss3.144">mouse_uninstall</A>
<LI><A NAME="toc3.145">3.145</A> <A HREF="funcref.html#ss3.145">mouse_unload</A>
<LI><A NAME="toc3.146">3.146</A> <A HREF="funcref.html#ss3.146">offsetof</A>
<LI><A NAME="toc3.147">3.147</A> <A HREF="funcref.html#ss3.147">open</A>
<LI><A NAME="toc3.148">3.148</A> <A HREF="funcref.html#ss3.148">opendir</A>
<LI><A NAME="toc3.149">3.149</A> <A HREF="funcref.html#ss3.149">peekbsys</A>
<LI><A NAME="toc3.150">3.150</A> <A HREF="funcref.html#ss3.150">peekwsys</A>
<LI><A NAME="toc3.151">3.151</A> <A HREF="funcref.html#ss3.151">perror</A>
<LI><A NAME="toc3.152">3.152</A> <A HREF="funcref.html#ss3.152">pokebsys</A>
<LI><A NAME="toc3.153">3.153</A> <A HREF="funcref.html#ss3.153">pokewsys</A>
<LI><A NAME="toc3.154">3.154</A> <A HREF="funcref.html#ss3.154">qsort</A>
<LI><A NAME="toc3.155">3.155</A> <A HREF="funcref.html#ss3.155">raise</A>
<LI><A NAME="toc3.156">3.156</A> <A HREF="funcref.html#ss3.156">rand</A>
<LI><A NAME="toc3.157">3.157</A> <A HREF="funcref.html#ss3.157">readdir</A>
<LI><A NAME="toc3.158">3.158</A> <A HREF="funcref.html#ss3.158">realloc</A>
<LI><A NAME="toc3.159">3.159</A> <A HREF="funcref.html#ss3.159">remove</A>
<LI><A NAME="toc3.160">3.160</A> <A HREF="funcref.html#ss3.160">rename</A>
<LI><A NAME="toc3.161">3.161</A> <A HREF="funcref.html#ss3.161">reset_brk</A>
<LI><A NAME="toc3.162">3.162</A> <A HREF="funcref.html#ss3.162">reset_irq</A>
<LI><A NAME="toc3.163">3.163</A> <A HREF="funcref.html#ss3.163">revers</A>
<LI><A NAME="toc3.164">3.164</A> <A HREF="funcref.html#ss3.164">rewinddir</A>
<LI><A NAME="toc3.165">3.165</A> <A HREF="funcref.html#ss3.165">screensize</A>
<LI><A NAME="toc3.166">3.166</A> <A HREF="funcref.html#ss3.166">seekdir</A>
<LI><A NAME="toc3.167">3.167</A> <A HREF="funcref.html#ss3.167">ser_close</A>
<LI><A NAME="toc3.168">3.168</A> <A HREF="funcref.html#ss3.168">ser_get</A>
<LI><A NAME="toc3.169">3.169</A> <A HREF="funcref.html#ss3.169">ser_install</A>
<LI><A NAME="toc3.170">3.170</A> <A HREF="funcref.html#ss3.170">ser_ioctl</A>
<LI><A NAME="toc3.171">3.171</A> <A HREF="funcref.html#ss3.171">ser_load_driver</A>
<LI><A NAME="toc3.172">3.172</A> <A HREF="funcref.html#ss3.172">ser_open</A>
<LI><A NAME="toc3.173">3.173</A> <A HREF="funcref.html#ss3.173">ser_put</A>
<LI><A NAME="toc3.174">3.174</A> <A HREF="funcref.html#ss3.174">ser_status</A>
<LI><A NAME="toc3.175">3.175</A> <A HREF="funcref.html#ss3.175">ser_uninstall</A>
<LI><A NAME="toc3.176">3.176</A> <A HREF="funcref.html#ss3.176">ser_unload</A>
<LI><A NAME="toc3.177">3.177</A> <A HREF="funcref.html#ss3.177">set_brk</A>
<LI><A NAME="toc3.178">3.178</A> <A HREF="funcref.html#ss3.178">set_irq</A>
<LI><A NAME="toc3.179">3.179</A> <A HREF="funcref.html#ss3.179">setjmp</A>
<LI><A NAME="toc3.180">3.180</A> <A HREF="funcref.html#ss3.180">setlocale</A>
<LI><A NAME="toc3.181">3.181</A> <A HREF="funcref.html#ss3.181">signal</A>
<LI><A NAME="toc3.182">3.182</A> <A HREF="funcref.html#ss3.182">sleep</A>
<LI><A NAME="toc3.183">3.183</A> <A HREF="funcref.html#ss3.183">slow</A>
<LI><A NAME="toc3.184">3.184</A> <A HREF="funcref.html#ss3.184">srand</A>
<LI><A NAME="toc3.185">3.185</A> <A HREF="funcref.html#ss3.185">strcasecmp</A>
<LI><A NAME="toc3.186">3.186</A> <A HREF="funcref.html#ss3.186">strcat</A>
<LI><A NAME="toc3.187">3.187</A> <A HREF="funcref.html#ss3.187">strchr</A>
<LI><A NAME="toc3.188">3.188</A> <A HREF="funcref.html#ss3.188">strcmp</A>
<LI><A NAME="toc3.189">3.189</A> <A HREF="funcref.html#ss3.189">strcoll</A>
<LI><A NAME="toc3.190">3.190</A> <A HREF="funcref.html#ss3.190">strcpy</A>
<LI><A NAME="toc3.191">3.191</A> <A HREF="funcref.html#ss3.191">strcspn</A>
<LI><A NAME="toc3.192">3.192</A> <A HREF="funcref.html#ss3.192">strdup</A>
<LI><A NAME="toc3.193">3.193</A> <A HREF="funcref.html#ss3.193">strerror</A>
<LI><A NAME="toc3.194">3.194</A> <A HREF="funcref.html#ss3.194">stricmp</A>
<LI><A NAME="toc3.195">3.195</A> <A HREF="funcref.html#ss3.195">strlen</A>
<LI><A NAME="toc3.196">3.196</A> <A HREF="funcref.html#ss3.196">strlower</A>
<LI><A NAME="toc3.197">3.197</A> <A HREF="funcref.html#ss3.197">strlwr</A>
<LI><A NAME="toc3.198">3.198</A> <A HREF="funcref.html#ss3.198">strncat</A>
<LI><A NAME="toc3.199">3.199</A> <A HREF="funcref.html#ss3.199">strncmp</A>
<LI><A NAME="toc3.200">3.200</A> <A HREF="funcref.html#ss3.200">strncpy</A>
<LI><A NAME="toc3.201">3.201</A> <A HREF="funcref.html#ss3.201">strqtok</A>
<LI><A NAME="toc3.202">3.202</A> <A HREF="funcref.html#ss3.202">strrchr</A>
<LI><A NAME="toc3.203">3.203</A> <A HREF="funcref.html#ss3.203">strspn</A>
<LI><A NAME="toc3.204">3.204</A> <A HREF="funcref.html#ss3.204">strstr</A>
<LI><A NAME="toc3.205">3.205</A> <A HREF="funcref.html#ss3.205">strtok</A>
<LI><A NAME="toc3.206">3.206</A> <A HREF="funcref.html#ss3.206">strxfrm</A>
<LI><A NAME="toc3.207">3.207</A> <A HREF="funcref.html#ss3.207">strupper</A>
<LI><A NAME="toc3.208">3.208</A> <A HREF="funcref.html#ss3.208">strupr</A>
<LI><A NAME="toc3.209">3.209</A> <A HREF="funcref.html#ss3.209">telldir</A>
<LI><A NAME="toc3.210">3.210</A> <A HREF="funcref.html#ss3.210">textcolor</A>
<LI><A NAME="toc3.211">3.211</A> <A HREF="funcref.html#ss3.211">tgi_arc</A>
<LI><A NAME="toc3.212">3.212</A> <A HREF="funcref.html#ss3.212">tgi_bar</A>
<LI><A NAME="toc3.213">3.213</A> <A HREF="funcref.html#ss3.213">tgi_circle</A>
<LI><A NAME="toc3.214">3.214</A> <A HREF="funcref.html#ss3.214">tgi_clear</A>
<LI><A NAME="toc3.215">3.215</A> <A HREF="funcref.html#ss3.215">tgi_done</A>
<LI><A NAME="toc3.216">3.216</A> <A HREF="funcref.html#ss3.216">tgi_ellipse</A>
<LI><A NAME="toc3.217">3.217</A> <A HREF="funcref.html#ss3.217">tgi_free_vectorfont</A>
<LI><A NAME="toc3.218">3.218</A> <A HREF="funcref.html#ss3.218">tgi_getaspectratio</A>
<LI><A NAME="toc3.219">3.219</A> <A HREF="funcref.html#ss3.219">tgi_getcolor</A>
<LI><A NAME="toc3.220">3.220</A> <A HREF="funcref.html#ss3.220">tgi_getcolorcount</A>
<LI><A NAME="toc3.221">3.221</A> <A HREF="funcref.html#ss3.221">tgi_getdefpalette</A>
<LI><A NAME="toc3.222">3.222</A> <A HREF="funcref.html#ss3.222">tgi_geterror</A>
<LI><A NAME="toc3.223">3.223</A> <A HREF="funcref.html#ss3.223">tgi_geterrormsg</A>
<LI><A NAME="toc3.224">3.224</A> <A HREF="funcref.html#ss3.224">tgi_getmaxcolor</A>
<LI><A NAME="toc3.225">3.225</A> <A HREF="funcref.html#ss3.225">tgi_getmaxx</A>
<LI><A NAME="toc3.226">3.226</A> <A HREF="funcref.html#ss3.226">tgi_getmaxy</A>
<LI><A NAME="toc3.227">3.227</A> <A HREF="funcref.html#ss3.227">tgi_getpagecount</A>
<LI><A NAME="toc3.228">3.228</A> <A HREF="funcref.html#ss3.228">tgi_getpalette</A>
<LI><A NAME="toc3.229">3.229</A> <A HREF="funcref.html#ss3.229">tgi_getpixel</A>
<LI><A NAME="toc3.230">3.230</A> <A HREF="funcref.html#ss3.230">tgi_getxres</A>
<LI><A NAME="toc3.231">3.231</A> <A HREF="funcref.html#ss3.231">tgi_getyres</A>
<LI><A NAME="toc3.232">3.232</A> <A HREF="funcref.html#ss3.232">tgi_gotoxy</A>
<LI><A NAME="toc3.233">3.233</A> <A HREF="funcref.html#ss3.233">tgi_init</A>
<LI><A NAME="toc3.234">3.234</A> <A HREF="funcref.html#ss3.234">tgi_install</A>
<LI><A NAME="toc3.235">3.235</A> <A HREF="funcref.html#ss3.235">tgi_install_vectorfont</A>
<LI><A NAME="toc3.236">3.236</A> <A HREF="funcref.html#ss3.236">tgi_ioctl</A>
<LI><A NAME="toc3.237">3.237</A> <A HREF="funcref.html#ss3.237">tgi_line</A>
<LI><A NAME="toc3.238">3.238</A> <A HREF="funcref.html#ss3.238">tgi_lineto</A>
<LI><A NAME="toc3.239">3.239</A> <A HREF="funcref.html#ss3.239">tgi_load_driver</A>
<LI><A NAME="toc3.240">3.240</A> <A HREF="funcref.html#ss3.240">tgi_load_vectorfont</A>
<LI><A NAME="toc3.241">3.241</A> <A HREF="funcref.html#ss3.241">tgi_outtext</A>
<LI><A NAME="toc3.242">3.242</A> <A HREF="funcref.html#ss3.242">tgi_outtextxy</A>
<LI><A NAME="toc3.243">3.243</A> <A HREF="funcref.html#ss3.243">tgi_pieslice</A>
<LI><A NAME="toc3.244">3.244</A> <A HREF="funcref.html#ss3.244">tgi_setaspectratio</A>
<LI><A NAME="toc3.245">3.245</A> <A HREF="funcref.html#ss3.245">tgi_setcolor</A>
<LI><A NAME="toc3.246">3.246</A> <A HREF="funcref.html#ss3.246">tgi_setdrawpage</A>
<LI><A NAME="toc3.247">3.247</A> <A HREF="funcref.html#ss3.247">tgi_setpalette</A>
<LI><A NAME="toc3.248">3.248</A> <A HREF="funcref.html#ss3.248">tgi_setpixel</A>
<LI><A NAME="toc3.249">3.249</A> <A HREF="funcref.html#ss3.249">tgi_setviewpage</A>
<LI><A NAME="toc3.250">3.250</A> <A HREF="funcref.html#ss3.250">tgi_gettextheight</A>
<LI><A NAME="toc3.251">3.251</A> <A HREF="funcref.html#ss3.251">tgi_settextscale</A>
<LI><A NAME="toc3.252">3.252</A> <A HREF="funcref.html#ss3.252">tgi_settextstyle</A>
<LI><A NAME="toc3.253">3.253</A> <A HREF="funcref.html#ss3.253">tgi_gettextwidth</A>
<LI><A NAME="toc3.254">3.254</A> <A HREF="funcref.html#ss3.254">tgi_uninstall</A>
<LI><A NAME="toc3.255">3.255</A> <A HREF="funcref.html#ss3.255">tgi_unload</A>
<LI><A NAME="toc3.256">3.256</A> <A HREF="funcref.html#ss3.256">time</A>
<LI><A NAME="toc3.257">3.257</A> <A HREF="funcref.html#ss3.257">toggle_videomode</A>
<LI><A NAME="toc3.258">3.258</A> <A HREF="funcref.html#ss3.258">tolower</A>
<LI><A NAME="toc3.259">3.259</A> <A HREF="funcref.html#ss3.259">toupper</A>
<LI><A NAME="toc3.260">3.260</A> <A HREF="funcref.html#ss3.260">ultoa</A>
<LI><A NAME="toc3.261">3.261</A> <A HREF="funcref.html#ss3.261">unlink</A>
<LI><A NAME="toc3.262">3.262</A> <A HREF="funcref.html#ss3.262">utoa</A>
<LI><A NAME="toc3.263">3.263</A> <A HREF="funcref.html#ss3.263">vcprintf</A>
<LI><A NAME="toc3.264">3.264</A> <A HREF="funcref.html#ss3.264">videomode</A>
<LI><A NAME="toc3.265">3.265</A> <A HREF="funcref.html#ss3.265">wherex</A>
<LI><A NAME="toc3.266">3.266</A> <A HREF="funcref.html#ss3.266">wherey</A>
</UL>

<HR>
<H2><A NAME="s1">1.</A> <A HREF="#toc1">Introduction</A></H2>


<P>cc65 is a C compiler for 6502 based systems. It implements a subset of the ISO
C standard plus additional functions specially crafted for 6502 systems or
just some of the supported machines. This function refrence describes the
available functions together with any limitations.</P>
<P>For an overview about the available libraries, their purpose, and any
differences to the ISO standard, please have a look at the 
<A HREF="library.html">cc65 Library Overview</A>.</P>
<P><EM>Note:</EM> Standard C functions are listed here, but not described in detail.
Since these functions behave identical on all standard compliant systems, they
are described in any book covering standard C.</P>
<P>Each entry for a function contains a detailed description</P>
<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Summary of what <B>function</B> does.</P>
<DT><B>Header</B><DD>
<P>The header file that contains the declaration.</P>
<DT><B>Declaration</B><DD>
<P>Describes the needed header files and declaration of the
function.</P>
<DT><B>Description</B><DD>
<P>Description of the function.</P>
<DT><B>Limits</B><DD>
<P>Limits.</P>
<DT><B>Availability</B><DD>
<P>The availability of the function.</P>
<DT><B>See also</B><DD>
<P>Other related functions.</P>
<DT><B>Example</B><DD>
<P>A piece of actual code using the function.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="s2">2.</A> <A HREF="#toc2">Functions by header file</A></H2>



<H2><A NAME="6502.h"></A> <A NAME="ss2.1">2.1</A> <A HREF="#toc2.1"><CODE>6502.h</CODE></A>
</H2>


<P>
<UL>
<LI>
<A HREF="#BRK">BRK</A></LI>
<LI>
<A HREF="#CLI">CLI</A></LI>
<LI>
<A HREF="#SEI">SEI</A></LI>
<LI>
<A HREF="#_sys">_sys</A></LI>
<LI>
<A HREF="#getcpu">getcpu</A></LI>
<LI>
<A HREF="#reset_brk">reset_brk</A></LI>
<LI>
<A HREF="#reset_irq">reset_irq</A></LI>
<LI>
<A HREF="#set_brk">set_brk</A></LI>
<LI>
<A HREF="#set_irq">set_irq</A></LI>
</UL>
</P>


<H2><A NAME="apple2.h"></A> <A NAME="ss2.2">2.2</A> <A HREF="#toc2.2"><CODE>apple2.h</CODE></A>
</H2>


<P>
<UL>
<LI>_dos_type</LI>
<LI>
<A HREF="#get_ostype">get_ostype</A></LI>
<LI>rebootafterexit</LI>
</UL>
</P>


<H2><A NAME="apple2enh.h"></A> <A NAME="ss2.3">2.3</A> <A HREF="#toc2.3"><CODE>apple2enh.h</CODE></A>
</H2>


<P>
<UL>
<LI>_dos_type</LI>
<LI>
<A HREF="#get_ostype">get_ostype</A></LI>
<LI>rebootafterexit</LI>
<LI>textframe</LI>
<LI>textframexy</LI>
<LI>
<A HREF="#videomode">videomode</A></LI>
</UL>
</P>


<H2><A NAME="assert.h"></A> <A NAME="ss2.4">2.4</A> <A HREF="#toc2.4"><CODE>assert.h</CODE></A>
</H2>


<P>
<UL>
<LI>
<A HREF="#assert">assert</A></LI>
</UL>
</P>


<H2><A NAME="atari.h"></A> <A NAME="ss2.5">2.5</A> <A HREF="#toc2.5"><CODE>atari.h</CODE></A>
</H2>


<P>
<UL>
<LI>
<A HREF="#get_ostype">get_ostype</A></LI>
</UL>
</P>
<P>(incomplete)</P>


<H2><A NAME="atmos.h"></A> <A NAME="ss2.6">2.6</A> <A HREF="#toc2.6"><CODE>atmos.h</CODE></A>
</H2>


<P>
<UL>
<LI>
<A HREF="#atmos_load">atmos_load</A></LI>
<LI>
<A HREF="#atmos_save">atmos_save</A></LI>
</UL>
</P>
<P>(incomplete)</P>


<H2><A NAME="c128.h"></A> <A NAME="ss2.7">2.7</A> <A HREF="#toc2.7"><CODE>c128.h</CODE></A>
</H2>


<P>
<UL>
<LI>
<A HREF="#c64mode">c64mode</A></LI>
<LI>
<A HREF="#fast">fast</A></LI>
<LI>
<A HREF="#slow">slow</A></LI>
<LI>
<A HREF="#toggle_videomode">toggle_videomode</A></LI>
<LI>
<A HREF="#videomode">videomode</A></LI>
</UL>
</P>


<H2><A NAME="c16.h"></A> <A NAME="ss2.8">2.8</A> <A HREF="#toc2.8"><CODE>c16.h</CODE></A>
</H2>


<P>(incomplete)</P>


<H2><A NAME="c64.h"></A> <A NAME="ss2.9">2.9</A> <A HREF="#toc2.9"><CODE>c64.h</CODE></A>
</H2>


<P>
<UL>
<LI>
<A HREF="#get_ostype">get_ostype</A></LI>
</UL>
</P>


<H2><A NAME="cbm.h"></A> <A NAME="ss2.10">2.10</A> <A HREF="#toc2.10"><CODE>cbm.h</CODE></A>
</H2>


<P>
<UL>
<LI>
<A HREF="#cbm_k_acptr">cbm_k_acptr</A></LI>
<LI>
<A HREF="#cbm_k_basin">cbm_k_basin</A></LI>
<LI>
<A HREF="#cbm_k_bsout">cbm_k_bsout</A></LI>
<LI>
<A HREF="#cbm_k_chkin">cbm_k_chkin</A></LI>
<LI>
<A HREF="#cbm_k_ciout">cbm_k_ciout</A></LI>
<LI>
<A HREF="#cbm_k_ckout">cbm_k_ckout</A></LI>
<LI>
<A HREF="#cbm_k_clall">cbm_k_clall</A></LI>
<LI>
<A HREF="#cbm_k_close">cbm_k_close</A></LI>
<LI>
<A HREF="#cbm_k_clrch">cbm_k_clrch</A></LI>
<LI>
<A HREF="#cbm_k_getin">cbm_k_getin</A></LI>
<LI>
<A HREF="#cbm_k_iobase">cbm_k_iobase</A></LI>
<LI>
<A HREF="#cbm_k_listen">cbm_k_listen</A></LI>
<LI>
<A HREF="#cbm_k_load">cbm_k_load</A></LI>
<LI>
<A HREF="#cbm_k_open">cbm_k_open</A></LI>
<LI>
<A HREF="#cbm_k_readst">cbm_k_readst</A></LI>
<LI>
<A HREF="#cbm_k_save">cbm_k_save</A></LI>
<LI>
<A HREF="#cbm_k_setlfs">cbm_k_setlfs</A></LI>
<LI>
<A HREF="#cbm_k_setnam">cbm_k_setnam</A></LI>
<LI>
<A HREF="#cbm_k_unlsn">cbm_k_unlsn</A></LI>
</UL>
</P>
<P>(incomplete)</P>


<H2><A NAME="cbm510.h"></A> <A NAME="ss2.11">2.11</A> <A HREF="#toc2.11"><CODE>cbm510.h</CODE></A>
</H2>


<P>
<UL>
<LI>
<A HREF="#peekbsys">peekbsys</A></LI>
<LI>
<A HREF="#peekwsys">peekwsys</A></LI>
<LI>
<A HREF="#pokebsys">pokebsys</A></LI>
<LI>
<A HREF="#pokewsys">pokewsys</A></LI>
</UL>
</P>


<H2><A NAME="cbm610.h"></A> <A NAME="ss2.12">2.12</A> <A HREF="#toc2.12"><CODE>cbm610.h</CODE></A>
</H2>


<P>
<UL>
<LI>
<A HREF="#peekbsys">peekbsys</A></LI>
<LI>
<A HREF="#peekwsys">peekwsys</A></LI>
<LI>
<A HREF="#pokebsys">pokebsys</A></LI>
<LI>
<A HREF="#pokewsys">pokewsys</A></LI>
</UL>
</P>


<H2><A NAME="cc65.h"></A> <A NAME="ss2.13">2.13</A> <A HREF="#toc2.13"><CODE>cc65.h</CODE></A>
</H2>



<P>(incomplete)</P>


<H2><A NAME="conio.h"></A> <A NAME="ss2.14">2.14</A> <A HREF="#toc2.14"><CODE>conio.h</CODE></A>
</H2>


<P>
<UL>
<LI>
<A HREF="#bgcolor">bgcolor</A></LI>
<LI>
<A HREF="#bordercolor">bordercolor</A></LI>
<LI>
<A HREF="#cclear">cclear</A></LI>
<LI>
<A HREF="#cclearxy">cclearxy</A></LI>
<LI>
<A HREF="#cgetc">cgetc</A></LI>
<LI>
<A HREF="#chline">chline</A></LI>
<LI>
<A HREF="#chlinexy">chlinexy</A></LI>
<LI>
<A HREF="#clrscr">clrscr</A></LI>
<LI>
<A HREF="#cprintf">cprintf</A></LI>
<LI>
<A HREF="#cputc">cputc</A></LI>
<LI>
<A HREF="#cputcxy">cputcxy</A></LI>
<LI>
<A HREF="#cputs">cputs</A></LI>
<LI>
<A HREF="#cputsxy">cputsxy</A></LI>
<LI>
<A HREF="#cursor">cursor</A></LI>
<LI>
<A HREF="#cvline">cvline</A></LI>
<LI>
<A HREF="#cvlinexy">cvlinexy</A></LI>
<LI>
<A HREF="#gotox">gotox</A></LI>
<LI>
<A HREF="#gotoxy">gotoxy</A></LI>
<LI>
<A HREF="#gotoy">gotoy</A></LI>
<LI>
<A HREF="#kbhit">kbhit</A></LI>
<LI>
<A HREF="#revers">revers</A></LI>
<LI>
<A HREF="#screensize">screensize</A></LI>
<LI>
<A HREF="#textcolor">textcolor</A></LI>
<LI>
<A HREF="#vcprintf">vcprintf</A></LI>
<LI>
<A HREF="#wherex">wherex</A></LI>
<LI>
<A HREF="#wherey">wherey</A></LI>
</UL>
</P>


<H2><A NAME="ctype.h"></A> <A NAME="ss2.15">2.15</A> <A HREF="#toc2.15"><CODE>ctype.h</CODE></A>
</H2>


<P>
<UL>
<LI>
<A HREF="#isalnum">isalnum</A></LI>
<LI>
<A HREF="#isalpha">isalpha</A></LI>
<LI>
<A HREF="#isascii">isascii</A></LI>
<LI>
<A HREF="#isblank">isblank</A></LI>
<LI>
<A HREF="#iscntrl">iscntrl</A></LI>
<LI>
<A HREF="#isdigit">isdigit</A></LI>
<LI>
<A HREF="#isgraph">isgraph</A></LI>
<LI>
<A HREF="#islower">islower</A></LI>
<LI>
<A HREF="#isprint">isprint</A></LI>
<LI>
<A HREF="#ispunct">ispunct</A></LI>
<LI>
<A HREF="#isspace">isspace</A></LI>
<LI>
<A HREF="#isupper">isupper</A></LI>
<LI>
<A HREF="#isxdigit">isxdigit</A></LI>
<LI>
<A HREF="#tolower">tolower</A></LI>
<LI>
<A HREF="#toupper">toupper</A></LI>
</UL>
</P>


<H2><A NAME="dbg.h"></A> <A NAME="ss2.16">2.16</A> <A HREF="#toc2.16"><CODE>dbg.h</CODE></A>
</H2>



<P>(incomplete)</P>


<H2><A NAME="dio.h"></A> <A NAME="ss2.17">2.17</A> <A HREF="#toc2.17"><CODE>dio.h</CODE></A>
</H2>


<P>
<A HREF="dio.html">Low-level disk I/O API</A>.</P>


<H2><A NAME="dirent.h"></A> <A NAME="ss2.18">2.18</A> <A HREF="#toc2.18"><CODE>dirent.h</CODE></A>
</H2>


<P>
<UL>
<LI>
<A HREF="#_DE_ISDIR">_DE_ISDIR</A></LI>
<LI>
<A HREF="#_DE_ISLBL">_DE_ISLBL</A></LI>
<LI>
<A HREF="#_DE_ISLNK">_DE_ISLNK</A></LI>
<LI>
<A HREF="#_DE_ISREG">_DE_ISREG</A></LI>
<LI>
<A HREF="#closedir">closedir</A></LI>
<LI>
<A HREF="#opendir">opendir</A></LI>
<LI>
<A HREF="#readdir">readdir</A></LI>
<LI>
<A HREF="#rewinddir">rewinddir</A></LI>
<LI>
<A HREF="#seekdir">seekdir</A></LI>
<LI>
<A HREF="#telldir">telldir</A></LI>
</UL>
</P>
<P>(incomplete)</P>


<H2><A NAME="em.h"></A> <A NAME="ss2.19">2.19</A> <A HREF="#toc2.19"><CODE>em.h</CODE></A>
</H2>


<P>
<UL>
<LI>
<A HREF="#em_commit">em_commit</A></LI>
<LI>
<A HREF="#em_copyfrom">em_copyfrom</A></LI>
<LI>
<A HREF="#em_copyto">em_copyto</A></LI>
<LI>
<A HREF="#em_install">em_install</A></LI>
<LI>
<A HREF="#em_load_driver">em_load_driver</A></LI>
<LI>
<A HREF="#em_map">em_map</A></LI>
<LI>
<A HREF="#em_pagecount">em_pagecount</A></LI>
<LI>
<A HREF="#em_uninstall">em_uninstall</A></LI>
<LI>
<A HREF="#em_unload">em_unload</A></LI>
<LI>
<A HREF="#em_use">em_use</A></LI>
</UL>
</P>


<H2><A NAME="errno.h"></A> <A NAME="ss2.20">2.20</A> <A HREF="#toc2.20"><CODE>errno.h</CODE></A>
</H2>



<P>(incomplete)</P>


<H2><A NAME="fcntl.h"></A> <A NAME="ss2.21">2.21</A> <A HREF="#toc2.21"><CODE>fcntl.h</CODE></A>
</H2>


<P>
<UL>
<LI>
<A HREF="#close">close</A></LI>
<LI>
<A HREF="#creat">creat</A></LI>
<LI>
<A HREF="#open">open</A></LI>
</UL>
</P>


<H2><A NAME="geos.h"></A> <A NAME="ss2.22">2.22</A> <A HREF="#toc2.22"><CODE>geos.h</CODE></A>
</H2>


<P>(incomplete)</P>


<H2><A NAME="joystick.h"></A> <A NAME="ss2.23">2.23</A> <A HREF="#toc2.23"><CODE>joystick.h</CODE></A>
</H2>


<P>
<UL>
<LI>
<A HREF="#joy_count">joy_count</A></LI>
<LI>
<A HREF="#joy_install">joy_install</A></LI>
<LI>
<A HREF="#joy_load_driver">joy_load_driver</A></LI>
<LI>
<A HREF="#joy_read">joy_read</A></LI>
<LI>
<A HREF="#joy_uninstall">joy_uninstall</A></LI>
<LI>
<A HREF="#joy_unload">joy_unload</A></LI>
</UL>
</P>


<H2><A NAME="locale.h"></A> <A NAME="ss2.24">2.24</A> <A HREF="#toc2.24"><CODE>locale.h</CODE></A>
</H2>


<P>
<UL>
<LI>
<A HREF="#localeconv">localeconv</A></LI>
<LI>
<A HREF="#setlocale">setlocale</A></LI>
</UL>
</P>


<H2><A NAME="lynx.h"></A> <A NAME="ss2.25">2.25</A> <A HREF="#toc2.25"><CODE>lynx.h</CODE></A>
</H2>



<P>(incomplete)</P>


<H2><A NAME="modload.h"></A> <A NAME="ss2.26">2.26</A> <A HREF="#toc2.26"><CODE>modload.h</CODE></A>
</H2>


<P>
<UL>
<LI>
<A HREF="#mod_load">mod_load</A></LI>
<LI>
<A HREF="#mod_free">mod_free</A></LI>
</UL>
</P>


<H2><A NAME="mouse.h"></A> <A NAME="ss2.27">2.27</A> <A HREF="#toc2.27"><CODE>mouse.h</CODE></A>
</H2>


<P>
<UL>
<LI>
<A HREF="#mouse_buttons">mouse_buttons</A></LI>
<LI>
<A HREF="#mouse_getbox">mouse_getbox</A></LI>
<LI>
<A HREF="#mouse_geterrormsg">mouse_geterrormsg</A></LI>
<LI>
<A HREF="#mouse_hide">mouse_hide</A></LI>
<LI>
<A HREF="#mouse_info">mouse_info</A></LI>
<LI>
<A HREF="#mouse_install">mouse_install</A></LI>
<LI>
<A HREF="#mouse_ioctl">mouse_ioctl</A></LI>
<LI>
<A HREF="#mouse_load_driver">mouse_load_driver</A></LI>
<LI>
<A HREF="#mouse_move">mouse_move</A></LI>
<LI>
<A HREF="#mouse_pos">mouse_pos</A></LI>
<LI>
<A HREF="#mouse_setbox">mouse_setbox</A></LI>
<LI>
<A HREF="#mouse_show">mouse_show</A></LI>
<LI>
<A HREF="#mouse_uninstall">mouse_uninstall</A></LI>
<LI>
<A HREF="#mouse_unload">mouse_unload</A></LI>
</UL>
</P>


<H2><A NAME="nes.h"></A> <A NAME="ss2.28">2.28</A> <A HREF="#toc2.28"><CODE>nes.h</CODE></A>
</H2>



<P>(incomplete)</P>


<H2><A NAME="o65.h"></A> <A NAME="ss2.29">2.29</A> <A HREF="#toc2.29"><CODE>o65.h</CODE></A>
</H2>


<P>The <CODE>o65.h</CODE> header file contains structure and constant definitions that
may be used when dealing with files in 
<A HREF="http://www.6502.org/users/andre/o65/fileformat.html">the o65 format</A>.
It does not declare any functions.</P>


<H2><A NAME="peekpoke.h"></A> <A NAME="ss2.30">2.30</A> <A HREF="#toc2.30"><CODE>peekpoke.h</CODE></A>
</H2>


<P>
<UL>
<LI>
<A HREF="#PEEK">PEEK</A></LI>
<LI>
<A HREF="#PEEKW">PEEKW</A></LI>
<LI>
<A HREF="#POKE">POKE</A></LI>
<LI>
<A HREF="#POKEW">POKEW</A></LI>
</UL>
</P>


<H2><A NAME="pet.h"></A> <A NAME="ss2.31">2.31</A> <A HREF="#toc2.31"><CODE>pet.h</CODE></A>
</H2>


<P>(incomplete)</P>


<H2><A NAME="plus4.h"></A> <A NAME="ss2.32">2.32</A> <A HREF="#toc2.32"><CODE>plus4.h</CODE></A>
</H2>


<P>(incomplete)</P>


<H2><A NAME="serial.h"></A> <A NAME="ss2.33">2.33</A> <A HREF="#toc2.33"><CODE>serial.h</CODE></A>
</H2>


<P>The <CODE>serial.h</CODE> header file contains definitions for initializing serial
communication.</P>
<P>
<UL>
<LI>
<A HREF="#ser_close">ser_close</A></LI>
<LI>
<A HREF="#ser_get">ser_get</A></LI>
<LI>
<A HREF="#ser_install">ser_install</A></LI>
<LI>
<A HREF="#ser_ioctl">ser_ioctl</A></LI>
<LI>
<A HREF="#ser_load_driver">ser_load_driver</A></LI>
<LI>
<A HREF="#ser_open">ser_open</A></LI>
<LI>
<A HREF="#ser_put">ser_put</A></LI>
<LI>
<A HREF="#ser_status">ser_status</A></LI>
<LI>
<A HREF="#ser_uninstall">ser_uninstall</A></LI>
<LI>
<A HREF="#ser_unload">ser_unload</A></LI>
</UL>
</P>


<H2><A NAME="setjmp.h"></A> <A NAME="ss2.34">2.34</A> <A HREF="#toc2.34"><CODE>setjmp.h</CODE></A>
</H2>


<P>
<UL>
<LI>
<A HREF="#setjmp">setjmp</A></LI>
<LI>
<A HREF="#longjmp">longjmp</A></LI>
</UL>
</P>


<H2><A NAME="signal.h"></A> <A NAME="ss2.35">2.35</A> <A HREF="#toc2.35"><CODE>signal.h</CODE></A>
</H2>


<P>
<UL>
<LI>
<A HREF="#raise">raise</A></LI>
<LI>
<A HREF="#signal">signal</A></LI>
</UL>
</P>


<H2><A NAME="stdarg.h"></A> <A NAME="ss2.36">2.36</A> <A HREF="#toc2.36"><CODE>stdarg.h</CODE></A>
</H2>


<P>(incomplete)</P>


<H2><A NAME="stdbool.h"></A> <A NAME="ss2.37">2.37</A> <A HREF="#toc2.37"><CODE>stdbool.h</CODE></A>
</H2>


<P>(incomplete)</P>


<H2><A NAME="stddef.h"></A> <A NAME="ss2.38">2.38</A> <A HREF="#toc2.38"><CODE>stddef.h</CODE></A>
</H2>


<P>
<UL>
<LI>
<A HREF="#offsetof">offsetof</A></LI>
</UL>
</P>


<H2><A NAME="stdio.h"></A> <A NAME="ss2.39">2.39</A> <A HREF="#toc2.39"><CODE>stdio.h</CODE></A>
</H2>


<P>
<UL>
<LI>
<A HREF="#_poserror">_poserror</A></LI>
<LI>
<A HREF="#clearerr">clearerr</A></LI>
<LI>
<A HREF="#feof">feof</A></LI>
<LI>
<A HREF="#ferror">ferror</A></LI>
<LI>
<A HREF="#fileno">fileno</A></LI>
<LI>
<A HREF="#rename">rename</A></LI>
<LI>
<A HREF="#remove">remove</A></LI>
</UL>
</P>
<P>(incomplete)</P>


<H2><A NAME="stdlib.h"></A> <A NAME="ss2.40">2.40</A> <A HREF="#toc2.40"><CODE>stdlib.h</CODE></A>
</H2>


<P>
<UL>
<LI>
<A HREF="#_heapadd">_heapadd</A></LI>
<LI>
<A HREF="#_heapblocksize">_heapblocksize</A></LI>
<LI>
<A HREF="#_heapmaxavail">_heapmaxavail</A></LI>
<LI>
<A HREF="#_heapmemavail">_heapmemavail</A></LI>
<LI>
<A HREF="#_randomize">_randomize</A></LI>
<LI>
<A HREF="#_swap">_swap</A></LI>
<LI>
<A HREF="#abort">abort</A></LI>
<LI>
<A HREF="#abs">abs</A></LI>
<LI>
<A HREF="#atexit">atexit</A></LI>
<LI>
<A HREF="#atoi">atoi</A></LI>
<LI>
<A HREF="#atol">atol</A></LI>
<LI>
<A HREF="#bsearch">bsearch</A></LI>
<LI>
<A HREF="#calloc">calloc</A></LI>
<LI>
<A HREF="#div">div</A></LI>
<LI>
<A HREF="#exit">exit</A></LI>
<LI>
<A HREF="#free">free</A></LI>
<LI>
<A HREF="#getenv">getenv</A></LI>
<LI>
<A HREF="#itoa">itoa</A></LI>
<LI>
<A HREF="#labs">labs</A></LI>
<LI>
<A HREF="#ltoa">ltoa</A></LI>
<LI>
<A HREF="#malloc">malloc</A></LI>
<LI>
<A HREF="#perror">perror</A></LI>
<LI>
<A HREF="#qsort">qsort</A></LI>
<LI>
<A HREF="#rand">rand</A></LI>
<LI>
<A HREF="#realloc">realloc</A></LI>
<LI>
<A HREF="#srand">srand</A></LI>
<LI>
<A HREF="#ultoa">ultoa</A></LI>
<LI>
<A HREF="#utoa">utoa</A></LI>
</UL>
</P>
<P>(incomplete)</P>


<H2><A NAME="string.h"></A> <A NAME="ss2.41">2.41</A> <A HREF="#toc2.41"><CODE>string.h</CODE></A>
</H2>


<P>
<UL>
<LI>
<A HREF="#_stroserror">_stroserror</A></LI>
<LI>
<A HREF="#bzero">bzero</A></LI>
<LI>
<A HREF="#memchr">memchr</A></LI>
<LI>
<A HREF="#memcmp">memcmp</A></LI>
<LI>
<A HREF="#memcpy">memcpy</A></LI>
<LI>
<A HREF="#memmove">memmove</A></LI>
<LI>
<A HREF="#memset">memset</A></LI>
<LI>
<A HREF="#strcasecmp">strcasecmp</A></LI>
<LI>
<A HREF="#strcat">strcat</A></LI>
<LI>
<A HREF="#strchr">strchr</A></LI>
<LI>
<A HREF="#strcmp">strcmp</A></LI>
<LI>
<A HREF="#strcoll">strcoll</A></LI>
<LI>
<A HREF="#strcpy">strcpy</A></LI>
<LI>
<A HREF="#strcspn">strcspn</A></LI>
<LI>
<A HREF="#strdup">strdup</A></LI>
<LI>
<A HREF="#strerror">strerror</A></LI>
<LI>
<A HREF="#stricmp">stricmp</A></LI>
<LI>
<A HREF="#strlen">strlen</A></LI>
<LI>
<A HREF="#strlower">strlower</A></LI>
<LI>
<A HREF="#strlwr">strlwr</A></LI>
<LI>
<A HREF="#strncat">strncat</A></LI>
<LI>
<A HREF="#strncmp">strncmp</A></LI>
<LI>
<A HREF="#strncpy">strncpy</A></LI>
<LI>
<A HREF="#strqtok">strqtok</A></LI>
<LI>
<A HREF="#strrchr">strrchr</A></LI>
<LI>
<A HREF="#strspn">strspn</A></LI>
<LI>
<A HREF="#strstr">strstr</A></LI>
<LI>
<A HREF="#strtok">strtok</A></LI>
<LI>
<A HREF="#strxfrm">strxfrm</A></LI>
<LI>
<A HREF="#strupper">strupper</A></LI>
<LI>
<A HREF="#strupr">strupr</A></LI>
</UL>
</P>
<P>(incomplete)</P>


<H2><A NAME="tgi.h"></A> <A NAME="ss2.42">2.42</A> <A HREF="#toc2.42"><CODE>tgi.h</CODE></A>
</H2>


<P>
<UL>
<LI>
<A HREF="#tgi_arc">tgi_arc</A></LI>
<LI>
<A HREF="#tgi_bar">tgi_bar</A></LI>
<LI>
<A HREF="#tgi_circle">tgi_circle</A></LI>
<LI>
<A HREF="#tgi_clear">tgi_clear</A></LI>
<LI>
<A HREF="#tgi_done">tgi_done</A></LI>
<LI>
<A HREF="#tgi_ellipse">tgi_ellipse</A></LI>
<LI>
<A HREF="#tgi_free_vectorfont">tgi_free_vectorfont</A></LI>
<LI>
<A HREF="#tgi_getaspectratio">tgi_getaspectratio</A></LI>
<LI>
<A HREF="#tgi_getcolor">tgi_getcolor</A></LI>
<LI>
<A HREF="#tgi_getcolorcount">tgi_getcolorcount</A></LI>
<LI>
<A HREF="#tgi_getdefpalette">tgi_getdefpalette</A></LI>
<LI>
<A HREF="#tgi_geterror">tgi_geterror</A></LI>
<LI>
<A HREF="#tgi_geterrormsg">tgi_geterrormsg</A></LI>
<LI>
<A HREF="#tgi_getmaxcolor">tgi_getmaxcolor</A></LI>
<LI>
<A HREF="#tgi_getmaxx">tgi_getmaxx</A></LI>
<LI>
<A HREF="#tgi_getmaxy">tgi_getmaxy</A></LI>
<LI>
<A HREF="#tgi_getpagecount">tgi_getpagecount</A></LI>
<LI>
<A HREF="#tgi_getpalette">tgi_getpalette</A></LI>
<LI>
<A HREF="#tgi_getpixel">tgi_getpixel</A></LI>
<LI>
<A HREF="#tgi_gettextheight">tgi_gettextheight</A></LI>
<LI>
<A HREF="#tgi_gettextwidth">tgi_gettextwidth</A></LI>
<LI>
<A HREF="#tgi_getxres">tgi_getxres</A></LI>
<LI>
<A HREF="#tgi_getyres">tgi_getyres</A></LI>
<LI>
<A HREF="#tgi_gotoxy">tgi_gotoxy</A></LI>
<LI>
<A HREF="#tgi_init">tgi_init</A></LI>
<LI>
<A HREF="#tgi_install">tgi_install</A></LI>
<LI>
<A HREF="#tgi_install_vectorfont">tgi_install_vectorfont</A></LI>
<LI>
<A HREF="#tgi_ioctl">tgi_ioctl</A></LI>
<LI>
<A HREF="#tgi_line">tgi_line</A></LI>
<LI>
<A HREF="#tgi_lineto">tgi_lineto</A></LI>
<LI>
<A HREF="#tgi_load_driver">tgi_load_driver</A></LI>
<LI>
<A HREF="#tgi_load_vectorfont">tgi_load_vectorfont</A></LI>
<LI>
<A HREF="#tgi_outtext">tgi_outtext</A></LI>
<LI>
<A HREF="#tgi_outtextxy">tgi_outtextxy</A></LI>
<LI>
<A HREF="#tgi_setaspectratio">tgi_setaspectratio</A></LI>
<LI>
<A HREF="#tgi_setcolor">tgi_setcolor</A></LI>
<LI>
<A HREF="#tgi_setdrawpage">tgi_setdrawpage</A></LI>
<LI>
<A HREF="#tgi_setpalette">tgi_setpalette</A></LI>
<LI>
<A HREF="#tgi_setpixel">tgi_setpixel</A></LI>
<LI>
<A HREF="#tgi_setviewpage">tgi_setviewpage</A></LI>
<LI>
<A HREF="#tgi_settextscale">tgi_settextscale</A></LI>
<LI>
<A HREF="#tgi_settextstyle">tgi_settextstyle</A></LI>
<LI>
<A HREF="#tgi_uninstall">tgi_uninstall</A></LI>
<LI>
<A HREF="#tgi_unload">tgi_unload</A></LI>
</UL>
</P>

<H2><A NAME="time.h"></A> <A NAME="ss2.43">2.43</A> <A HREF="#toc2.43"><CODE>time.h</CODE></A>
</H2>


<P>
<UL>
<LI>
<A HREF="#clock">clock</A></LI>
<LI>
<A HREF="#time">time</A></LI>
</UL>
</P>
<P>(incomplete)</P>


<H2><A NAME="unistd.h"></A> <A NAME="ss2.44">2.44</A> <A HREF="#toc2.44"><CODE>unistd.h</CODE></A>
</H2>


<P>
<UL>
<LI>
<A HREF="#exec">exec</A></LI>
<LI>
<A HREF="#getopt">getopt</A></LI>
<LI>
<A HREF="#sleep">sleep</A></LI>
<LI>
<A HREF="#unlink">unlink</A></LI>
</UL>
</P>
<P>(incomplete)</P>


<H2><A NAME="vic20.h"></A> <A NAME="ss2.45">2.45</A> <A HREF="#toc2.45"><CODE>vic20.h</CODE></A>
</H2>


<P>(incomplete)</P>


<H2><A NAME="zlib.h"></A> <A NAME="ss2.46">2.46</A> <A HREF="#toc2.46"><CODE>zlib.h</CODE></A>
</H2>



<P>(incomplete)</P>


<H2><A NAME="s3">3.</A> <A HREF="#toc3">Alphabetical function reference</A></H2>



<H2><A NAME="_DE_ISDIR"></A> <A NAME="ss3.1">3.1</A> <A HREF="#toc3.1">_DE_ISDIR</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Determine if a directory entry specifies a directory.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#dirent.h">dirent.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>int _DE_ISDIR(unsigned char type);</CODE></P>
<DT><B>Description</B><DD>
<P>The function is called with the type of a directory entry
taken from a <CODE>struct dirent</CODE> and returns true if the entry designates
a directory.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is actually a macro.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#_DE_ISLBL">_DE_ISLBL</A>,
<A HREF="#_DE_ISLNK">_DE_ISLNK</A>,
<A HREF="#_DE_ISREG">_DE_ISREG</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="_DE_ISLBL"></A> <A NAME="ss3.2">3.2</A> <A HREF="#toc3.2">_DE_ISLBL</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Determine if a directory entry specifies a disk label.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#dirent.h">dirent.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>int _DE_ISLBL(unsigned char type);</CODE></P>
<DT><B>Description</B><DD>
<P>The function is called with the type of a directory entry
taken from a <CODE>struct dirent</CODE> and returns true if the entry designates
a disk label.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is actually a macro.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#_DE_ISDIR">_DE_ISDIR</A>,
<A HREF="#_DE_ISLNK">_DE_ISLNK</A>,
<A HREF="#_DE_ISREG">_DE_ISREG</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="_DE_ISLNK"></A> <A NAME="ss3.3">3.3</A> <A HREF="#toc3.3">_DE_ISLNK</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Determine if a directory entry specifies a link.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#dirent.h">dirent.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>int _DE_ISLNK(unsigned char type);</CODE></P>
<DT><B>Description</B><DD>
<P>The function is called with the type of a directory entry
taken from a <CODE>struct dirent</CODE> and returns true if the entry designates
a link.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is actually a macro.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#_DE_ISDIR">_DE_ISDIR</A>,
<A HREF="#_DE_ISLBL">_DE_ISLBL</A>,
<A HREF="#_DE_ISREG">_DE_ISREG</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="_DE_ISREG"></A> <A NAME="ss3.4">3.4</A> <A HREF="#toc3.4">_DE_ISREG</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Determine if a directory entry specifies a regular file.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#dirent.h">dirent.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>int _DE_ISREG(unsigned char type);</CODE></P>
<DT><B>Description</B><DD>
<P>The function is called with the type of a directory entry
taken from a <CODE>struct dirent</CODE> and returns true if the entry designates
a regular file.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is actually a macro.</LI>
<LI>A "regular file" means anything with data in it. This might still mean
that special processing is needed, when accessing the file. Relative files of
the CBM systems are classified as being "regular" files, for example.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#_DE_ISDIR">_DE_ISDIR</A>,
<A HREF="#_DE_ISLBL">_DE_ISLBL</A>,
<A HREF="#_DE_ISLNK">_DE_ISLNK</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="_heapadd"></A> <A NAME="ss3.5">3.5</A> <A HREF="#toc3.5">_heapadd</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Add a block to the heap.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#stdlib.h">stdlib.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ _heapadd (void* mem, size_t size);</CODE></P>
<DT><B>Description</B><DD>
<P>The function adds a block of raw memory to the heap.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The minimum blocksize that can be added is 6 bytes; the function will
ignore smaller blocks.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#_heapblocksize">_heapblocksize</A>,
<A HREF="#_heapmaxavail">_heapmaxavail</A>,
<A HREF="#_heapmemavail">_heapmemavail</A>,
<A HREF="#calloc">calloc</A>,
<A HREF="#free">free</A>,
<A HREF="#malloc">malloc</A>,
<A HREF="#realloc">realloc</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="_heapblocksize"></A> <A NAME="ss3.6">3.6</A> <A HREF="#toc3.6">_heapblocksize</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Return the size of an allocated block.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#stdlib.h">stdlib.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>size_t __fastcall__ _heapblocksize (const void* block);</CODE></P>
<DT><B>Description</B><DD>
<P>The function returns the size of a block that must have
previously been allocated by <CODE>
<A HREF="#malloc">malloc</A></CODE>, <CODE>
<A HREF="#calloc">calloc</A></CODE> or <CODE>
<A HREF="#realloc">realloc</A></CODE>.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>Passing a pointer to a block that was is not the result of one of the
allocation functions, or that has been free'd will give unpredicable results.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#_heapadd">_heapadd</A>,
<A HREF="#_heapmaxavail">_heapmaxavail</A>,
<A HREF="#_heapmemavail">_heapmemavail</A>,
<A HREF="#calloc">calloc</A>,
<A HREF="#free">free</A>,
<A HREF="#malloc">malloc</A>,
<A HREF="#realloc">realloc</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="_heapmaxavail"></A> <A NAME="ss3.7">3.7</A> <A HREF="#toc3.7">_heapmaxavail</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Return the largest block that is available on the heap.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#stdlib.h">stdlib.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>size_t _heapmaxavail (void);</CODE></P>
<DT><B>Description</B><DD>
<P>The function returns the size of the largest block that may
be allocated from the heap using <CODE>
<A HREF="#malloc">malloc</A></CODE>.</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#_heapadd">_heapadd</A>,
<A HREF="#_heapblocksize">_heapblocksize</A>,
<A HREF="#_heapmemavail">_heapmemavail</A>,
<A HREF="#calloc">calloc</A>,
<A HREF="#free">free</A>,
<A HREF="#malloc">malloc</A>,
<A HREF="#realloc">realloc</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="_heapmemavail"></A> <A NAME="ss3.8">3.8</A> <A HREF="#toc3.8">_heapmemavail</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Return the total available space on the heap.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#stdlib.h">stdlib.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>size_t __fastcall__ _heapmemavail (void);</CODE></P>
<DT><B>Description</B><DD>
<P>The function returns the total number of bytes available on
the heap.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>This function is of less use than usually assumed, since the returned
heap space may be available but not in one block. So even if this function
says that several times more heap space is available than needed, 
<A HREF="#malloc">malloc</A> may still return <CODE>NULL</CODE>.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#_heapadd">_heapadd</A>,
<A HREF="#_heapblocksize">_heapblocksize</A>,
<A HREF="#_heapmaxavail">_heapmaxavail</A>,
<A HREF="#calloc">calloc</A>,
<A HREF="#free">free</A>,
<A HREF="#malloc">malloc</A>,
<A HREF="#realloc">realloc</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="_poserror"></A> <A NAME="ss3.9">3.9</A> <A HREF="#toc3.9">_poserror</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Print an error message for the error in <CODE>_oserror</CODE>.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#stdio.h">stdio.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ _poserror (const char* msg);</CODE></P>
<DT><B>Description</B><DD>
<P><CODE>_poserror</CODE> prints an error message to <CODE>stderr</CODE>. If
<CODE>msg</CODE> is not <CODE>NULL</CODE> and not an empty string, it is printed followed by
a colon and a blank. Then the error message for the current contents of
<CODE>_oserror</CODE> are printed followed by a newline. The message output is the
same as returned by <CODE>
<A HREF="#_stroserror">_stroserror</A></CODE> with an
argument of <CODE>_oserror</CODE>.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>Since operating system specific error code are - you guessed it -
operating system specific, the value in <CODE>_oserror</CODE> and the message that is
printed depends on the cc65 target.</LI>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#_stroserror">_stroserror</A>,
<A HREF="#perror">perror</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="_randomize"></A> <A NAME="ss3.10">3.10</A> <A HREF="#toc3.10">_randomize</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Initialize the pseudo random number generator.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#stdlib.h">stdlib.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void _randomize (void);</CODE></P>
<DT><B>Description</B><DD>
<P>The function initializes the random number generator with
a seed derived from fast changing hardware events, so the seed itself can be
considered random to a certain degree.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The randomness of the seed depends on the machine hardware.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#rand">rand</A>,
<A HREF="#srand">srand</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="_stroserror"></A> <A NAME="ss3.11">3.11</A> <A HREF="#toc3.11">_stroserror</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Return a string describing an OS specific error code.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#string.h">string.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>const char* __fastcall__ _stroserror (unsigned char errcode);</CODE></P>
<DT><B>Description</B><DD>
<P><CODE>_stroserror</CODE> will return a string describing the given
operating system specific error code.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>Since operating system specific error code are - you guessed it -
operating system specific, the parameter and the string returned depend on the
cc65 target.</LI>
<LI>The function is only available as fastcall function, so it may only be
used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#strerror">strerror</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="_swap"></A> <A NAME="ss3.12">3.12</A> <A HREF="#toc3.12">_swap</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Swap the contents of memory areas.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#stdlib.h">stdlib.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ _swap (void* p, void* q, size_t size);</CODE></P>
<DT><B>Description</B><DD>
<P><CODE>_swap</CODE> will swap (exchange) the contents of the two memory
areas pointed to by <CODE>p</CODE> and <CODE>q</CODE>. Both memory areas are assumed to be
<CODE>size</CODE> bytes in size.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The memory areas may not overlap, otherwise the results are undefined.</LI>
<LI>The function is only available as fastcall function, so it may only be
used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#memcpy">memcpy</A>,
<A HREF="#memmove">memmove</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="_sys"></A> <A NAME="ss3.13">3.13</A> <A HREF="#toc3.13">_sys</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Call a subroutine passing register values.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#6502.h">6502.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ _sys (struct regs* r);</CODE></P>
<DT><B>Description</B><DD>
<P>The function will call the subroutine at the address
specified in the <CODE>pc</CODE> member of the passed <CODE>regs</CODE> structure. All
registers and the CPU flags are set to the values given in the <CODE>regs</CODE>
structure. On return from the subroutine, the new values of the registers and
flags are stored back overwriting the old values.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>Bits 4 and 5 of the flags value in the <CODE>regs</CODE> structure are ignored
when calling the subroutine (they are unchanged from their current values).</LI>
<LI>The function is only available as fastcall function, so it may only be
used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="BRK"></A> <A NAME="ss3.14">3.14</A> <A HREF="#toc3.14">BRK</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Insert a 6502 BRK instrunction into the code.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#6502.h">6502.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void BRK (void);</CODE></P>
<DT><B>Description</B><DD>
<P>The function will insert a 6502 BRK instruction into the code
which may be used to trigger a debugger.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is actually a macro.</LI>
<LI>The inserted instruction may lead to unexpected results if no debugger
is present.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#CLI">CLI</A>,
<A HREF="#SEI">SEI</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="CLI"></A> <A NAME="ss3.15">3.15</A> <A HREF="#toc3.15">CLI</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Insert a 6502 CLI instrunction into the code.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#6502.h">6502.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void CLI (void);</CODE></P>
<DT><B>Description</B><DD>
<P>The function will insert a 6502 CLI instruction into the code,
so interrupts are enabled. Enabling interrupts has no effects if they are
already enabled (the default).</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is actually a macro.</LI>
<LI>Disabling interrupts may lead to unexpected results.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#BRK">BRK</A>,
<A HREF="#SEI">SEI</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="PEEK"></A> <A NAME="ss3.16">3.16</A> <A HREF="#toc3.16">PEEK</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Read a byte from memory.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#peekpoke.h">peekpoke.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>unsigned char PEEK (unsigned addr);</CODE></P>
<DT><B>Description</B><DD>
<P>The function will read the absolute memory given by <CODE>addr</CODE>
and return the value read.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is actually a macro.</LI>
<LI>This function depends highly on the platform and environment.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#PEEKW">PEEKW</A>,
<A HREF="#POKE">POKE</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="PEEKW"></A> <A NAME="ss3.17">3.17</A> <A HREF="#toc3.17">PEEKW</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Read a word (two bytes) from memory.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#peekpoke.h">peekpoke.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>unsigned PEEKW (unsigned addr);</CODE></P>
<DT><B>Description</B><DD>
<P>The function will read the absolute memory given by <CODE>addr</CODE>
and return the value read. The byte read from the higher address is the high
byte of the return value.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is actually a macro.</LI>
<LI>This function depends highly on the platform and environment.</LI>
<LI>The order in which the two bytes are read is unspecified and may
depend of the address expression used.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#PEEK">PEEK</A>,
<A HREF="#POKE">POKE</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="POKE"></A> <A NAME="ss3.18">3.18</A> <A HREF="#toc3.18">POKE</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Write a byte to memory.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#peekpoke.h">peekpoke.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void POKE (unsigned addr, unsigned char val);</CODE></P>
<DT><B>Description</B><DD>
<P>The function writes the value <CODE>val</CODE> to the absolute
memory address given by <CODE>addr</CODE>.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is actually a macro.</LI>
<LI>This function depends highly on the platform and environment.</LI>
<LI>Careless use will cause the program to act strange or may crash the
machine.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#PEEK">PEEK</A>,
<A HREF="#POKEW">POKEW</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="POKEW"></A> <A NAME="ss3.19">3.19</A> <A HREF="#toc3.19">POKEW</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Write a word (two bytes) to memory.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#peekpoke.h">peekpoke.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void POKEW (unsigned addr, unsigned val);</CODE></P>
<DT><B>Description</B><DD>
<P>The function writes the value <CODE>val</CODE> to the absolute
memory address given by <CODE>addr</CODE>. The low byte of <CODE>val</CODE> is written to
the <CODE>addr</CODE>, the high byte is written to <CODE>addr+1</CODE>.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is actually a macro.</LI>
<LI>This function depends highly on the platform and environment.</LI>
<LI>Careless use will cause the program to act strange or may crash the
machine.</LI>
<LI>The order in which the two bytes are written is unspecified and may
depend of the address expression used.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#PEEK">PEEK</A>,
<A HREF="#POKE">POKE</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="SEI"></A> <A NAME="ss3.20">3.20</A> <A HREF="#toc3.20">SEI</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Insert a 6502 SEI instrunction into the code.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#6502.h">6502.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void SEI (void);</CODE></P>
<DT><B>Description</B><DD>
<P>The function will insert a 6502 SEI instruction into the code,
so interrupts are disabled. Note that non maskable interrupts cannot be
disabled.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is actually a macro.</LI>
<LI>Disabling interrupts may lead to unexpected results.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#BRK">BRK</A>,
<A HREF="#CLI">CLI</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="abort"></A> <A NAME="ss3.21">3.21</A> <A HREF="#toc3.21">abort</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Terminates a program abnormally.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#stdlib.h">stdlib.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void abort (void);</CODE></P>
<DT><B>Description</B><DD>
<P><CODE>abort</CODE> raises <CODE>SIGABRT</CODE>, writes a termination message
on stderr, then terminates the program with an exit code of 3.</P>
<DT><B>Availability</B><DD>
<P>ISO 9899</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#assert">assert</A>,
<A HREF="#exit">exit</A>,
<A HREF="#raise">raise</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="abs"></A> <A NAME="ss3.22">3.22</A> <A HREF="#toc3.22">abs</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Returns the absolute value of an integer.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#stdlib.h">stdlib.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>int __fastcall__ abs (int v);</CODE></P>
<DT><B>Description</B><DD>
<P><CODE>abs</CODE> returns the absolute value of the argument passed to
the function.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The return value is undefined if <CODE>INT_MIN</CODE> is passed to the function.</LI>
<LI>The function is only available as fastcall function, so it may only be
used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>ISO 9899</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#labs">labs</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="assert"></A> <A NAME="ss3.23">3.23</A> <A HREF="#toc3.23">assert</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Test a condition and possibly abort.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#assert.h">assert.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void assert (int cond);</CODE></P>
<DT><B>Description</B><DD>
<P><CODE>assert</CODE> is a macro that expands to a <CODE>id</CODE>
statement. If the condition evaluates t zero (false), assert prints a message
on stderr and aborts the program.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is actually a macro.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>ISO 9899</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#abort">abort</A>,
<A HREF="#exit">exit</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="atexit"></A> <A NAME="ss3.24">3.24</A> <A HREF="#toc3.24">atexit</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Register an exit function.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#stdlib.h">stdlib.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>int __fastcall__ atexit (void (*exitfunc) (void));</CODE></P>
<DT><B>Description</B><DD>
<P><CODE>atexit</CODE> registers the function pointed to by
<CODE>exitfunc</CODE> as an exit function. Exit functions are called when the program
terminates, they are called in LIFO order (the last function registered is
called first). <CODE>atexit</CODE> returns zero on success and a nonzero value on
failure.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>A maximum of 5 exit functions can be registered.</LI>
<LI>There is no way to unregister an exit function.</LI>
<LI>The function is only available as fastcall function, so it may only be
used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>ISO 9899</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#abort">abort</A>,
<A HREF="#exit">exit</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="atmos_load"></A> <A NAME="ss3.25">3.25</A> <A HREF="#toc3.25">atmos_load</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Load Atmos tape.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#atmos.h">atmos.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ atmos_load(const char* name);</CODE></P>
<DT><B>Description</B><DD>
<P><CODE>atmos_load</CODE> reads a memory block from tape.</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#atmos_save">atmos_save</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="atmos_save"></A> <A NAME="ss3.26">3.26</A> <A HREF="#toc3.26">atmos_save</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Save Atmos tape.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#atmos.h">atmos.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ atmos_save(const char* name, const void* start, const void* end);</CODE></P>
<DT><B>Description</B><DD>
<P><CODE>atmos_save</CODE> writes a memory block to tape.</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#atmos_load">atmos_load</A></P>
<DT><B>Example</B><DD>
<P>
<PRE>
atmos_save("hires", 0xa000, 0xc000);
</PRE>
</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="atoi"></A> <A NAME="ss3.27">3.27</A> <A HREF="#toc3.27">atoi</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Convert a string to an integer.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#stdlib.h">stdlib.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>int __fastcall__ atoi (const char* s);</CODE></P>
<DT><B>Description</B><DD>
<P><CODE>atoi</CODE> converts the given string into an integer.
Conversion stops as soon as any invalid character is encountered.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>There is no way to detect any conversion errors.</LI>
<LI>The function does not check for an numerical overflow when converting.</LI>
<LI>The function is only available as fastcall function, so it may only be
used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>ISO 9899</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#atol">atol</A>,
<A HREF="#itoa">itoa</A>,
<A HREF="#ltoa">ltoa</A>,
<A HREF="#ultoa">ultoa</A>,
<A HREF="#utoa">utoa</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="atol"></A> <A NAME="ss3.28">3.28</A> <A HREF="#toc3.28">atol</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Convert a string to a long integer.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#stdlib.h">stdlib.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>long __fastcall__ atol (const char* s);</CODE></P>
<DT><B>Description</B><DD>
<P><CODE>atol</CODE> converts the given string into a long integer.
Conversion stops as soon as any invalid character is encountered.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>There is no way to detect any conversion errors.</LI>
<LI>The function does not check for an numerical overflow when converting.</LI>
<LI>The function is only available as fastcall function, so it may only be
used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>ISO 9899</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#atoi">atoi</A>,
<A HREF="#itoa">itoa</A>,
<A HREF="#ltoa">ltoa</A>,
<A HREF="#ultoa">ultoa</A>,
<A HREF="#utoa">utoa</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="bgcolor"></A> <A NAME="ss3.29">3.29</A> <A HREF="#toc3.29">bgcolor</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Set the background text color.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#conio.h">conio.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>unsigned char __fastcall__ bgcolor (unsigned char color);</CODE></P>
<DT><B>Description</B><DD>
<P>The function will set a new background color and return the
old (current) one. The background color is valid for the whole text output
area of the screen, not just for new text.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>Background colors are system dependent. The function may have no effect
on systems where the background color cannot be changed.</LI>
<LI>The function is only available as fastcall function, so it may only be
used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#bordercolor">bordercolor</A>,
<A HREF="#textcolor">textcolor</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="bordercolor"></A> <A NAME="ss3.30">3.30</A> <A HREF="#toc3.30">bordercolor</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Set the border (frame) color.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#conio.h">conio.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>unsigned char __fastcall__ bordercolor (unsigned char color);</CODE></P>
<DT><B>Description</B><DD>
<P>The function will set a new border color. It returns the old
(current) border color.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>Border colors are system dependent. The function may have no effect
on systems where the border color cannot be changed.</LI>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#bgcolor">bgcolor</A>,
<A HREF="#textcolor">textcolor</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="bsearch"></A> <A NAME="ss3.31">3.31</A> <A HREF="#toc3.31">bsearch</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Do a binary search in a sorted array.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#stdlib.h">stdlib.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void* __fastcall__ bsearch (const void* key,
const void* base, size_t n, size_t size,
int (*cmp) (const void*, const void*));</CODE></P>
<DT><B>Description</B><DD>
<P><CODE>bsearch</CODE> searches a sorted array for a member that
matches the one pointed to by <CODE>key</CODE>. <CODE>base</CODE> is the address of the array,
<CODE>n</CODE> is the number of elements, <CODE>size</CODE> the size of an element and <CODE>cmp</CODE>
the function used to compare the members against the key. The function returns
a pointer to the member found, or <CODE>NULL</CODE> if there was no match.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The contents of the array must be sorted in ascending order according to
the compare function given.</LI>
<LI>If there are multiple members that match the key, the function will
return one of the members.</LI>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>ISO 9899</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#qsort">qsort</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="bzero"></A> <A NAME="ss3.32">3.32</A> <A HREF="#toc3.32">bzero</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Fill a memory area with zeroes.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#string.h">string.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ bzero (void* p, size_t count);</CODE></P>
<DT><B>Description</B><DD>
<P><CODE>bzero</CODE> fills the memory area pointed to by <CODE>p</CODE> with
zero.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is non standard and therefore only available in non ANSI
mode. You should use <CODE>
<A HREF="#memset">memset</A></CODE> instead.</LI>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#_swap">_swap</A>,
<A HREF="#memcpy">memcpy</A>,
<A HREF="#memmove">memmove</A>,
<A HREF="#memset">memset</A>,</P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="c64mode"></A> <A NAME="ss3.33">3.33</A> <A HREF="#toc3.33">c64mode</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Switch the C128 into C64 compatible mode.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#c128.h">c128.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void c64mode (void);</CODE></P>
<DT><B>Description</B><DD>
<P>The function will cause the machine to reboot into C64 mode.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is specific to the C128.</LI>
<LI>The function will not return to the caller.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>C128</P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="calloc"></A> <A NAME="ss3.34">3.34</A> <A HREF="#toc3.34">calloc</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Allocate and clear memory.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#stdlib.h">stdlib.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void* __fastcall__ calloc (size_t n, size_t size);</CODE></P>
<DT><B>Description</B><DD>
<P><CODE>calloc</CODE> allocates memory for an array of <CODE>n</CODE> elements
of size <CODE>size</CODE>, clears the whole block with binary zeroes and returns a
pointer to it. On error (not enough memory available), <CODE>calloc</CODE> returns
<CODE>NULL</CODE>.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>Clearing the memory may not have the expected effect on all platforms:
pointers in the block may not be <CODE>NULL</CODE> and floating point variables may
not be zero (0.0). In other words: The "clearing" effect of this function
should be used with care for portable programs.</LI>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>ISO 9899</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#_heapadd">_heapadd</A>,
<A HREF="#_heapblocksize">_heapblocksize</A>,
<A HREF="#_heapmaxavail">_heapmaxavail</A>,
<A HREF="#_heapmemavail">_heapmemavail</A>,
<A HREF="#free">free</A>,
<A HREF="#malloc">malloc</A>,
<A HREF="#realloc">realloc</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="cbm_k_acptr"></A> <A NAME="ss3.35">3.35</A> <A HREF="#toc3.35">cbm_k_acptr</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Input byte from serial bus</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#cbm.h">cbm.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>unsigned char cbm_k_acptr (void);</CODE></P>
<DT><B>Description</B><DD>
<P>The function returns a byte of data, which it
gets from the current TALKer on the serial bus.
In order to receive the data, the device must have previously been
sent a command to TALK and a secondary address if it needs one.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI></LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#cbm_k_talk">cbm_k_talk</A>,</P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="cbm_k_basin"></A> <A NAME="ss3.36">3.36</A> <A HREF="#toc3.36">cbm_k_basin</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Input a Character from the Current Device</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#cbm.h">cbm.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>unsigned char cbm_k_basin (void);</CODE></P>
<DT><B>Description</B><DD>
<P>The function returns a character from the current input device.
Device must first have been OPENed and then designated as the input channel by the CHKIN routine.
When this function is called, the next byte of data available from the device is returned.
Exception is the routine for the keyboard device (which is the default input device).</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI></LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#cbm_k_open">cbm_k_open</A>,
<A HREF="#cbm_k_chkin">cbm_k_chkin</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="cbm_k_bsout"></A> <A NAME="ss3.37">3.37</A> <A HREF="#toc3.37">cbm_k_bsout</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Output a byte</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#cbm.h">cbm.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ cbm_k_bsout (unsigned char C);</CODE></P>
<DT><B>Description</B><DD>
<P>Function sends the character to the current output device.
Unless a device has been OPENed and designated as the
current output channel using the CHKOUT routine, the character is
printed to the screen, which is the default output device.  If the
cassette is the current device, outputting a byte will only add it to
the buffer. No actual transmission of data will occur until the
192-byte buffer is full.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may
only be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#cbm_k_open">cbm_k_open</A>,
<A HREF="#cbm_k_chkin">cbm_k_chkout</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="cbm_k_chkin"></A> <A NAME="ss3.38">3.38</A> <A HREF="#toc3.38">cbm_k_chkin</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Designate a Logical File As the Current Input Channel</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#cbm.h">cbm.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>unsigned char __fastcall__ cbm_k_chkin (unsigned char FN);</CODE></P>
<DT><B>Description</B><DD>
<P>If you wish to
get data from any device other than the keyboard, this function must be
called after OPENing the device, before you can get a data byte with
the cbm_k_basin or cbm_k_getin routine.  When called, the routine will designate
the logical file whose file number was supplied as the
current file, its device as the current device, and its secondary
address as the current secondary address.  If the device on the
channel is a serial device, which requires a TALK command and
sometimes a secondary address, function will send them over the
serial bus.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may
only be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#cbm_k_open">cbm_k_open</A>,
<A HREF="#cbm_k_basin">cbm_k_basin</A>,
<A HREF="#cbm_k_getin">cbm_k_getin</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="cbm_k_ciout"></A> <A NAME="ss3.39">3.39</A> <A HREF="#toc3.39">cbm_k_ciout</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Transmit a byte over the serial bus</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#cbm.h">cbm.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ cbm_k_ciout (unsigned char C);</CODE></P>
<DT><B>Description</B><DD>
<P>Purpose of this function is to send a byte of data over
the serial bus.  In order for the data to be received, the serial
device must have first been commanded to LISTEN and been given a
secondary address if necessary.  This routine always buffers the
current character, and defers sending it until the next byte is
buffered.  When the UNLISTEN command is sent, the last byte will be
sent with an End or Identify (EOI).</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may
only be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#cbm_k_listen">cbm_k_listen</A>,
<A HREF="#cbm_k_unlsn">cbm_k_unlsn</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="cbm_k_ckout"></A> <A NAME="ss3.40">3.40</A> <A HREF="#toc3.40">cbm_k_ckout</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Designate a Logical File As the Current Output Channel</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#cbm.h">cbm.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>unsigned char __fastcall__ cbm_k_ckout (unsigned char FN);</CODE></P>
<DT><B>Description</B><DD>
<P>If you wish to
output data to any device other than the screen, this routine must be
called after OPENing the device, and before you output a data byte
with the cbm_k_bsout() function.  When called, the function will designate the
logical file whose file number was supplied as the current
file, its device as the current device, and its secondary address as
the current secondary address.  If the device on the channel uses the
serial bus, and therefore requires a LISTEN command and possibly a
secondary address, this information will be sent on the bus.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may
only be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#cbm_k_bsout">cbm_k_bsout</A>,
<A HREF="#cbm_k_listen">cbm_k_listen</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="cbm_k_clall"></A> <A NAME="ss3.41">3.41</A> <A HREF="#toc3.41">cbm_k_clall</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Close All Logical I/O Files</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#cbm.h">cbm.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void cbm_k_clall (void);</CODE></P>
<DT><B>Description</B><DD>
<P>It closes all
open files, by resetting the index into open files to
zero and restores the default I/O devices.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI></LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#cbm_k_open">cbm_k_open</A>,
<A HREF="#cbm_k_close">cbm_k_close</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="cbm_k_close"></A> <A NAME="ss3.42">3.42</A> <A HREF="#toc3.42">cbm_k_close</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Close a Logical I/O File</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#cbm.h">cbm.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ cbm_k_close (unsigned char FN);</CODE></P>
<DT><B>Description</B><DD>
<P>It is used to
close a logical file after all I/O operations involving that file have
been completed.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may
only be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#cbm_k_open">cbm_k_open</A>,
<A HREF="#cbm_k_clall">cbm_k_clall</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="cbm_k_clrch"></A> <A NAME="ss3.43">3.43</A> <A HREF="#toc3.43">cbm_k_clrch</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Restore Current Input and Output Devices to the Default Devices</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#cbm.h">cbm.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void cbm_k_clrch (void);</CODE></P>
<DT><B>Description</B><DD>
<P>It sets the
current input device to the keyboard, and the current output device to
the screen.  Also, if the current input device was formerly a serial
device, the routine sends it an UNTALK command on the serial bus, and
if a serial device was formerly the current output device, the routine
sends it an UNLISTEN command.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI></LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#cbm_k_chkin">cbm_k_chkin</A>,
<A HREF="#cbm_k_ckout">cbm_k_ckout</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="cbm_k_getin"></A> <A NAME="ss3.44">3.44</A> <A HREF="#toc3.44">cbm_k_getin</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Get One Byte from the Input Device</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#cbm.h">cbm.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>unsigned char cbm_k_getin (void);</CODE></P>
<DT><B>Description</B><DD>
<P>Function gets a character from the current input device.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI></LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#cbm_k_basin">cbm_k_basin</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="cbm_k_iobase"></A> <A NAME="ss3.45">3.45</A> <A HREF="#toc3.45">cbm_k_iobase</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Return Base Address of Memory-Mapped I/O Devices</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#cbm.h">cbm.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>unsigned cbm_k_iobase (void);</CODE></P>
<DT><B>Description</B><DD>
<P>This function returns the address of
the memory section where the memory mapped I/O devices are located. This
address can then be used with an offset to access the memory mapped I/O
devices in the Commodore 64. The offset is the number of locations from
the beginning of the page on which the I/O register you want is located.
This function exists to provide compatibility between the Commodore 64,
VIC-20, and future models of the Commodore 64. If the I/O locations for
a program are set by a call to this function, they should
still remain compatible with future versions of the Commodore 64, the
KERNAL and BASIC.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI></LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>

<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="cbm_k_listen"></A> <A NAME="ss3.46">3.46</A> <A HREF="#toc3.46">cbm_k_listen</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Command a device on the serial bus to LISTEN</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#cbm.h">cbm.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ cbm_k_listen (unsigned char dev);</CODE></P>
<DT><B>Description</B><DD>
<P>This function will command a device on the serial bus to
receive data. The KERNAL routine will OR the supplied device number bit by bit
to convert it to a listen address, then transmits this data as a command on
the serial bus. The specified device will then go into listen mode, and
be ready to accept information.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may
only be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#cbm_k_unlsn">cbm_k_unlsn</A>,</P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="cbm_k_load"></A> <A NAME="ss3.47">3.47</A> <A HREF="#toc3.47">cbm_k_load</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Load RAM from a Device</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#cbm.h">cbm.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>unsigned int __fastcall__ cbm_k_load(unsigned char flag, unsigned addr);</CODE></P>
<DT><B>Description</B><DD>
<P>This function LOADs data bytes from any input device directly into the memory.
It can also be used for a verify operation, comparing data from a device with the data already in
memory, while leaving the data stored in RAM unchanged.
The flag must be set to 0 for a LOAD operation, or 1 for a
verify, If the input device is OPENed with a secondary address (SA) of 0
the header information from the device is ignored. In this case, the starting address for the load must be supplied.
If the device is addressed with a secondary address of 1, then the data is
loaded into memory starting at the location specified by the header.
Function returns the address of the highest RAM location loaded.
Before this function can be called, the KERNAL SETLFS, and SETNAM
routines must be called.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may
only be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#cbm_k_save">cbm_k_save</A>,
<A HREF="#cbm_k_setlfs">cbm_k_setlfs</A>,
<A HREF="#cbm_k_setnam">cbm_k_setnam</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="cbm_k_open"></A> <A NAME="ss3.48">3.48</A> <A HREF="#toc3.48">cbm_k_open</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Open a Logical I/O File</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#cbm.h">cbm.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>unsigned char cbm_k_open (void);</CODE></P>
<DT><B>Description</B><DD>
<P>This function assigns a logical file to a device, so that it can be used for
Input/Output operations. In order to specify the logical file number,
the device number, and the secondary address if any, the cbm_k_setlfs() function must first be called.
Likewise, in order to designate the filename, the cbm_k_setnam() function must be used first.  After these two
functions are called, cbm_k_open() is then called.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI></LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#cbm_k_close">cbm_k_close</A>,
<A HREF="#cbm_k_setlfs">cbm_k_setlfs</A>,
<A HREF="#cbm_k_setnam">cbm_k_setnam</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="cbm_k_readst"></A> <A NAME="ss3.49">3.49</A> <A HREF="#toc3.49">cbm_k_readst</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Read status word</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#cbm.h">cbm.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>unsigned char cbm_k_readst (void);</CODE></P>
<DT><B>Description</B><DD>
<P>This function returns the current status of the I/O devices. It is usually called after new communication to an I/O device and gives information about device status, or errors that have occurred during the I/O operation.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI></LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>

<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="cbm_k_save"></A> <A NAME="ss3.50">3.50</A> <A HREF="#toc3.50">cbm_k_save</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Save RAM to a Device</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#cbm.h">cbm.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>unsigned char __fastcall__ cbm_k_save(unsigned int start, unsigned int end)</CODE></P>
<DT><B>Description</B><DD>
<P>This function saves a section of memory. The cbm_k_setlfs() and cbm_k_setnam() functions must be
used before calling this function. However, a file name is not required to
SAVE to device 1 (the Datassette(TM) recorder). Any attempt to save to
other devices without using a file name results in an error. NOTE: Device 0 (the keyboard), device 2 (RS-232), and device 3 (the screen) cannot be SAVEd to. If the attempt is made, an error occurs, and the SAVE is stopped.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may
only be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#cbm_k_load">cbm_k_load</A>,
<A HREF="#cbm_k_setlfs">cbm_k_setlfs</A>,
<A HREF="#cbm_k_setnam">cbm_k_setnam</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="cbm_k_setlfs"></A> <A NAME="ss3.51">3.51</A> <A HREF="#toc3.51">cbm_k_setlfs</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Set up a logical file</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#cbm.h">cbm.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ cbm_k_setlfs (unsigned char LFN, unsigned char DEV, unsigned char SA);</CODE></P>
<DT><B>Description</B><DD>
<P>This functions sets up the logical file by setting its number, device address,
and secondary address.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may
only be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#cbm_k_setnam">cbm_k_setnam</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="cbm_k_setnam"></A> <A NAME="ss3.52">3.52</A> <A HREF="#toc3.52">cbm_k_setnam</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Set Filename Parameters</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#cbm.h">cbm.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ cbm_k_setnam (const char* Name);</CODE></P>
<DT><B>Description</B><DD>
<P>This function is used to set up the file name for the OPEN,
SAVE, or LOAD operations.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may
only be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#cbm_k_open">cbm_k_open</A>,
<A HREF="#cbm_k_load">cbm_k_load</A>,
<A HREF="#cbm_k_save">cbm_k_save</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="cbm_k_talk"></A> <A NAME="ss3.53">3.53</A> <A HREF="#toc3.53">cbm_k_talk</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Commands device to TALK</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#cbm.h">cbm.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ cbm_k_talk (unsigned char dev);</CODE></P>
<DT><B>Description</B><DD>
<P>When called, it ORs the device number with the TALK code (64, $40) and sends it on the serial
bus. This commands the device to TALK.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may
only be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#cbm_k_acptr">cbm_k_acptr</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="cbm_k_unlsn"></A> <A NAME="ss3.54">3.54</A> <A HREF="#toc3.54">cbm_k_unlsn</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Send an UNLISTEN command</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#cbm.h">cbm.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void cbm_k_unlsn (void);</CODE></P>
<DT><B>Description</B><DD>
<P>This function commands all devices on the serial bus to
stop receiving data from the host computer (i.e., UNLISTEN). Calling this
function results in an UNLISTEN command being transmitted on the serial
bus. Only devices previously commanded to LISTEN are affected. This
function is normally used after the host computer is finished sending data
to external devices. Sending the UNLISTEN commands the listening devices
to get off the serial bus so it can be used for other purposes.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI></LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#cbm_k_listen">cbm_k_listen</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="cclear"></A> <A NAME="ss3.55">3.55</A> <A HREF="#toc3.55">cclear</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Clear part of a line (write a given number of spaces).</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#conio.h">conio.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ cclear (unsigned char length);</CODE></P>
<DT><B>Description</B><DD>
<P>The function clears part of a line by writing <CODE>length</CODE>
spaces in the current text color.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may
only be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#cclearxy">cclearxy</A>,
<A HREF="#clrscr">clrscr</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="cclearxy"></A> <A NAME="ss3.56">3.56</A> <A HREF="#toc3.56">cclearxy</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Clear part of a line (write a given number of spaces) starting
at a specific screen position.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#conio.h">conio.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ cclearxy (unsigned char x, unsigned char y, unsigned char length);</CODE></P>
<DT><B>Description</B><DD>
<P>The function moves the cursor to a specific position, and
will then clear part of the line by writing <CODE>length</CODE> spaces in the current
text color.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may
only be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#cclear">cclear</A>,
<A HREF="#clrscr">clrscr</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="cgetc"></A> <A NAME="ss3.57">3.57</A> <A HREF="#toc3.57">cgetc</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Read a character from the keyboard.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#conio.h">conio.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>char cgetc (void);</CODE></P>
<DT><B>Description</B><DD>
<P>The function reads a character from the keyboard. If there is
no character available, <CODE>cgetc</CODE> waits until the user presses a key. If the
cursor is enabled by use of the <CODE>cursor</CODE> function, a blinking cursor is
displayed while waiting.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>If the system supports a keyboard buffer, <CODE>cgetc</CODE> will fetch a key
from this buffer and wait only if the buffer is empty.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#cursor">cursor</A>,
<A HREF="#kbhit">kbhit</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="chline"></A> <A NAME="ss3.58">3.58</A> <A HREF="#toc3.58">chline</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Output a horizontal line in text mode.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#conio.h">conio.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ chline (unsigned char length);</CODE></P>
<DT><B>Description</B><DD>
<P>The function outputs a horizontal line with the given length
starting at the current cursor position.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The character used to draw the horizontal line is system dependent.
If available, a line drawing character is used. Drawing a line that is partially
off screen leads to undefined behaviour.</LI>
<LI>The function is only available as fastcall function, so it may only be
used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#chlinexy">chlinexy</A>,
<A HREF="#cvline">cvline</A>,
<A HREF="#cvlinexy">cvlinexy</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="chlinexy"></A> <A NAME="ss3.59">3.59</A> <A HREF="#toc3.59">chlinexy</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Output a horizontal line at a given position in text mode.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#conio.h">conio.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ chlinexy (unsigned char x, unsigned char y, unsigned char length);</CODE></P>
<DT><B>Description</B><DD>
<P>The function outputs a horizontal line with the given length
starting at a given position.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The character used to draw the horizontal line is system dependent.
If available, a line drawing character is used. Drawing a line that is partially
off screen leads to undefined behaviour.</LI>
<LI>The function is only available as fastcall function, so it may only be
used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#chline">chline</A>,
<A HREF="#cvline">cvline</A>,
<A HREF="#cvlinexy">cvlinexy</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="clearerr"></A> <A NAME="ss3.60">3.60</A> <A HREF="#toc3.60">clearerr</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Clear error and end-of-file status of a stream.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#stdio.h">stdio.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ clearerr (FILE* f);</CODE></P>
<DT><B>Description</B><DD>
<P><CODE>clearerr</CODE> clears the error and end-of-file status
indicators for the stream <CODE>f</CODE>.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only be
used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>ISO 9899</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#feof">feof</A>,
<A HREF="#ferror">ferror</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="clock"></A> <A NAME="ss3.61">3.61</A> <A HREF="#toc3.61">clock</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Determine the processor time used.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#time.h">time.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>clock_t clock (void);</CODE></P>
<DT><B>Description</B><DD>
<P>The <CODE>clock</CODE> function returns an approximaton of processor
time used by the program. The time is returned in implementation defined
units. It can be converted to seconds by dividing by the value of the macro
<CODE>CLOCKS_PER_SEC</CODE>.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>Since the machines, cc65 generated programs run on, cannot run multiple
processes, the function will actually return the time since some
implementation defined point in the past.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>ISO 9899</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#time">time</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="clrscr"></A> <A NAME="ss3.62">3.62</A> <A HREF="#toc3.62">clrscr</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Clear the text screen.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#conio.h">conio.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void clrscr (void);</CODE></P>
<DT><B>Description</B><DD>
<P>The function clears the text screen and moves the cursor to
the upper left corner.</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#cclear">cclear</A>,
<A HREF="#cclearxy">cclearxy</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="close"></A> <A NAME="ss3.63">3.63</A> <A HREF="#toc3.63">close</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Close a file descriptor.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#fcntl.h">fcntl.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>int __fastcall__ close (int fd);</CODE></P>
<DT><B>Description</B><DD>
<P>The function closes the given file descriptor. It returns zero
on success and -1 on error. If an error occurs, the cause can be determined by
reading the <CODE>errno</CODE> variable.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>POSIX 1003.1</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#creat">creat</A>,
<A HREF="#open">open</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="closedir"></A> <A NAME="ss3.64">3.64</A> <A HREF="#toc3.64">closedir</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Close a directory.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#dirent.h">dirent.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>int __fastcall__ closedir (DIR* dir);</CODE></P>
<DT><B>Description</B><DD>
<P>The function closes the given directory descriptor. It returns
zero on success and -1 on error. If an error occurs, the cause can be determined
by reading the <CODE>errno</CODE> variable.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>POSIX 1003.1</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#opendir">opendir</A>,
<A HREF="#readdir">readdir</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="creat"></A> <A NAME="ss3.65">3.65</A> <A HREF="#toc3.65">creat</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Create a file.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#fcntl.h">fcntl.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>int __fastcall__ creat (const char* name, unsigned mode);</CODE></P>
<DT><B>Description</B><DD>
<P><CODE>creat</CODE> creates a new file and returns the file descriptor
associated with it. On error, -1 is returned and an error code is stored in
<CODE>errno</CODE>.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI><CODE>creat</CODE> is identical to calling <CODE>
<A HREF="#open">open</A></CODE> with
<CODE>flags</CODE> equal to <CODE>O_WRONLY | O_CREAT | O_TRUNC</CODE>.</LI>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>POSIX 1003.1</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#close">close</A>,
<A HREF="#open">open</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="cprintf"></A> <A NAME="ss3.66">3.66</A> <A HREF="#toc3.66">cprintf</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Formatted output to the console.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#conio.h">conio.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>int cprintf (const char* format, ...);</CODE></P>
<DT><B>Description</B><DD>
<P>The arguments are converted to text where necessary and
formatted according to the format string given. The resulting string is output
to the console. <CODE>cprintf</CODE> supports the same format specifiers as
<CODE>printf</CODE>. </P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>Like all other <CODE>conio</CODE> output functions, <CODE>cprintf</CODE> distinguishes
between <CODE>\r</CODE> and <CODE>\n</CODE>.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#cputc">cputc</A>,
<A HREF="#cputcxy">cputcxy</A>,
<A HREF="#cputs">cputs</A>,
<A HREF="#cputsxy">cputsxy</A>,
<A HREF="#vcprintf">vcprintf</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="cputc"></A> <A NAME="ss3.67">3.67</A> <A HREF="#toc3.67">cputc</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Output a character directly to the console.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#conio.h">conio.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ cputc (char c);</CODE></P>
<DT><B>Description</B><DD>
<P>Output one character to the console at the current cursor
position.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>Like all other <CODE>conio</CODE> output functions, <CODE>cputc</CODE> distinguishes
between <CODE>\r</CODE> and <CODE>\n</CODE>.</LI>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#cprintf">cprintf</A>,
<A HREF="#cputcxy">cputcxy</A>,
<A HREF="#cputs">cputs</A>,
<A HREF="#cputsxy">cputsxy</A>,
<A HREF="#vcprintf">vcprintf</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="cputcxy"></A> <A NAME="ss3.68">3.68</A> <A HREF="#toc3.68">cputcxy</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Output a character at a specific screen position.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#conio.h">conio.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ cputcxy (unsigned char x, unsigned char y, char c);</CODE></P>
<DT><B>Description</B><DD>
<P><CODE>cputcxy</CODE> moves the cursor to the given x/y position on
the screen and outputs one character.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>Like all other <CODE>conio</CODE> output functions, <CODE>cputcxy</CODE> distinguishes
between <CODE>\r</CODE> and <CODE>\n</CODE>.</LI>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#cprintf">cprintf</A>,
<A HREF="#cputc">cputc</A>,
<A HREF="#cputs">cputs</A>,
<A HREF="#cputsxy">cputsxy</A>,
<A HREF="#vcprintf">vcprintf</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="cputs"></A> <A NAME="ss3.69">3.69</A> <A HREF="#toc3.69">cputs</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Output a string directly to the console.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#conio.h">conio.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ cputs (const char* s);</CODE></P>
<DT><B>Description</B><DD>
<P>The function outputs the given string on the console at the
current cursor position.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>Like all other <CODE>conio</CODE> output functions, <CODE>cputs</CODE> distinguishes
between <CODE>\r</CODE> and <CODE>\n</CODE>.</LI>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#cprintf">cprintf</A>,
<A HREF="#cputc">cputc</A>,
<A HREF="#cputcxy">cputcxy</A>,
<A HREF="#cputsxy">cputsxy</A>,
<A HREF="#vcprintf">vcprintf</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="cputsxy"></A> <A NAME="ss3.70">3.70</A> <A HREF="#toc3.70">cputsxy</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Output a string to the console at a given position.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#conio.h">conio.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ cputsxy (unsigned char x, unsigned char y, const char* s);</CODE></P>
<DT><B>Description</B><DD>
<P><CODE>cputsxy</CODE> moves the cursor to the given x/y position,
and outputs the string <CODE>s</CODE>.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>Like all other <CODE>conio</CODE> output functions, <CODE>cputsxy</CODE> distinguishes
between <CODE>\r</CODE> and <CODE>\n</CODE>.</LI>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#cprintf">cprintf</A>,
<A HREF="#cputc">cputc</A>,
<A HREF="#cputcxy">cputcxy</A>,
<A HREF="#cputs">cputs</A>,
<A HREF="#vcprintf">vcprintf</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="cursor"></A> <A NAME="ss3.71">3.71</A> <A HREF="#toc3.71">cursor</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Enable/disable a blinking cursor when waiting for keyboard input.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#conio.h">conio.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>unsigned char __fastcall__ cursor (unsigned char onoff);</CODE></P>
<DT><B>Description</B><DD>
<P>If the argument to the function is non zero, a blinking cursor
will be enabled when the <CODE>cgetc</CODE> function waits for input from the keyboard.
If the argument is zero, <CODE>cgetc</CODE> will wait without a blinking cursor.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#cgetc">cgetc</A>,
<A HREF="#kbhit">kbhit</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="cvline"></A> <A NAME="ss3.72">3.72</A> <A HREF="#toc3.72">cvline</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Output a vertical line in text mode.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#conio.h">conio.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ cvline (unsigned char length);</CODE></P>
<DT><B>Description</B><DD>
<P>The function outputs a vertical line with the given length
starting at the current cursor position.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The character used to draw the vertical line is system dependent.
If available, a line drawing character is used. Drawing a line that is partially
off screen leads to undefined behaviour.</LI>
<LI>The function is only available as fastcall function, so it may only be
used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#chline">chline</A>,
<A HREF="#chlinexy">chlinexy</A>,
<A HREF="#cvlinexy">cvlinexy</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="cvlinexy"></A> <A NAME="ss3.73">3.73</A> <A HREF="#toc3.73">cvlinexy</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Output a vertical line at a given position in text mode.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#conio.h">conio.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ cvlinexy (unsigned char x, unsigned char y, unsigned char length);</CODE></P>
<DT><B>Description</B><DD>
<P>The function outputs a vertical line with the given length
starting at a given position.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The character used to draw the vertical line is system dependent.
If available, a line drawing character is used. Drawing a line that is partially
off screen leads to undefined behaviour.</LI>
<LI>The function is only available as fastcall function, so it may only be
used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#chline">chline</A>,
<A HREF="#chlinexy">chlinexy</A>,
<A HREF="#cvline">cvline</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="div"></A> <A NAME="ss3.74">3.74</A> <A HREF="#toc3.74">div</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Divide two ints and return quotient and remainder.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#stdlib.h">stdlib.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>div_t __fastcall__ div (int numer, int denom);</CODE></P>
<DT><B>Description</B><DD>
<P><CODE>div</CODE> divides <CODE>numer</CODE> by <CODE>denom</CODE> and returns the
quotient and remainder in a <CODE>div_t</CODE> structure.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>ISO 9899</P>
<DT><B>See also</B><DD>
<P>ldiv</P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="em_commit"></A> <A NAME="ss3.75">3.75</A> <A HREF="#toc3.75">em_commit</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Commit changes into extended memory.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#em.h">em.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void em_commit (void);</CODE></P>
<DT><B>Description</B><DD>
<P>Commit changes in the memory window to extended storage. If
the contents of the memory window have been changed, these changes may be lost
if <CODE>
<A HREF="#em_map">em_map</A></CODE>, <CODE>
<A HREF="#em_use">em_use</A></CODE>,
<CODE>
<A HREF="#em_copyfrom">em_copyfrom</A></CODE> or <CODE>
<A HREF="#em_copyto">em_copyto</A></CODE> are called without calling <CODE>em_commit</CODE> first.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>Calling <CODE>em_commit</CODE> does not necessarily mean that changes to the
memory window are discarded, it does just mean that the drivers is allowed
to discard it.</LI>
<LI>The function is only available as fastcall function, so it may only be
used in presence of a prototype.</LI>
<LI>The function produces undefined results if no extended memory driver is
loaded.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#em_load_driver">em_load_driver</A>,
<A HREF="#em_map">em_map</A>,
<A HREF="#em_use">em_use</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="em_copyfrom"></A> <A NAME="ss3.76">3.76</A> <A HREF="#toc3.76">em_copyfrom</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Copy from extended into normal memory.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#em.h">em.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ em_copyfrom (const struct em_copy* copy_data);</CODE></P>
<DT><B>Description</B><DD>
<P>Copy data from extended memory into linear memory. Source and
target addresses as well as the number of bytes to transfer are specified in
the <CODE>em_copy</CODE> structure that is passed as a parameter.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>Calling <CODE>em_copyfrom</CODE> will invalidate the memory window, so if you
made any changes to the data in the window, call <CODE>
<A HREF="#em_commit">em_commit</A></CODE> first, or the changes are lost.</LI>
<LI>The function is only available as fastcall function, so it may only be
used in presence of a prototype.</LI>
<LI>The function produces undefined results if no extended memory driver is
loaded.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#em_commit">em_commit</A>,
<A HREF="#em_copyto">em_copyto</A>,
<A HREF="#em_load_driver">em_load_driver</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="em_copyto"></A> <A NAME="ss3.77">3.77</A> <A HREF="#toc3.77">em_copyto</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Copy from normal into extended memory.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#em.h">em.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ em_copyto (const struct em_copy* copy_data);</CODE></P>
<DT><B>Description</B><DD>
<P>Copy data from linear into extended memory. Source and
target addresses as well as the number of bytes to transfer are specified in
the <CODE>em_copy</CODE> structure that is passed as a parameter.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>Calling <CODE>em_copyto</CODE> will invalidate the memory window, so if you
made any changes to the data in the window, call <CODE>
<A HREF="#em_commit">em_commit</A></CODE> first, or the changes are lost.</LI>
<LI>The function is only available as fastcall function, so it may only be
used in presence of a prototype.</LI>
<LI>The function produces undefined results if no extended memory driver is
loaded.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#em_commit">em_commit</A>,
<A HREF="#em_copyfrom">em_copyfrom</A>,
<A HREF="#em_load_driver">em_load_driver</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="em_install"></A> <A NAME="ss3.78">3.78</A> <A HREF="#toc3.78">em_install</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Install an already loaded extended memory driver.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#em.h">em.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>unsigned char _fastcall__ em_install (void* driver);</CODE></P>
<DT><B>Description</B><DD>
<P>The function installs an already loaded extended memory driver
and returns an error code. The function may be used to install a driver linked
statically to the program.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>Not all drivers are able to detect if the supported hardware is really
present.</LI>
<LI>The function is only available as fastcall function, so it may only be
used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#em_load_driver">em_load_driver</A>,
<A HREF="#em_uninstall">em_uninstall</A>,
<A HREF="#em_unload">em_unload</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="em_load_driver"></A> <A NAME="ss3.79">3.79</A> <A HREF="#toc3.79">em_load_driver</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Load and initialize an extended memory driver.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#em.h">em.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ em_load_driver (const char* name);</CODE></P>
<DT><B>Description</B><DD>
<P>Load an extended memory driver into memory and initialize
it. The function returns an error code that tells if all this has been
successful.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>Not all drivers are able to detect if the supported hardware is really
present.</LI>
<LI>The function is only available as fastcall function, so it may only be
used in presence of a prototype.</LI>
<LI>The driver is loaded by name, so currently you must know the type of
extended memory that should be supported. There is no autodetect capability.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#em_unload">em_unload</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="em_map"></A> <A NAME="ss3.80">3.80</A> <A HREF="#toc3.80">em_map</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Make a page of extended memory accessible.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#em.h">em.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void* __fastcall__ em_map (unsigned page);</CODE></P>
<DT><B>Description</B><DD>
<P>The function maps one page of extended memory into linear
memory and returns a pointer to the page frame. Depending on the hardware
and driver, the data is either mapped into the address space or transfered
into a buffer. If you don't need the actual contents of the page (for example
because you're going to overwrite it completely), it is better to call
<CODE>
<A HREF="#em_use">em_use</A></CODE> instead. <CODE>em_use</CODE> will not transfer the
data if it is possible to avoid that.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>Calling <CODE>em_map</CODE> will invalidate the memory window, so if you
made any changes to the data in the window, call <CODE>
<A HREF="#em_commit">em_commit</A></CODE> first, or the changes are lost.</LI>
<LI>The function is only available as fastcall function, so it may only be
used in presence of a prototype.</LI>
<LI>The function produces undefined results if no extended memory driver is
loaded.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#em_commit">em_commit</A>,
<A HREF="#em_load_driver">em_load_driver</A>,
<A HREF="#em_use">em_use</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="em_pagecount"></A> <A NAME="ss3.81">3.81</A> <A HREF="#toc3.81">em_pagecount</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Return the number of available extended memory pages.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#em.h">em.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>unsigned em_pagecount (void);</CODE></P>
<DT><B>Description</B><DD>
<P>The function returns the size of the extended memory supported
by the driver in 256 byte pages.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function returns zero if no extended memory driver is loaded.</LI>
<LI>The function may return zero if the supported hardware was not detected.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#em_load_driver">em_load_driver</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="em_uninstall"></A> <A NAME="ss3.82">3.82</A> <A HREF="#toc3.82">em_uninstall</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Uninstall an already loaded extended memory driver.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#em.h">em.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>unsigned char em_uninstall (void);</CODE></P>
<DT><B>Description</B><DD>
<P>The function uninstalls an already loaded extended memory
driver but doesn't remove it from memory.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>If the driver has been loaded using <CODE>
<A HREF="#em_load_driver">em_load_driver</A></CODE>, <CODE>
<A HREF="#em_unload">em_unload</A></CODE>
should be used instead of <CODE>em_uninstall</CODE> so the driver is also removed
from memory.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#em_install">em_install</A>,
<A HREF="#em_load_driver">em_load_driver</A>,
<A HREF="#em_unload">em_unload</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="em_unload"></A> <A NAME="ss3.83">3.83</A> <A HREF="#toc3.83">em_unload</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Unload an extended memory driver.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#em.h">em.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>unsigned char em_unload (void);</CODE></P>
<DT><B>Description</B><DD>
<P>The function unloads a loaded extended memory driver and
frees all memory allocated for the driver.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function does nothing if no driver is loaded.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#em_load_driver">em_load_driver</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="em_use"></A> <A NAME="ss3.84">3.84</A> <A HREF="#toc3.84">em_use</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Prepare an extended memory page for use.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#em.h">em.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void* __fastcall__ em_use (unsigned page);</CODE></P>
<DT><B>Description</B><DD>
<P>The function maps one page of extended memory into linear
memory and returns a pointer to the page frame. This function is similar to
<CODE>
<A HREF="#em_map">em_map</A></CODE>, but will not transfer data into the
actual memory window in the assumption that the existing data is wrong or
will get overwritten.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>Calling <CODE>em_use</CODE> will invalidate the memory window, so if you
made any changes to the data in the window, call <CODE>
<A HREF="#em_commit">em_commit</A></CODE> first, or the changes are lost.</LI>
<LI>The function is only available as fastcall function, so it may only be
used in presence of a prototype.</LI>
<LI>The function produces undefined results if no extended memory driver is
loaded.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#em_commit">em_commit</A>,
<A HREF="#em_load_driver">em_load_driver</A>,
<A HREF="#em_map">em_map</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="exit"></A> <A NAME="ss3.85">3.85</A> <A HREF="#toc3.85">exit</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Terminate the program.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#stdlib.h">stdlib.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ exit (int status);</CODE></P>
<DT><B>Description</B><DD>
<P><CODE>exit</CODE> terminates the program. The argument specifies the
return code of the program. Before termination, all files are closed, buffered
output is written and any functions registered with <CODE>
<A HREF="#atexit">atexit</A></CODE> are called. Common values for status are <CODE>EXIT_SUCCESS</CODE> and
<CODE>EXIT_FAILURE</CODE> which are also defined in <CODE>
<A HREF="#stdlib.h">stdlib.h</A></CODE>.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
<LI>It depends on the host machine if the program return code can be
evaluated or is ignored.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>ISO 9899</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#abort">abort</A>,
<A HREF="#exit">exit</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="exec"></A> <A NAME="ss3.86">3.86</A> <A HREF="#toc3.86">exec</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Execute a program file.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#unistd.h">unistd.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>int __fastcall__ exec (const char* progname, const char* cmdline);</CODE></P>
<DT><B>Description</B><DD>
<P><CODE>exec</CODE> replaces the currently running program by a new one.
Calling <CODE>exec()</CODE> is identical to calling <CODE>
<A HREF="#exit">exit()</A></CODE>,
then loading and starting the program named in the first argument, passing
the command line specified as second argument. Instead of an empty string,
a <CODE>NULL</CODE> pointer may be passed as second parameter.
On success, the function does not return. On failure, -1 is returned and
<CODE>errno</CODE> contains an error code.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
<LI>On most platforms, the function needs to copy a small stub loader to
some memory area outside the program space. This may collide with other
programs. See the platform specific docs on this.</LI>
<LI>Because it is necessary to terminate the running program before the
memory can be reused to load the new one, there is a high chance that the
function may not be able to return on errors.</LI>
<LI>The command line is passed to the new program in the same way as cc65
programs expect the command line. If the new program is not a cc65 generated
program, it may not be able to read it.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#exit">exit</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="fast"></A> <A NAME="ss3.87">3.87</A> <A HREF="#toc3.87">fast</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Switch the C128 into 2MHz mode.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#c128.h">c128.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void fast (void);</CODE></P>
<DT><B>Description</B><DD>
<P>The function will switch the clock of the C128 to 2MHz. This
will nearly double the speed compared to slow mode.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is specific to the C128.</LI>
<LI>2MHz clock will not work in 40 column mode.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>C128</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#slow">slow</A>,
<A HREF="#toggle_videomode">toggle_videomode</A>,
<A HREF="#videomode">videomode</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="feof"></A> <A NAME="ss3.88">3.88</A> <A HREF="#toc3.88">feof</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Return the end-of-file indicator of a stream.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#stdio.h">stdio.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>int __fastcall__ feof (FILE* f);</CODE></P>
<DT><B>Description</B><DD>
<P><CODE>feof</CODE> tests the end-of-file indicator ofthe stream
<CODE>f</CODE>, and returns a non zero value if it is set.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The indicator is set only after a read past the end of a file is
attempted.</LI>
<LI>The function is only available as fastcall function, so it may only be
used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>ISO 9899</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#feof">clearerr</A>,
<A HREF="#ferror">ferror</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="ferror"></A> <A NAME="ss3.89">3.89</A> <A HREF="#toc3.89">ferror</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Return the error indicator of a stream.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#stdio.h">stdio.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>int __fastcall__ ferror (FILE* f);</CODE></P>
<DT><B>Description</B><DD>
<P><CODE>ferror</CODE> tests the error indicator of the stream
<CODE>f</CODE>, and returns a non zero value if it is set.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only be
used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>ISO 9899</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#feof">clearerr</A>,
<A HREF="#ferror">feof</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="fileno"></A> <A NAME="ss3.90">3.90</A> <A HREF="#toc3.90">fileno</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Return the file handle used by a stream.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#stdio.h">stdio.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>int __fastcall__ fileno (FILE* f);</CODE></P>
<DT><B>Description</B><DD>
<P>The <CODE>fileno</CODE> function returns the file handle used
internally by a C stream. This file handle (an integer) can be used as a
handle for the POSIX input/output functions.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only be
used in presence of a prototype.</LI>
<LI>Mixing C file I/O functions and POSIX file I/O functions for the same
file may have unpredictable results.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>POSIX 1003.1</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#creat">creat</A>,
<A HREF="#open">open</A> </P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="free"></A> <A NAME="ss3.91">3.91</A> <A HREF="#toc3.91">free</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Free a block of dynamic memory.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#stdlib.h">stdlib.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ free (void* block);</CODE></P>
<DT><B>Description</B><DD>
<P>Free a block of dynamic memory previously allocated with
<CODE>
<A HREF="#malloc">malloc</A></CODE>, <CODE>
<A HREF="#calloc">calloc</A></CODE>
or <CODE>
<A HREF="#realloc">realloc</A></CODE>. As an exception, if the passed
pointer is <CODE>NULL</CODE>, no action is performed.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>Passing an already free'd block to <CODE>free</CODE> again will cause undefined
behaviour and may crash your program.</LI>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>ISO 9899</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#_heapadd">_heapadd</A>,
<A HREF="#_heapblocksize">_heapblocksize</A>,
<A HREF="#_heapmaxavail">_heapmaxavail</A>,
<A HREF="#_heapmemavail">_heapmemavail</A>,
<A HREF="#calloc">calloc</A>,
<A HREF="#malloc">malloc</A>,
<A HREF="#realloc">realloc</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="get_ostype"></A> <A NAME="ss3.92">3.92</A> <A HREF="#toc3.92">get_ostype</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>The function returns the operating system, the program runs on.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#apple2.h">apple2.h</A>,
<A HREF="#atari.h">atari.h</A>, 
<A HREF="#c64.h">c64.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>unsigned char get_ostype (void);</CODE></P>
<DT><B>Description</B><DD>
<P><CODE>get_ostype</CODE> is machine dependent and does not exist for
all supported targets. If it exists, it returns a number that identifies the
operating system or machine type, the program runs on. The machine dependent
header files define constants that can be used to check the return code.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function does not exist on all platforms.</LI>
<LI>The return codes are platform dependent.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65 (not all platforms)</P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="getcpu"></A> <A NAME="ss3.93">3.93</A> <A HREF="#toc3.93">getcpu</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Determine on which CPU the program is running.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#6502.h">6502.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>unsigned char getcpu (void);</CODE></P>
<DT><B>Description</B><DD>
<P>The function checks on which CPU the code is running. It
returns one of the constants
<UL>
<LI><CODE>CPU_6502</CODE></LI>
<LI><CODE>CPU_65C02</CODE></LI>
<LI><CODE>CPU_65816</CODE></LI>
</UL>
</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>Other, more exotic CPU types are not disinguished.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="getenv"></A> <A NAME="ss3.94">3.94</A> <A HREF="#toc3.94">getenv</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Return a value from the environment.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#stdlib.h">stdlib.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>char* __fastcall__ getenv (const char* name);</CODE></P>
<DT><B>Description</B><DD>
<P>The function searches the environment for an entry that
matches <CODE>name</CODE> and returns its value. The environment consists of a list
of strings in the form <CODE>name=value</CODE>. If there is no match, <CODE>getenv</CODE>
returns <CODE>NULL</CODE>.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>What exactly is stored in the environment depends on the machine the
program is running on.</LI>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>ISO 9899</P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="getopt"></A> <A NAME="ss3.95">3.95</A> <A HREF="#toc3.95">getopt</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Parse command line options.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#unistd.h">unistd.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>int __fastcall__ getopt (int argc, char* const* argv,
const char* optstring);</CODE></P>
<DT><B>Description</B><DD>
<P>The function parses command line arguments, <CODE>argc</CODE> and
<CODE>argv</CODE> are the argument count and array passed to <CODE>main</CODE>. <CODE>optstring</CODE>
is a string that contains command line option characters. If a character in
<CODE>optstring</CODE> is followed by a colon, the option requires an argument. An
option on the command line is recognized if it is one of the option characters
preceeded by a '-'.
<CODE>getopt</CODE> must be called repeatedly. It will return each option character
found on the command line and <CODE>EOF</CODE> (-1) if there is no other option. An
option argument is placed in <CODE>optarg</CODE>, the index of the next element on the
command line to be processed is placed in <CODE>optind</CODE>.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The implementation will not reorder options. A non option on the command
line will terminate option processing. All remaining arguments are not
recognized as options, even if the start with a '-' character.</LI>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>POSIX.2</P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="gotox"></A> <A NAME="ss3.96">3.96</A> <A HREF="#toc3.96">gotox</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Move the text mode cursor to a new X position.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#conio.h">conio.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ gotox (unsigned char x);</CODE></P>
<DT><B>Description</B><DD>
<P>The function moves the text mode cursor to the specified X
position while leaving the Y position untouched. The leftmost position on the
screen has the coordinate 0.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may
only be used in presence of a prototype.</LI>
<LI>Invalid values for the X position (out of screen coordinates) may
lead to undefined behaviour.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#gotoy">gotoy</A>,
<A HREF="#gotoxy">gotoxy</A>,
<A HREF="#wherex">wherex</A>,
<A HREF="#wherey">wherey</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="gotoxy"></A> <A NAME="ss3.97">3.97</A> <A HREF="#toc3.97">gotoxy</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Move the text mode cursor to a new position.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#conio.h">conio.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ gotoxy (unsigned char x, unsigned char y);</CODE></P>
<DT><B>Description</B><DD>
<P>The function moves the text mode cursor to the specified
position. The leftmost position on the screen has the X coordinate 0, the
topmost line has the Y coordinate 0.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only be
used in presence of a prototype.</LI>
<LI>Invalid values for any of both coordinates (out of screen positions) may
lead to undefined behaviour.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#gotox">gotox</A>,
<A HREF="#gotoy">gotoy</A>,
<A HREF="#wherex">wherex</A>,
<A HREF="#wherey">wherey</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="gotoy"></A> <A NAME="ss3.98">3.98</A> <A HREF="#toc3.98">gotoy</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Move the text mode cursor to a new Y position.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#conio.h">conio.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ gotoy (unsigned char x);</CODE></P>
<DT><B>Description</B><DD>
<P>The function moves the text mode cursor to the specified Y
position while leaving the X position untouched. The uppermost position on the
screen has the coordinate 0.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may
only be used in presence of a prototype.</LI>
<LI>Invalid values for the Y position (out of screen coordinates) may lead
to undefined behaviour.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#gotox">gotox</A>,
<A HREF="#gotoxy">gotoxy</A>,
<A HREF="#wherex">wherex</A>,
<A HREF="#wherey">wherey</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="isalnum"></A> <A NAME="ss3.99">3.99</A> <A HREF="#toc3.99">isalnum</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Check if a given character is a letter or digit.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#ctype.h">ctype.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>int __fastcall__ isalnum (int c);</CODE></P>
<DT><B>Description</B><DD>
<P>The function returns a non zero value if the given argument
is a letter or digit. The return value is zero if the character is anything
else.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>When compiling with <CODE>-Os</CODE> the function is actually a macro. The
inline sequence generated by the macro will not work correctly for values
outside the range 0..255. <EM>Note:</EM> The constant <CODE>EOF</CODE> is not part of
this range. The non inline function may be accessed by <CODE>#undef</CODE>'ing
the macro.</LI>
<LI>When compiling without <CODE>-Os</CODE>, the function is only available as
fastcall function, so it may only be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>ISO 9899</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#isalpha">isalpha</A>,
<A HREF="#isascii">isascii</A>,
<A HREF="#isblank">isblank</A>,
<A HREF="#iscntrl">iscntrl</A>,
<A HREF="#isdigit">isdigit</A>,
<A HREF="#isgraph">isgraph</A>,
<A HREF="#islower">islower</A>,
<A HREF="#isprint">isprint</A>,
<A HREF="#ispunct">ispunct</A>,
<A HREF="#isspace">isspace</A>,
<A HREF="#isupper">isupper</A>,
<A HREF="#isxdigit">isxdigit</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="isalpha"></A> <A NAME="ss3.100">3.100</A> <A HREF="#toc3.100">isalpha</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Check if a given character is a letter.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#ctype.h">ctype.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>int __fastcall__ isalpha (int c);</CODE></P>
<DT><B>Description</B><DD>
<P>The function returns a non zero value if the given argument
is a letter. The return value is zero if the character is anything else.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>When compiling with <CODE>-Os</CODE> the function is actually a macro. The
inline sequence generated by the macro will not work correctly for values
outside the range 0..255. <EM>Note:</EM> The constant <CODE>EOF</CODE> is not part of
this range. The non inline function may be accessed by <CODE>#undef</CODE>'ing the
macro.</LI>
<LI>When compiling without <CODE>-Os</CODE>, the function is only available as
fastcall function, so it may only be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>ISO 9899</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#isalnum">isalnum</A>,
<A HREF="#isascii">isascii</A>,
<A HREF="#isblank">isblank</A>,
<A HREF="#iscntrl">iscntrl</A>,
<A HREF="#isdigit">isdigit</A>,
<A HREF="#isgraph">isgraph</A>,
<A HREF="#islower">islower</A>,
<A HREF="#isprint">isprint</A>,
<A HREF="#ispunct">ispunct</A>,
<A HREF="#isspace">isspace</A>,
<A HREF="#isupper">isupper</A>,
<A HREF="#isxdigit">isxdigit</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="isascii"></A> <A NAME="ss3.101">3.101</A> <A HREF="#toc3.101">isascii</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Check if a given character is in the ASCII (0..127) range.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#ctype.h">ctype.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>int __fastcall__ isascii (int c);</CODE></P>
<DT><B>Description</B><DD>
<P>The function returns a non zero value if the given argument
is in the range 0..127 (the range of valid ASCII characters) and zero if not.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>When compiling with <CODE>-Os</CODE> the function is actually a macro. The
inline sequence generated by the macro will not work correctly for values
outside the range 0..255. <EM>Note:</EM> The constant <CODE>EOF</CODE> is not part of
this range. The non inline function may be accessed by <CODE>#undef</CODE>'ing the
macro.</LI>
<LI>When compiling without <CODE>-Os</CODE>, the function is only available as
fastcall function, so it may only be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>ISO 9899</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#isalnum">isalnum</A>,
<A HREF="#isalpha">isalpha</A>,
<A HREF="#isblank">isblank</A>,
<A HREF="#iscntrl">iscntrl</A>,
<A HREF="#isdigit">isdigit</A>,
<A HREF="#isgraph">isgraph</A>,
<A HREF="#islower">islower</A>,
<A HREF="#isprint">isprint</A>,
<A HREF="#ispunct">ispunct</A>,
<A HREF="#isspace">isspace</A>,
<A HREF="#isupper">isupper</A>,
<A HREF="#isxdigit">isxdigit</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="isblank"></A> <A NAME="ss3.102">3.102</A> <A HREF="#toc3.102">isblank</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Check if a given character is a space or tab.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#ctype.h">ctype.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>int __fastcall__ isblank (int c);</CODE></P>
<DT><B>Description</B><DD>
<P>The function returns a non zero value if the given argument
is a space or tab character. The return value is zero if the character is
anything else.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>When compiling with <CODE>-Os</CODE> the function is actually a macro. The
inline sequence generated by the macro will not work correctly for values
outside the range 0..255. <EM>Note:</EM> The constant <CODE>EOF</CODE> is not part of
this range. The non inline function may be accessed by <CODE>#undef</CODE>'ing the
macro.</LI>
<LI>When compiling without <CODE>-Os</CODE>, the function is only available as
fastcall function, so it may only be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#isalnum">isalnum</A>,
<A HREF="#isalpha">isalpha</A>,
<A HREF="#isascii">isascii</A>,
<A HREF="#iscntrl">iscntrl</A>,
<A HREF="#isdigit">isdigit</A>,
<A HREF="#isgraph">isgraph</A>,
<A HREF="#islower">islower</A>,
<A HREF="#isprint">isprint</A>,
<A HREF="#ispunct">ispunct</A>,
<A HREF="#isspace">isspace</A>,
<A HREF="#isupper">isupper</A>,
<A HREF="#isxdigit">isxdigit</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="iscntrl"></A> <A NAME="ss3.103">3.103</A> <A HREF="#toc3.103">iscntrl</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Check if a given character is a control character.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#ctype.h">ctype.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>int __fastcall__ iscntrl (int c);</CODE></P>
<DT><B>Description</B><DD>
<P>The function returns a non zero value if the given argument
is a control character. The return value is zero if the character is anything
else.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>When compiling with <CODE>-Os</CODE> the function is actually a macro. The
inline sequence generated by the macro will not work correctly for values
outside the range 0..255. <EM>Note:</EM> The constant <CODE>EOF</CODE> is not part of
this range. The non inline function may be accessed by <CODE>#undef</CODE>'ing the
macro.</LI>
<LI>When compiling without <CODE>-Os</CODE>, the function is only available as
fastcall function, so it may only be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>ISO 9899</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#isalnum">isalnum</A>,
<A HREF="#isalpha">isalpha</A>,
<A HREF="#isascii">isascii</A>,
<A HREF="#isblank">isblank</A>,
<A HREF="#isdigit">isdigit</A>,
<A HREF="#isgraph">isgraph</A>,
<A HREF="#islower">islower</A>,
<A HREF="#isprint">isprint</A>,
<A HREF="#ispunct">ispunct</A>,
<A HREF="#isspace">isspace</A>,
<A HREF="#isupper">isupper</A>,
<A HREF="#isxdigit">isxdigit</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="isdigit"></A> <A NAME="ss3.104">3.104</A> <A HREF="#toc3.104">isdigit</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Check if a given character is a digit.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#ctype.h">ctype.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>int __fastcall__ isdigit (int c);</CODE></P>
<DT><B>Description</B><DD>
<P>The function returns a non zero value if the given argument
is a digit. The return value is zero if the character is anything else.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>When compiling with <CODE>-Os</CODE> the function is actually a macro. The
inline sequence generated by the macro will not work correctly for values
outside the range 0..255. <EM>Note:</EM> The constant <CODE>EOF</CODE> is not part of
this range. The non inline function may be accessed by <CODE>#undef</CODE>'ing the
macro.</LI>
<LI>When compiling without <CODE>-Os</CODE>, the function is only available as
fastcall function, so it may only be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>ISO 9899</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#isalnum">isalnum</A>,
<A HREF="#isalpha">isalpha</A>,
<A HREF="#isascii">isascii</A>,
<A HREF="#isblank">isblank</A>,
<A HREF="#iscntrl">iscntrl</A>,
<A HREF="#isgraph">isgraph</A>,
<A HREF="#islower">islower</A>,
<A HREF="#isprint">isprint</A>,
<A HREF="#ispunct">ispunct</A>,
<A HREF="#isspace">isspace</A>,
<A HREF="#isupper">isupper</A>,
<A HREF="#isxdigit">isxdigit</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="isgraph"></A> <A NAME="ss3.105">3.105</A> <A HREF="#toc3.105">isgraph</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Check if a given character is a printable character (except
space).</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#ctype.h">ctype.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>int __fastcall__ isgraph (int c);</CODE></P>
<DT><B>Description</B><DD>
<P>The function returns a non zero value if the given argument
is a printable character with the exception of space. The return value is zero
if the character is anything else.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>When compiling with <CODE>-Os</CODE> the function is actually a macro. The
inline sequence generated by the macro will not work correctly for values
outside the range 0..255. <EM>Note:</EM> The constant <CODE>EOF</CODE> is not part of
this range. The non inline function may be accessed by <CODE>#undef</CODE>'ing the
macro.</LI>
<LI>When compiling without <CODE>-Os</CODE>, the function is only available as
fastcall function, so it may only be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>ISO 9899</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#isalnum">isalnum</A>,
<A HREF="#isalpha">isalpha</A>,
<A HREF="#isascii">isascii</A>,
<A HREF="#isblank">isblank</A>,
<A HREF="#iscntrl">iscntrl</A>,
<A HREF="#isdigit">isdigit</A>,
<A HREF="#islower">islower</A>,
<A HREF="#isprint">isprint</A>,
<A HREF="#ispunct">ispunct</A>,
<A HREF="#isspace">isspace</A>,
<A HREF="#isupper">isupper</A>,
<A HREF="#isxdigit">isxdigit</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="islower"></A> <A NAME="ss3.106">3.106</A> <A HREF="#toc3.106">islower</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Check if a given character is a lower case letter.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#ctype.h">ctype.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>int __fastcall__ islower (int c);</CODE></P>
<DT><B>Description</B><DD>
<P>The function returns a non zero value if the given argument
is a lower case letter. The return value is zero if the character is anything
else.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>When compiling with <CODE>-Os</CODE> the function is actually a macro. The
inline sequence generated by the macro will not work correctly for values
outside the range 0..255. <EM>Note:</EM> The constant <CODE>EOF</CODE> is not part of
this range. The non inline function may be accessed by <CODE>#undef</CODE>'ing the
macro.</LI>
<LI>When compiling without <CODE>-Os</CODE>, the function is only available as
fastcall function, so it may only be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>ISO 9899</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#isalnum">isalnum</A>,
<A HREF="#isalpha">isalpha</A>,
<A HREF="#isascii">isascii</A>,
<A HREF="#isblank">isblank</A>,
<A HREF="#iscntrl">iscntrl</A>,
<A HREF="#isdigit">isdigit</A>,
<A HREF="#isgraph">isgraph</A>,
<A HREF="#isprint">isprint</A>,
<A HREF="#ispunct">ispunct</A>,
<A HREF="#isspace">isspace</A>,
<A HREF="#isupper">isupper</A>,
<A HREF="#isxdigit">isxdigit</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="isprint"></A> <A NAME="ss3.107">3.107</A> <A HREF="#toc3.107">isprint</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Check if a given character is a printable character.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#ctype.h">ctype.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>int __fastcall__ isprint (int c);</CODE></P>
<DT><B>Description</B><DD>
<P>The function returns a non zero value if the given argument
is a printable character (this includes the space character). The return value
is zero if the character is anything else.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>When compiling with <CODE>-Os</CODE> the function is actually a macro. The
inline sequence generated by the macro will not work correctly for values
outside the range 0..255. <EM>Note:</EM> The constant <CODE>EOF</CODE> is not part of
this range. The non inline function may be accessed by <CODE>#undef</CODE>'ing the
macro.</LI>
<LI>When compiling without <CODE>-Os</CODE>, the function is only available as
fastcall function, so it may only be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>ISO 9899</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#isalnum">isalnum</A>,
<A HREF="#isalpha">isalpha</A>,
<A HREF="#isascii">isascii</A>,
<A HREF="#isblank">isblank</A>,
<A HREF="#iscntrl">iscntrl</A>,
<A HREF="#isdigit">isdigit</A>,
<A HREF="#isgraph">isgraph</A>,
<A HREF="#islower">islower</A>,
<A HREF="#ispunct">ispunct</A>,
<A HREF="#isspace">isspace</A>,
<A HREF="#isupper">isupper</A>,
<A HREF="#isxdigit">isxdigit</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="ispunct"></A> <A NAME="ss3.108">3.108</A> <A HREF="#toc3.108">ispunct</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Check if a given character is a printable character but not a
space or an alphanumeric character.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#ctype.h">ctype.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>int __fastcall__ ispunct (int c);</CODE></P>
<DT><B>Description</B><DD>
<P>The function returns a non zero value if the given argument
is a printable character, but not a space or anything alphanumeric. The return
value is zero if the character is anything else.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>When compiling with <CODE>-Os</CODE> the function is actually a macro. The
inline sequence generated by the macro will not work correctly for values
outside the range 0..255. <EM>Note:</EM> The constant <CODE>EOF</CODE> is not part of
this range. The non inline function may be accessed by <CODE>#undef</CODE>'ing the
macro.</LI>
<LI>When compiling without <CODE>-Os</CODE>, the function is only available as
fastcall function, so it may only be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>ISO 9899</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#isalnum">isalnum</A>,
<A HREF="#isalpha">isalpha</A>,
<A HREF="#isascii">isascii</A>,
<A HREF="#isblank">isblank</A>,
<A HREF="#iscntrl">iscntrl</A>,
<A HREF="#isdigit">isdigit</A>,
<A HREF="#isgraph">isgraph</A>,
<A HREF="#islower">islower</A>,
<A HREF="#isprint">isprint</A>,
<A HREF="#isspace">isspace</A>,
<A HREF="#isupper">isupper</A>,
<A HREF="#isxdigit">isxdigit</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="isspace"></A> <A NAME="ss3.109">3.109</A> <A HREF="#toc3.109">isspace</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Check if a given character is a a white-space character.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#ctype.h">ctype.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>int __fastcall__ isspace (int c);</CODE></P>
<DT><B>Description</B><DD>
<P>The function returns a non zero value if the given argument
is a white space character. The return value is zero if the character is
anything else. The standard white space characters are: space, formfeed ('\f'),
newline ('\n'), carriage return ('\r'), horizontal tab ('\t'), and vertical tab
('\v').</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>When compiling with <CODE>-Os</CODE> the function is actually a macro. The
inline sequence generated by the macro will not work correctly for values
outside the range 0..255. <EM>Note:</EM> The constant <CODE>EOF</CODE> is not part of
this range. The non inline function may be accessed by <CODE>#undef</CODE>'ing the
macro.</LI>
<LI>When compiling without <CODE>-Os</CODE>, the function is only available as
fastcall function, so it may only be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>ISO 9899</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#isalnum">isalnum</A>,
<A HREF="#isalpha">isalpha</A>,
<A HREF="#isascii">isascii</A>,
<A HREF="#isblank">isblank</A>,
<A HREF="#iscntrl">iscntrl</A>,
<A HREF="#isdigit">isdigit</A>,
<A HREF="#isgraph">isgraph</A>,
<A HREF="#islower">islower</A>,
<A HREF="#isprint">isprint</A>,
<A HREF="#ispunct">ispunct</A>,
<A HREF="#isupper">isupper</A>,
<A HREF="#isxdigit">isxdigit</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="isupper"></A> <A NAME="ss3.110">3.110</A> <A HREF="#toc3.110">isupper</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Check if a given character is an upper case letter.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#ctype.h">ctype.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>int __fastcall__ isupper (int c);</CODE></P>
<DT><B>Description</B><DD>
<P>The function returns a non zero value if the given argument
is an upper case letter. The return value is zero if the character is anything
else.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>When compiling with <CODE>-Os</CODE> the function is actually a macro. The
inline sequence generated by the macro will not work correctly for values
outside the range 0..255. <EM>Note:</EM> The constant <CODE>EOF</CODE> is not part of
this range. The non inline function may be accessed by <CODE>#undef</CODE>'ing the
macro.</LI>
<LI>When compiling without <CODE>-Os</CODE>, the function is only available as
fastcall function, so it may only be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>ISO 9899</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#isalnum">isalnum</A>,
<A HREF="#isalpha">isalpha</A>,
<A HREF="#isascii">isascii</A>,
<A HREF="#isblank">isblank</A>,
<A HREF="#iscntrl">iscntrl</A>,
<A HREF="#isdigit">isdigit</A>,
<A HREF="#isgraph">isgraph</A>,
<A HREF="#islower">islower</A>,
<A HREF="#isprint">isprint</A>,
<A HREF="#ispunct">ispunct</A>,
<A HREF="#isspace">isspace</A>,
<A HREF="#isxdigit">isxdigit</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="isxdigit"></A> <A NAME="ss3.111">3.111</A> <A HREF="#toc3.111">isxdigit</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Check if a given character is a hexadecimal digit.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#ctype.h">ctype.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>int __fastcall__ isxdigit (int c);</CODE></P>
<DT><B>Description</B><DD>
<P>The function returns a non zero value if the given argument
is a hexadecimal digit (0..9, a..f and A..F). The return value is zero if the
character is anything else.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>When compiling with <CODE>-Os</CODE> the function is actually a macro. The
inline sequence generated by the macro will not work correctly for values
outside the range 0..255. <EM>Note:</EM> The constant <CODE>EOF</CODE> is not part of
this range. The non inline function may be accessed by <CODE>#undef</CODE>'ing the
macro.</LI>
<LI>When compiling without <CODE>-Os</CODE>, the function is only available as
fastcall function, so it may only be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>ISO 9899</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#isalnum">isalnum</A>,
<A HREF="#isalpha">isalpha</A>,
<A HREF="#isascii">isascii</A>,
<A HREF="#isblank">isblank</A>,
<A HREF="#iscntrl">iscntrl</A>,
<A HREF="#isdigit">isdigit</A>,
<A HREF="#isgraph">isgraph</A>,
<A HREF="#islower">islower</A>,
<A HREF="#isprint">isprint</A>,
<A HREF="#ispunct">ispunct</A>,
<A HREF="#isspace">isspace</A>,
<A HREF="#isupper">isupper</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="itoa"></A> <A NAME="ss3.112">3.112</A> <A HREF="#toc3.112">itoa</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Convert an integer into a string.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#stdlib.h">stdlib.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>char* __fastcall__ itoa (int val, char* buf, int radix);</CODE></P>
<DT><B>Description</B><DD>
<P><CODE>itoa</CODE> converts the integer <CODE>val</CODE> into a string using
<CODE>radix</CODE> as the base.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>There are no provisions to prevent a buffer overflow.</LI>
<LI>If <CODE>val</CODE> contains <CODE>INT_MIN</CODE>, the behaviour is undefined.</LI>
<LI>The function is non standard, so it is not available in strict ANSI mode.
You should probably use <CODE>sprintf</CODE> instead.</LI>
<LI>The function is only available as fastcall function, so it may only be
used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#atoi">atoi</A>,
<A HREF="#atol">atol</A>,
<A HREF="#ltoa">ltoa</A>,
<A HREF="#ultoa">ultoa</A>,
<A HREF="#utoa">utoa</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="joy_count"></A> <A NAME="ss3.113">3.113</A> <A HREF="#toc3.113">joy_count</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Return the number of joysticks supported by the current driver.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#joystick.h">joystick.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>unsigned char joy_count (void);</CODE></P>
<DT><B>Description</B><DD>
<P>The function returns a the number of joysticks supported
by the current joystick driver.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>A joystick driver must be loaded using 
<A HREF="#joy_load_driver">joy_load_driver</A> before calling this function.</LI>
<LI>The function returns the number of joysticks supported by the driver.
There's no way to check for the number of actually connected joysticks.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#joy_load_driver">joy_load_driver</A>,
<A HREF="#joy_read">joy_read</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="joy_install"></A> <A NAME="ss3.114">3.114</A> <A HREF="#toc3.114">joy_install</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Install an already loaded driver and return an error code.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#joystick.h">joystick.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>unsigned char __fastcall__ joy_install (void* driver);</CODE></P>
<DT><B>Description</B><DD>
<P>The function installs a driver that was already loaded into
memory (or linked statically to the program). It returns an error code
(<CODE>JOY_ERR_OK</CODE> in case of success).</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only be
used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#joy_load_driver">joy_load_driver</A>,
<A HREF="#joy_uninstall">joy_uninstall</A>,
<A HREF="#joy_unload">joy_unload</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="joy_load_driver"></A> <A NAME="ss3.115">3.115</A> <A HREF="#toc3.115">joy_load_driver</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Load a driver from disk and install it.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#joystick.h">joystick.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>unsigned char __fastcall__ joy_load_driver (const char* driver);</CODE></P>
<DT><B>Description</B><DD>
<P>The function loads a driver with the given name from disk
and installs it. An error code is returned, which is <CODE>JOY_ERR_OK</CODE> if the
driver was successfully loaded and installed.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only be
used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#joy_install">joy_install</A>,
<A HREF="#joy_uninstall">joy_uninstall</A>,
<A HREF="#joy_unload">joy_unload</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="joy_read"></A> <A NAME="ss3.116">3.116</A> <A HREF="#toc3.116">joy_read</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Read the status of a joystick.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#joystick.h">joystick.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>unsigned char __fastcall__ joy_read (unsigned char joystick);</CODE></P>
<DT><B>Description</B><DD>
<P>The function reads the status bits for a joystick. The number
of the joystick is passed as parameter. The result may be examined by using one
of the <CODE>JOY_xxx</CODE> macros from 
<A HREF="#joystick.h">joystick.h</A>.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>A joystick driver must be loaded using 
<A HREF="#joy_load_driver">joy_load_driver</A> before calling this function.</LI>
<LI>The function is only available as fastcall function, so it may only be
used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#joy_count">joy_count</A>,
<A HREF="#joy_load_driver">joy_load_driver</A>,
<A HREF="#joy_unload">joy_unload</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="joy_uninstall"></A> <A NAME="ss3.117">3.117</A> <A HREF="#toc3.117">joy_uninstall</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Uninstall the current joystick driver.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#joystick.h">joystick.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>unsigned char joy_uninstall (void);</CODE></P>
<DT><B>Description</B><DD>
<P>The function uninstalls the currently installed joystick
driver. It does not remove the driver from memory. The function returns an
error code, which is <CODE>JOY_ERR_OK</CODE> if the driver was successfully uninstalled.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>A joystick driver must be installed using 
<A HREF="#joy_install">joy_install</A> before calling this function.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#joy_install">joy_install</A>,
<A HREF="#joy_load_driver">joy_load_driver</A>,
<A HREF="#joy_unload">joy_unload</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="joy_unload"></A> <A NAME="ss3.118">3.118</A> <A HREF="#toc3.118">joy_unload</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Uninstall, then unload the current joystick driver.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#joystick.h">joystick.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>unsigned char joy_unload (void);</CODE></P>
<DT><B>Description</B><DD>
<P>The function uninstalls the currently installed joystick
driver and removes it from memory. An error code is returned, which is
<CODE>JOY_ERR_OK</CODE> if the driver was successfully uninstalled.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>A joystick driver must be loaded using 
<A HREF="#joy_load_driver">joy_load_driver</A> before calling this function.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#joy_load_driver">joy_load_driver</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="kbhit"></A> <A NAME="ss3.119">3.119</A> <A HREF="#toc3.119">kbhit</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Check if there's a key waiting in the keyboard buffer.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#conio.h">conio.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>unsigned char kbhit (void);</CODE></P>
<DT><B>Description</B><DD>
<P>The function returns a value of zero if there is no character
waiting to be read from the keyboard. It returns non zero otherwise.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>If the system does not support a keyboard buffer (most systems
do), the function is rather useless.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#cgetc">cgetc</A>,
<A HREF="#cursor">cursor</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="labs"></A> <A NAME="ss3.120">3.120</A> <A HREF="#toc3.120">labs</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Returns the absolute value of a long integer.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#stdlib.h">stdlib.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>long __fastcall__ labs (long v);</CODE></P>
<DT><B>Description</B><DD>
<P><CODE>labs</CODE> returns the absolute value of the argument passed to
the function.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The return value is undefined if <CODE>LONG_MIN</CODE> is passed to the function.</LI>
<LI>The function is only available as fastcall function, so it may only be
used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>ISO 9899</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#abs">abs</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="ltoa"></A> <A NAME="ss3.121">3.121</A> <A HREF="#toc3.121">ltoa</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Convert a long integer into a string.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#stdlib.h">stdlib.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>char* __fastcall__ ltoa (long val, char* buf, int radix);</CODE></P>
<DT><B>Description</B><DD>
<P><CODE>itoa</CODE> converts the long integer <CODE>val</CODE> into a string
using <CODE>radix</CODE> as the base.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>There are no provisions to prevent a buffer overflow.</LI>
<LI>If <CODE>val</CODE> contains <CODE>LONG_MIN</CODE>, the behaviour is undefined.</LI>
<LI>The function is non standard, so it is not available in strict ANSI mode.
You should probably use <CODE>sprintf</CODE> instead.</LI>
<LI>The function is only available as fastcall function, so it may only be
used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#atoi">atoi</A>,
<A HREF="#atol">atol</A>,
<A HREF="#itoa">itoa</A>,
<A HREF="#ultoa">ultoa</A>,
<A HREF="#utoa">utoa</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="localeconv"></A> <A NAME="ss3.122">3.122</A> <A HREF="#toc3.122">localeconv</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Returns a pointer to the current locale structure.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#locale.h">locale.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>struct lconv* localeconv (void);</CODE></P>
<DT><B>Description</B><DD>
<P><CODE>localeconv</CODE> returns a pointer to the current locale
structure.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>cc65 supports only the "C" locale, so even after setting a new locale
using <CODE>
<A HREF="#setlocale">setlocale</A></CODE>, the structure returned will
always be the same.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>ISO 9899</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#setlocale">setlocale</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="longjmp"></A> <A NAME="ss3.123">3.123</A> <A HREF="#toc3.123">longjmp</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Non local goto.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#setjmp.h">setjmp.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ longjmp (jmp_buf buf, int retval);</CODE></P>
<DT><B>Description</B><DD>
<P>The <CODE>longjmp</CODE> function restores a program context from the
data in <CODE>buf</CODE>, which must have been set by a preceeding call to
<CODE>
<A HREF="#setjmp">setjmp</A></CODE>. Program execution continues as if the
call to <CODE>
<A HREF="#setjmp">setjmp</A></CODE> has just returned the value
<CODE>retval</CODE>.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>If the parameter <CODE>retval</CODE> is zero, the function will behave as if it
was called with a value of one.</LI>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>ISO 9899</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#setjmp">setjmp</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="malloc"></A> <A NAME="ss3.124">3.124</A> <A HREF="#toc3.124">malloc</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Allocate dynamic memory.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#stdlib.h">stdlib.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void* __fastcall__ malloc (size_t size);</CODE></P>
<DT><B>Description</B><DD>
<P><CODE>malloc</CODE> allocates size bytes on the heap and returns a
pointer to the allocated memory block. On error (not enough memory available),
<CODE>malloc</CODE> returns <CODE>NULL</CODE>.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>ISO 9899</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#_heapadd">_heapadd</A>,
<A HREF="#_heapblocksize">_heapblocksize</A>,
<A HREF="#_heapmaxavail">_heapmaxavail</A>,
<A HREF="#_heapmemavail">_heapmemavail</A>,
<A HREF="#calloc">calloc</A>,
<A HREF="#free">free</A>,
<A HREF="#realloc">realloc</A>,
<A HREF="#strdup">strdup</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="memchr"></A> <A NAME="ss3.125">3.125</A> <A HREF="#toc3.125">memchr</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Search for a character in a block of raw memory.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#string.h">string.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void* __fastcall__ strchr (const void* mem, int c, size_t count);</CODE></P>
<DT><B>Description</B><DD>
<P>The <CODE>memchr</CODE> function locates the first occurrence of <CODE>c</CODE>
(converted to a char) in the block of raw memory string pointed to by <CODE>mem</CODE>
that is of size <CODE>count</CODE>. Upon completion, the function returns a pointer to
the character found, or a null pointer if the character was not found.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>ISO 9899</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#strchr">strchr</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="memcmp"></A> <A NAME="ss3.126">3.126</A> <A HREF="#toc3.126">memcmp</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Compare two memory areas.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#string.h">string.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>int __fastcall__ memcmp (const void* p1, const void* p2, size_t count);</CODE></P>
<DT><B>Description</B><DD>
<P><CODE>memcmp</CODE> compares <CODE>count</CODE> bytes from the memory area
pointed to by <CODE>p1</CODE> into the memory area pointed to by <CODE>p2</CODE>. It returns a value that is less than
zero if <CODE>p1</CODE> is less than <CODE>p2</CODE>, zero if <CODE>p1</CODE> is the same as <CODE>p2</CODE>,
and a value greater than zero if <CODE>p1</CODE> is greater than <CODE>p2</CODE>.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>ISO 9899</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#strcmp">strcmp</A>,
<A HREF="#memmove">memmove</A>,
<A HREF="#memset">memset</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="memcpy"></A> <A NAME="ss3.127">3.127</A> <A HREF="#toc3.127">memcpy</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Copy a memory area.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#string.h">string.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void* __fastcall__ memcpy (void* dest, const void* src, size_t count);</CODE></P>
<DT><B>Description</B><DD>
<P><CODE>memcpy</CODE> copies <CODE>count</CODE> bytes from the memory area
pointed to by <CODE>src</CODE> into the memory area pointed to by <CODE>dest</CODE>. It returns
<CODE>dest</CODE>.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The result is undefined if the memory areas do overlap. Use
<CODE>
<A HREF="#memmove">memmove</A></CODE> to copy overlapping memory areas.</LI>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>ISO 9899</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#_swap">_swap</A>,
<A HREF="#memmove">memmove</A>,
<A HREF="#memset">memset</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="memmove"></A> <A NAME="ss3.128">3.128</A> <A HREF="#toc3.128">memmove</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Copy a memory area.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#string.h">string.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void* __fastcall__ memmove (void* dest, const void* src, size_t count);</CODE></P>
<DT><B>Description</B><DD>
<P><CODE>memmove</CODE> copies <CODE>count</CODE> bytes from the memory area
pointed to by <CODE>src</CODE> into the memory area pointed to by <CODE>dest</CODE>. It returns
<CODE>dest</CODE>.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>While <CODE>memmove</CODE> allows the memory areas to overlap, it has some
additional overhead compared to <CODE>
<A HREF="#memcpy">memcpy</A></CODE>.</LI>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>ISO 9899</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#_swap">_swap</A>,
<A HREF="#memcpy">memcpy</A>,
<A HREF="#memset">memset</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="memset"></A> <A NAME="ss3.129">3.129</A> <A HREF="#toc3.129">memset</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Fill a memory area.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#string.h">string.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void* __fastcall__ memset (void* p, int val, size_t count);</CODE></P>
<DT><B>Description</B><DD>
<P><CODE>memset</CODE> fills the memory area pointed to by <CODE>p</CODE> with
the value <CODE>val</CODE>. The function returns <CODE>p</CODE>.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>ISO 9899</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#_swap">_swap</A>,
<A HREF="#bzero">bzero</A>,
<A HREF="#memcpy">memcpy</A>,
<A HREF="#memmove">memmove</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="mod_free"></A> <A NAME="ss3.130">3.130</A> <A HREF="#toc3.130">mod_free</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Free a relocatable module.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#modload.h">modload.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ mod_free (void* module);</CODE></P>
<DT><B>Description</B><DD>
<P>The function will free a module loaded into memory by use of
the <CODE>
<A HREF="#mod_load">mod_load</A></CODE> function.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The pointer passed as parameter is the pointer to the module memory,
not the pointer to the control structure.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#mod_load">mod_load</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="mod_load"></A> <A NAME="ss3.131">3.131</A> <A HREF="#toc3.131">mod_load</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Load a relocatable module.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#modload.h">modload.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>unsigned char mod_load (struct mod_ctrl* ctrl);</CODE></P>
<DT><B>Description</B><DD>
<P>The function will load a code module into memory and relocate
it. The function will return an error code. If <CODE>MLOAD_OK</CODE> is returned, the
outgoing fields in the passed <CODE>mod_ctrl</CODE> struct contain information about
the module just loaded. Possible error codes are:
<UL>
<LI><CODE>MLOAD_OK</CODE> - Module load successful</LI>
<LI><CODE>MLOAD_ERR_READ</CODE> - Read error</LI>
<LI><CODE>MLOAD_ERR_HDR</CODE> - Header error</LI>
<LI><CODE>MLOAD_ERR_OS</CODE> - Wrong operating system</LI>
<LI><CODE>MLOAD_ERR_FMT</CODE> - Data format error</LI>
<LI><CODE>MLOAD_ERR_MEM</CODE> - Not enough memory</LI>
</UL>
</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The 
<A HREF="ld65.html">ld65</A> linker is needed to create
relocatable o65 modules for use with this function.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#mod_free">mod_free</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="mouse_setbox"></A> <A NAME="ss3.132">3.132</A> <A HREF="#toc3.132">mouse_setbox</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Specify a bounding box for the mouse cursor.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#mouse.h">mouse.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ mouse_setbox (const struct mouse_box* box);</CODE></P>
<DT><B>Description</B><DD>
<P>The function allows to set a bounding box for mouse movement.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function does not check if the mouse cursor is currently within the
given rectangle. Placing the mouse cursor within the bounding box is the
responsibility of the programmer.</LI>
<LI>While the bounding box may be larger than the actual screen size, the
standard mouse cursor draw routines may fail to set the cursor to coordinates
outside of the screen area. Depending on the platform, you may have to supply
your own mouse cursor routines.</LI>
<LI>The function is only available as fastcall function, so it may only be
used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#mouse_getbox">mouse_getbox</A>,
<A HREF="#mouse_move">mouse_move</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="mouse_getbox"></A> <A NAME="ss3.133">3.133</A> <A HREF="#toc3.133">mouse_getbox</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Return the current bounding box for the mouse cursor.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#mouse.h">mouse.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ mouse_getbox (struct mouse_box* box);</CODE></P>
<DT><B>Description</B><DD>
<P>The function queries the current bounding box for mouse
movement.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only be
used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#mouse_move">mouse_move</A>,
<A HREF="#mouse_setbox">mouse_setbox</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="mouse_buttons"></A> <A NAME="ss3.134">3.134</A> <A HREF="#toc3.134">mouse_buttons</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Return a bit mask encoding the state of the mouse buttons.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#mouse.h">mouse.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>unsigned char mouse_buttons (void);</CODE></P>
<DT><B>Description</B><DD>
<P>The function returns a bit mask that encodes the state of the
mouse buttons. You may use the <CODE>MOUSE_BTN_XXX</CODE> flags to decode the function
return value.</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#mouse_info">mouse_info</A>,
<A HREF="#mouse_pos">mouse_pos</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="mouse_geterrormsg"></A> <A NAME="ss3.135">3.135</A> <A HREF="#toc3.135">mouse_geterrormsg</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Return a readable error message for an error code.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#mouse.h">mouse.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>const char* __fastcall__ mouse_geterrormsg (unsigned char
code);</CODE></P>
<DT><B>Description</B><DD>
<P>The function returns an error message (in english) for the
error code passed parameter.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function will return "Unknown error" for invalid error codes.</LI>
<LI>The function is only available as fastcall function, so it may only be
used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#mouse_load_driver">mouse_load_driver</A>,
<A HREF="#mouse_uninstall">mouse_uninstall</A>,
<A HREF="#mouse_unload">mouse_unload</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="mouse_hide"></A> <A NAME="ss3.136">3.136</A> <A HREF="#toc3.136">mouse_hide</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Hide the mouse pointer.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#mouse.h">mouse.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void mouse_hide (void);</CODE></P>
<DT><B>Description</B><DD>
<P>The function hides the mouse pointer. It manages a counter
that is shared between <CODE>
<A HREF="#mouse_show">mouse_show</A></CODE> and
<CODE>mouse_hide</CODE> so that every call call to <CODE>mouse_hide</CODE> must be followed by
a call to <CODE>
<A HREF="#mouse_show">mouse_show</A></CODE> to make the mouse cursor
visible.</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#mouse_show">mouse_show</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="mouse_info"></A> <A NAME="ss3.137">3.137</A> <A HREF="#toc3.137">mouse_info</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Return the state of the mouse buttons and the position of the
mouse.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#mouse.h">mouse.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ mouse_info (struct mouse_info* info);</CODE></P>
<DT><B>Description</B><DD>
<P>The function returns the state of the mouse buttons and the
position of the mouse in the <CODE>mouse_info</CODE> structure passed as parameter.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The <CODE>mouse_info</CODE> struct is a superset of the <CODE>mouse_pos</CODE> struct,
so if you just need the mouse position, call <CODE>
<A HREF="#mouse_pos">mouse_pos</A></CODE> instead.</LI>
<LI>The function is only available as fastcall function, so it may only be
used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#mouse_buttons">mouse_buttons</A>,
<A HREF="#mouse_pos">mouse_pos</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="mouse_install"></A> <A NAME="ss3.138">3.138</A> <A HREF="#toc3.138">mouse_install</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Install an already loaded mouse driver.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#mouse.h">mouse.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>unsigned char __fastcall__ mouse_install (const struct
mouse_callbacks* c, void* driver);</CODE></P>
<DT><B>Description</B><DD>
<P>The function installs an already loaded mouse driver and
returns an error code. The <CODE>mouse_callbacks</CODE> structure passed as first
parameter contains pointers to routines needed to move or hide/show the mouse
pointer. Defaults for these routines are supplied by the library, so if you
can live with these defaults (which are platform specific), just pass a
pointer to <CODE>mouse_def_callbacks</CODE>. The function may be used to install a
driver linked statically to the program.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>Not all drivers are able to detect if the supported hardware is really
present.</LI>
<LI>After installing a driver, the mouse cursor is hidden.</LI>
<LI>The function is only available as fastcall function, so it may only be
used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#mouse_load_driver">mouse_load_driver</A>,
<A HREF="#mouse_uninstall">mouse_uninstall</A>,
<A HREF="#mouse_unload">mouse_unload</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="mouse_ioctl"></A> <A NAME="ss3.139">3.139</A> <A HREF="#toc3.139">mouse_ioctl</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Call the driver specific ioctl function.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#mouse.h">mouse.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>unsigned char __fastcall__ mouse_ioctl (unsigned char code, void* data);</CODE></P>
<DT><B>Description</B><DD>
<P>The function calls the IOCTL entry in the mouse driver,
which is driver specific. The <CODE>code</CODE> parameter will choose between
different IOCTL functions, and the <CODE>data</CODE> depends on code. The
function returns an error code. The purpose of this function is to allow
for driver specific extensions. See the documentation for a specific mouse
driver for supported ioctl calls.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>Calling this function is non portable, because each driver may
implement different ioctl calls (or none at all).</LI>
<LI>The function is only available as fastcall function, so it may only be
used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="mouse_load_driver"></A> <A NAME="ss3.140">3.140</A> <A HREF="#toc3.140">mouse_load_driver</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Load and initialize a mouse driver.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#mouse.h">mouse.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>unsigned char __fastcall__ mouse_load_driver (const struct
mouse_callbacks* c, const char* driver);</CODE></P>
<DT><B>Description</B><DD>
<P>Load a mouse driver into memory and initialize it. The
function returns an error code that tells if the call has been successful. The
<CODE>mouse_callbacks</CODE> structure passed as first parameter contains pointers to
routines needed to move or hide/show the mouse pointer. Defaults for these
routines are supplied by the library, so if you can live with these defaults
(which are platform specific), just pass a pointer to <CODE>mouse_def_callbacks</CODE>.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The driver is loaded by name, so currently you must know the type of
mouse that should be supported. There is no autodetect capability.</LI>
<LI>Not all drivers are able to detect if the supported hardware is really
present.</LI>
<LI>After installing a driver, the mouse cursor is hidden.</LI>
<LI>The function is only available as fastcall function, so it may only be
used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#mouse_install">mouse_install</A>,
<A HREF="#mouse_uninstall">mouse_uninstall</A>,
<A HREF="#mouse_unload">mouse_unload</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="mouse_move"></A> <A NAME="ss3.141">3.141</A> <A HREF="#toc3.141">mouse_move</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Move the mouse cursor to a specific position.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#mouse.h">mouse.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ mouse_move (int x, int y);</CODE></P>
<DT><B>Description</B><DD>
<P>The function updates the mouse position. If the mouse cursor
is visible, it is shown at the new position.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function does not check if the new position is within the bounding
box specified with <CODE>
<A HREF="#mouse_setbox">mouse_setbox</A></CODE>.</LI>
<LI>The function is only available as fastcall function, so it may only be
used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#mouse_getbox">mouse_getbox</A>,
<A HREF="#mouse_setbox">mouse_setbox</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="mouse_pos"></A> <A NAME="ss3.142">3.142</A> <A HREF="#toc3.142">mouse_pos</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Return the position of the mouse.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#mouse.h">mouse.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ mouse_pos (struct mouse_pos* pos);</CODE></P>
<DT><B>Description</B><DD>
<P>The function returns the position of the mouse in the
<CODE>mouse_pos</CODE> structure passed as parameter.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The <CODE>mouse_pos</CODE> struct is a subset of the <CODE>mouse_info</CODE> struct,
so if you do also need the mouse buttons, call <CODE>
<A HREF="#mouse_info">mouse_info</A></CODE> instead.</LI>
<LI>The function is only available as fastcall function, so it may only be
used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#mouse_buttons">mouse_buttons</A>,
<A HREF="#mouse_info">mouse_info</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="mouse_show"></A> <A NAME="ss3.143">3.143</A> <A HREF="#toc3.143">mouse_show</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Show the mouse pointer.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#mouse.h">mouse.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void mouse_show (void);</CODE></P>
<DT><B>Description</B><DD>
<P>The function shows the mouse pointer. It manages a counter
that is shared between <CODE>
<A HREF="#mouse_hide">mouse_hide</A></CODE> and
<CODE>mouse_show</CODE>. The mouse cursor is visible if there was one more call to
<CODE>mouse_show</CODE> than to <CODE>
<A HREF="#mouse_hide">mouse_hide</A></CODE>.</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#mouse_hide">mouse_hide</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="mouse_uninstall"></A> <A NAME="ss3.144">3.144</A> <A HREF="#toc3.144">mouse_uninstall</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Uninstall an already loaded mouse driver.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#mouse.h">mouse.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>unsigned char mouse_uninstall (void);</CODE></P>
<DT><B>Description</B><DD>
<P>The function uninstalls an already loaded mouse driver but
don't removes it from memory.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>If the driver has been loaded using <CODE>
<A HREF="#mouse_load_driver">mouse_load_driver</A></CODE>, <CODE>
<A HREF="#mouse_unload">mouse_unload</A></CODE>
should be used instead of <CODE>mouse_uninstall</CODE> so the driver is also removed
from memory.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#mouse_install">mouse_install</A>,
<A HREF="#mouse_load_driver">mouse_load_driver</A>,
<A HREF="#mouse_unload">mouse_unload</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="mouse_unload"></A> <A NAME="ss3.145">3.145</A> <A HREF="#toc3.145">mouse_unload</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Unload a mouse driver.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#mouse.h">mouse.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>unsigned char __fastcall__ mouse_unload (void);</CODE></P>
<DT><B>Description</B><DD>
<P>The function unloads a loaded mouse driver and frees all
memory allocated for the driver.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function does nothing if no driver is loaded.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#mouse_install">mouse_install</A>,
<A HREF="#mouse_load_driver">mouse_load_driver</A>,
<A HREF="#mouse_uninstall">mouse_uninstall</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="offsetof"></A> <A NAME="ss3.146">3.146</A> <A HREF="#toc3.146">offsetof</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Calculate the offset of a struct or union member.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#stddef.h">stddef.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>size_t offsetof (type, member);</CODE></P>
<DT><B>Description</B><DD>
<P><CODE>offsetof</CODE> calculates the address offset of a <CODE>struct</CODE>
or <CODE>union</CODE> member.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is actually a macro.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>ISO 9899</P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="open"></A> <A NAME="ss3.147">3.147</A> <A HREF="#toc3.147">open</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Open and possibly create a file.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#fcntl.h">fcntl.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>int open (const char* name, int flags, ...);</CODE></P>
<DT><B>Description</B><DD>
<P><CODE>open</CODE> opens a file and returns the file descriptor
associated with it. On error, -1 is returned and an error code is stored in
<CODE>errno</CODE>. Several flags may be passed to <CODE>open</CODE> that change the behaviour.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>POSIX specifies an additional <CODE>mode</CODE> argument that may be passed to
open, which is used as the permission mask when a new file is created. While
cc65 allows to pass this argument, it is ignored.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>POSIX 1003.1</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#close">close</A>,
<A HREF="#creat">creat</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="opendir"></A> <A NAME="ss3.148">3.148</A> <A HREF="#toc3.148">opendir</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Open a directory.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#dirent.h">dirent.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>DIR* __fastcall__ opendir (const char* name);</CODE></P>
<DT><B>Description</B><DD>
<P><CODE>opendir</CODE> opens a directory and returns the direcory
descriptor associated with it. On error, NULL is returned and an error code is
stored in <CODE>errno</CODE>.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>POSIX 1003.1</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#closedir">closedir</A>,
<A HREF="#readdir">readdir</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="peekbsys"></A> <A NAME="ss3.149">3.149</A> <A HREF="#toc3.149">peekbsys</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Read one byte from a location in the system bank.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#cbm610.h">cbm610.h</A></CODE>,
<CODE>
<A HREF="#cbm510.h">cbm510.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>unsigned char __fastcall__ peekbsys (unsigned addr);</CODE></P>
<DT><B>Description</B><DD>
<P><CODE>peekbsys</CODE> reads one byte from the given address in the
system bank (bank 15) of the CBM PET-II machines and returns it.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
<LI>This function may be a macro depending on the compiler options. The
actual function is accessible by #undef'ing the macro.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#PEEK">PEEK</A>,
<A HREF="#PEEKW">PEEKW</A>,
<A HREF="#peekwsys">peekwsys</A>,
<A HREF="#pokebsys">pokebsys</A>,
<A HREF="#pokewsys">pokewsys</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="peekwsys"></A> <A NAME="ss3.150">3.150</A> <A HREF="#toc3.150">peekwsys</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Read one word from a location in the system bank.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#cbm610.h">cbm610.h</A></CODE>,
<CODE>
<A HREF="#cbm510.h">cbm510.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>unsigned __fastcall__ peekwsys (unsigned addr);</CODE></P>
<DT><B>Description</B><DD>
<P><CODE>peekwsys</CODE> reads one word from the given address in the
system bank (bank 15) of the CBM PET-II machines and returns it. Following
the usual 6502 conventions, the low byte is read from <CODE>addr</CODE>, and the
high byte is read from <CODE>addr+1</CODE>.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
<LI>The order in which the two bytes are read is undefined.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#PEEK">PEEK</A>,
<A HREF="#PEEKW">PEEKW</A>,
<A HREF="#peekbsys">peekbsys</A>,
<A HREF="#pokebsys">pokebsys</A>,
<A HREF="#pokewsys">pokewsys</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="perror"></A> <A NAME="ss3.151">3.151</A> <A HREF="#toc3.151">perror</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Print an error message for the error in <CODE>errno</CODE>.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#stdio.h">stdio.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ perror (const char* s);</CODE></P>
<DT><B>Description</B><DD>
<P><CODE>perror</CODE> prints an error message to <CODE>stderr</CODE>. If <CODE>s</CODE>
is not <CODE>NULL</CODE> and not an empty string, it is printed followed by a colon and
a blank. Then the error message for the current contents of <CODE>errno</CODE> is
printed followed by a newline. The message output is the same as returned by
<CODE>
<A HREF="#strerror">strerror</A></CODE> with an argument of <CODE>errno</CODE>.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>ISO 9899</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#_poserror">_poserror</A>,
<A HREF="#strerror">strerror</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="pokebsys"></A> <A NAME="ss3.152">3.152</A> <A HREF="#toc3.152">pokebsys</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Write one byte to a location in the system bank.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#cbm610.h">cbm610.h</A></CODE>,
<CODE>
<A HREF="#cbm510.h">cbm510.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ pokebsys (unsigned addr, unsigned char val);</CODE></P>
<DT><B>Description</B><DD>
<P><CODE>pokebsys</CODE> writes one byte to the given address in the
system bank (bank 15) of the CBM PET-II machines.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#POKE">POKE</A>,
<A HREF="#POKEW">POKEW</A>,
<A HREF="#peekbsys">peekbsys</A>,
<A HREF="#peekwsys">peekwsys</A>,
<A HREF="#pokewsys">pokewsys</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="pokewsys"></A> <A NAME="ss3.153">3.153</A> <A HREF="#toc3.153">pokewsys</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Write one word to a location in the system bank.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#cbm610.h">cbm610.h</A></CODE>,
<CODE>
<A HREF="#cbm510.h">cbm510.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ pokewsys (unsigned addr, unsigned val);</CODE></P>
<DT><B>Description</B><DD>
<P><CODE>pokewsys</CODE> writes one word to the given address in the
system bank (bank 15) of the CBM PET-II machines. Following the usual 6502
conventions, the low byte of <CODE>val</CODE> is written to <CODE>addr</CODE>, and the
high byte is written to <CODE>addr+1</CODE>.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
<LI>The order in which the two bytes are written is undefined.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#POKE">POKE</A>,
<A HREF="#POKEW">POKEW</A>,
<A HREF="#peekbsys">peekbsys</A>,
<A HREF="#peekwsys">peekwsys</A>,
<A HREF="#pokebsys">pokebsys</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="qsort"></A> <A NAME="ss3.154">3.154</A> <A HREF="#toc3.154">qsort</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Sort an array.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#stdlib.h">stdlib.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ qsort (void* base, size_t count,
size_t size, int (*compare) (const void*, const void*));</CODE></P>
<DT><B>Description</B><DD>
<P><CODE>qsort</CODE> sorts an array according to a given compare
function <CODE>compare</CODE>. <CODE>base</CODE> is the address of the array, <CODE>count</CODE>
is the number of elements, <CODE>size</CODE> the size of an element and <CODE>compare</CODE>
the function used to compare the members.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>If there are multiple members with the same key, the order after calling
the function is undefined.</LI>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>ISO 9899</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#bsearch">bsearch</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="raise"></A> <A NAME="ss3.155">3.155</A> <A HREF="#toc3.155">raise</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Send a signal to the executing program.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#signal.h">signal.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>int __fastcall__ raise (int sig);</CODE></P>
<DT><B>Description</B><DD>
<P><CODE>raise</CODE> sends the given signal to the program. If the
program has installed a signal handler for the signal, this signal handler
will be executed. If no handler has been installed, the default action for
the raised signal will be taken. The function returns zero on success,
nonzero otherwise.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>ISO 9899</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#abort">abort</A>,
<A HREF="#signal">signal</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="rand"></A> <A NAME="ss3.156">3.156</A> <A HREF="#toc3.156">rand</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Return a pseudo random number.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#stdlib.h">stdlib.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>int rand (void);</CODE></P>
<DT><B>Description</B><DD>
<P>The function returns a pseudo random number
between 0 and <CODE>RAND_MAX</CODE> (exclusive).</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>Without using <CODE>
<A HREF="#srand">srand</A></CODE>, always the same
flow of numbers is generated.</LI>
<LI>On startup, the function behaves as if 
<A HREF="#srand">srand</A>
had been used with an argument of 1.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>ISO 9899</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#_randomize">_randomize</A>,
<A HREF="#srand">srand</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="readdir"></A> <A NAME="ss3.157">3.157</A> <A HREF="#toc3.157">readdir</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Read a directory.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#dirent.h">dirent.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>struct dirent* __fastcall__ readdir (DIR* dir);</CODE></P>
<DT><B>Description</B><DD>
<P><CODE>readdir</CODE> reads the next directory entry from the directory
stream pointed to by <CODE>dir</CODE>. It stores the data in a <CODE>dirent</CODE> structure
and returns a pointer to it. If the end of directory is reached, or an error
occurs, NULL is returned. In case of errors, an error code is stored into
<CODE>errno</CODE>.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
<LI>The returned pointer may point to a statically allocated instance of
<CODE>struct dirent</CODE>, so it may get overwritten by subsequent calls to
<CODE>readdir</CODE>.</LI>
<LI>On several platforms, namely the CBMs and the Atari, the disk drives get
confused when opening/closing files between directory reads. So for example a
program that reads the list of files on a disk, and after each call to
<CODE>readdir</CODE>, opens the file to process it, will fail.<BR>
Possible solutions are reading the directory into memory before processing the
file list, or to reset the directory by seeking to the correct position after
opening/closing a file:
<PRE>
        seekdir (DIR, telldir (DIR));
</PRE>

Platforms known to work without problems are: Apple.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>POSIX 1003.1</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#closedir">closedir</A>,
<A HREF="#opendir">opendir</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="realloc"></A> <A NAME="ss3.158">3.158</A> <A HREF="#toc3.158">realloc</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Change the size of an allocated memory block.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#stdlib.h">stdlib.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void* __fastcall__ realloc (void* block, size_t size);</CODE></P>
<DT><B>Description</B><DD>
<P><CODE>realloc</CODE> changes the size of the memory block pointed to
by <CODE>block</CODE> to <CODE>size</CODE> bytes. If <CODE>block</CODE> is <CODE>NULL</CODE>, <CODE>realloc</CODE>
behaves as if <CODE>malloc</CODE> had been called. If <CODE>size</CODE> is zero, <CODE>realloc</CODE>
behaves as if <CODE>free</CODE> had been called. On error (not enough memory
available), <CODE>realloc</CODE> returns <CODE>NULL</CODE>.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The part of the memory block that is returned will have its contents
unchanged.</LI>
<LI>This function is somewhat dangerous to use. Be careful to save the
pointer you're passing somewhere else, otherwise
<BLOCKQUOTE><CODE>
<PRE>
        ptr = realloc (ptr, size);
</PRE>
</CODE></BLOCKQUOTE>

will loose your only copy of <CODE>ptr</CODE> if <CODE>realloc</CODE> returns <CODE>NULL</CODE>.</LI>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>ISO 9899</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#_heapadd">_heapadd</A>,
<A HREF="#_heapblocksize">_heapblocksize</A>,
<A HREF="#_heapmaxavail">_heapmaxavail</A>,
<A HREF="#_heapmemavail">_heapmemavail</A>,
<A HREF="#calloc">calloc</A>,
<A HREF="#free">free</A>,
<A HREF="#realloc">realloc</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="remove"></A> <A NAME="ss3.159">3.159</A> <A HREF="#toc3.159">remove</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Delete a file.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#stdio.h">stdio.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>int __fastcall__ remove (const char* name);</CODE></P>
<DT><B>Description</B><DD>
<P><CODE>remove</CODE> deletes the file with the given name. On success,
zero is returned. On error, -1 is returned and <CODE>errno</CODE> is set to an error
code describing the reason for the failure.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>This function is not available on all cc65 targets (depends on the
availability of file I/O).</LI>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>ISO 9899</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#rename">rename</A>,
<A HREF="#unlink">unlink</A></P>
<DT><B>Example</B><DD>
<P>
<PRE>
#include &lt;stdio.h&gt;

#define FILENAME "helloworld"

if (remove (FILENAME) == 0) {
    printf ("We deleted %s successfully\n", FILENAME);
} else {
    printf ("There was a problem deleting %s\n", FILENAME);
}
</PRE>
</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="rename"></A> <A NAME="ss3.160">3.160</A> <A HREF="#toc3.160">rename</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Rename a file.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#stdio.h">stdio.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>int __fastcall__ rename (const char* oldname, const char* newname);</CODE></P>
<DT><B>Description</B><DD>
<P><CODE>rename</CODE> renames a file (gives it a new name). On success,
zero is returned. On error, -1 is returned and <CODE>errno</CODE> is set to an error
code describing the reason for the failure.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>This function is not available on all cc65 targets (depends on the
capabilities of the storage devices).</LI>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>ISO 9899</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#remove">remove</A></P>
<DT><B>Example</B><DD>
<P>
<PRE>
#include &lt;stdio.h&gt;

#define OLDNAME "textfile.txt"
#define NEWNAME "textfile.bak"

if (rename (OLDNAME, NEWNAME) == 0) {
    printf ("Renamed %s to %s\n", OLDNAME, NEWNAME);
} else {
    printf ("Error renaming %s to %s\n", OLDNAME, NEWNAME);
}
</PRE>
</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="reset_brk"></A> <A NAME="ss3.161">3.161</A> <A HREF="#toc3.161">reset_brk</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Resets the break vector to its original value.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#6502.h">6502.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void reset_brk (void);</CODE></P>
<DT><B>Description</B><DD>
<P><CODE>reset_brk</CODE> resets the break vector to the value it had
before a call to <CODE>set_brk</CODE>.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>Since <CODE>
<A HREF="#set_brk">set_brk</A></CODE> installs an exit handler,
it is not strictly necessary to call this function as part of the cleanup when
the program ends.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#reset_irq">reset_irq</A>,
<A HREF="#set_brk">set_brk</A>,
<A HREF="#set_irq">set_irq</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="reset_irq"></A> <A NAME="ss3.162">3.162</A> <A HREF="#toc3.162">reset_irq</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Resets the C level interrupt request vector.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#6502.h">6502.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void reset_irq (void);</CODE></P>
<DT><B>Description</B><DD>
<P><CODE>reset_irq</CODE> resets the C level interrupt request vector.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The original IRQ vector is restored on program termination even without
calling this function.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#reset_brk">reset_brk</A>,
<A HREF="#set_brk">set_brk</A>,
<A HREF="#set_irq">set_irq</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="revers"></A> <A NAME="ss3.163">3.163</A> <A HREF="#toc3.163">revers</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Control revers character display.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#conio.h">conio.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>unsigned char __fastcall__ revers (unsigned char onoff);</CODE></P>
<DT><B>Description</B><DD>
<P>If the argument is non zero, the function enables reverse
character display. If the argument is zero, reverse character display is
switched off. The old value of the setting is returned.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function may not be supported by the hardware, in which case
the call is ignored.</LI>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#textcolor">textcolor</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="rewinddir"></A> <A NAME="ss3.164">3.164</A> <A HREF="#toc3.164">rewinddir</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Reset a directory stream.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#dirent.h">dirent.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ rewinddir (DIR* dir);</CODE></P>
<DT><B>Description</B><DD>
<P><CODE>rewinddir</CODE> sets the position of the directory stream
pointed to by <CODE>dir</CODE> to the start of the directory.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>POSIX 1003.1</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#seekdir">seekdir</A>,
<A HREF="#telldir">telldir</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="screensize"></A> <A NAME="ss3.165">3.165</A> <A HREF="#toc3.165">screensize</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Return the dimensions of the text mode screen.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#conio.h">conio.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ screensize (unsigned char* x, unsigned char* y);</CODE></P>
<DT><B>Description</B><DD>
<P>The function returns the dimensions of the text mode screen.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#gotox">gotox</A>,
<A HREF="#gotoxy">gotoxy</A>,
<A HREF="#gotoy">gotoy</A>,
<A HREF="#wherex">wherex</A>,
<A HREF="#wherey">wherey</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="seekdir"></A> <A NAME="ss3.166">3.166</A> <A HREF="#toc3.166">seekdir</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Set the position of a directory stream.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#dirent.h">dirent.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ seekdir (DIR* dir, long offset);</CODE></P>
<DT><B>Description</B><DD>
<P><CODE>seekdir</CODE> sets the position of the directory stream
pointed to by <CODE>dir</CODE> to the value given in <CODE>offset</CODE>, which should be a
value returned by <CODE>
<A HREF="#telldir">telldir</A></CODE>.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>POSIX 1003.1</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#rewinddir">rewinddir</A>,
<A HREF="#telldir">telldir</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="ser_close"></A> <A NAME="ss3.167">3.167</A> <A HREF="#toc3.167">ser_close</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Close the port and disable interrupts</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#serial.h">serial.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>unsigned char ser_close (void);</CODE></P>
<DT><B>Description</B><DD>
<P>Close the port by clearing buffers and disable interrupts.</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>Other serial functions.</P>
<DT><B>Example</B><DD>
<P>
<PRE>
#include &lt;serial.h>

static void initialize(){
  struct ser_params params = {
    SER_BAUD_9600,
    SER_BITS_8,
    SER_STOP_1,
    SER_PAR_MARK,
    SER_HS_NONE
  };
  ser_install(lynx_comlynx); // This will activate the ComLynx
  CLI();
  ser_open(&amp;params);
}
</PRE>
</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="ser_get"></A> <A NAME="ss3.168">3.168</A> <A HREF="#toc3.168">ser_get</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Read a character from serial port.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#serial.h">serial.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>unsigned char __fastcall__ ser_get (char* b);</CODE></P>
<DT><B>Description</B><DD>
<P>Get a character from the serial port. If no characters are
available, the function will return SER_ERR_NO_DATA, so this is not a fatal
error.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>Other serial functions.</P>
<DT><B>Example</B><DD>
<P>Wait for a character to be available from a serial port.
<PRE>
char ch;
while (ser_get(&amp;ch) == SER_ERR_NO_DATA)
  ;
</PRE>
</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="ser_install"></A> <A NAME="ss3.169">3.169</A> <A HREF="#toc3.169">ser_install</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Install an already loaded driver and return an error code.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#serial.h">serial.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>unsigned char __fastcall__ ser_install (void* driver);</CODE></P>
<DT><B>Description</B><DD>
<P>The function installs a driver that was already loaded into
memory (or linked statically to the program). It returns an error code
(<CODE>SER_ERR_OK</CODE> in case of success).</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only be
used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#ser_load_driver">ser_load_driver</A>,
<A HREF="#ser_uninstall">ser_uninstall</A>,
<A HREF="#ser_unload">ser_unload</A></P>
<DT><B>Example</B><DD>
<P>
<PRE>
ser_install(lynx_comlynx); //Include the driver statically instead of loading it.
</PRE>
</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="ser_ioctl"></A> <A NAME="ss3.170">3.170</A> <A HREF="#toc3.170">ser_ioctl</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Platform dependent code extensions.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#serial.h">serial.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>unsigned __fastcall__ ser_ioctl (unsigned char code, void* data);</CODE></P>
<DT><B>Description</B><DD>
<P>Some platforms have extra serial functions that are not
supported by standard serial driver functions. You can extend the driver to support
this extra functionality bt using ser_ioctl functions.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
<LI>These functions are not easily portable to other cc65 platforms.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>Other serial functions.</P>
<DT><B>Example</B><DD>
<P>None</P>
</DL>
</BLOCKQUOTE>
</P>

<H2><A NAME="ser_load_driver"></A> <A NAME="ss3.171">3.171</A> <A HREF="#toc3.171">ser_load_driver</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Load and install a serial driver.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#serial.h">serial.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>unsigned char __fastcall__ ser_load_driver (const char *name);</CODE></P>
<DT><B>Description</B><DD>
<P>Load and install the driver by name.
Will just load the driver and check if loading was successful.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>Other serial functions.</P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="ser_open"></A> <A NAME="ss3.172">3.172</A> <A HREF="#toc3.172">ser_open</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Open the port by setting the port parameters and enable interrupts</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#serial.h">serial.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>unsigned char __fastcall__ ser_open (const struct ser_params* params);</CODE></P>
<DT><B>Description</B><DD>
<P>Open the port by setting the port parameters and enable interrupts.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>Other serial functions.</P>
<DT><B>Example</B><DD>
<P>
<PRE>
#include &lt;serial.h>

static void initialize(){
  struct ser_params params = {
    SER_BAUD_9600,
    SER_BITS_8,
    SER_STOP_1,
    SER_PAR_MARK,
    SER_HS_NONE
  };
  ser_install(lynx_comlynx); // This will activate the ComLynx
  CLI();
  ser_open(&amp;params);
}
</PRE>
</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="ser_put"></A> <A NAME="ss3.173">3.173</A> <A HREF="#toc3.173">ser_put</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Write a character to a serial port.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#serial.h">serial.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>unsigned char __fastcall__ ser_put (char b);</CODE></P>
<DT><B>Description</B><DD>
<P>Send a character via the serial port. There is a transmit
buffer, but transmitting is not done via interrupt. The function returns
SER_ERR_OVERFLOW if there is no space left in the transmit buffer.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>Other serial functions.</P>
<DT><B>Example</B><DD>
<P>
<PRE>
ser_put('A');
</PRE>
</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="ser_status"></A> <A NAME="ss3.174">3.174</A> <A HREF="#toc3.174">ser_status</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Return the serial port status.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#serial.h">serial.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>unsigned char __fastcall__ ser_status (unsigned char* status);</CODE></P>
<DT><B>Description</B><DD>
<P>Return the serial port status.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>Other serial functions.</P>
<DT><B>Example</B><DD>
<P>None</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="ser_uninstall"></A> <A NAME="ss3.175">3.175</A> <A HREF="#toc3.175">ser_uninstall</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Uninstall the currently loaded driver but do not unload it.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#serial.h">serial.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>unsigned char ser_uninstall (void);</CODE></P>
<DT><B>Description</B><DD>
<P>Uninstall the currently loaded driver but do not unload it.</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>Other serial functions.</P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>

<H2><A NAME="ser_unload"></A> <A NAME="ss3.176">3.176</A> <A HREF="#toc3.176">ser_unload</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Uninstall, then unload the currently loaded driver.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#serial.h">serial.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>unsigned char ser_unload (void);</CODE></P>
<DT><B>Description</B><DD>
<P>Uninstall, then unload the currently loaded driver.</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>Other serial functions.</P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="set_brk"></A> <A NAME="ss3.177">3.177</A> <A HREF="#toc3.177">set_brk</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Set the break vector to a user function.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#6502.h">6502.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ set_brk (brk_handler func);</CODE></P>
<DT><B>Description</B><DD>
<P><CODE>set_brk</CODE> allows a user program to handle breaks within the
program code by letting the vector point to a user written C function. The
runtime library installs a small stub that saves the registers into global
variables that may be accessed (and changed) by the break handler.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
<LI>The stub saves the zero page registers used by the C runtime and switches
to a small break handler stack. This means that it is safe to execute C code,
even if C code was interrupted. Be careful however not to use too many local
variables, and do not enable stack checks for the handler function or any other
function called from it.</LI>
<LI>The <CODE>brk_pc</CODE> variable points to the <CODE>BRK</CODE> instruction. If you want
the continue with the interrupted code, you have to adjust <CODE>brk_pc</CODE>,
otherwise the <CODE>BRK</CODE> instruction will get executed over and over again.</LI>
<LI>Since <CODE>set_brk</CODE> installs an exit handler, it is not strictly necessary
to call <CODE>
<A HREF="#reset_brk">reset_brk</A></CODE> as part of the cleanup when
the program terminates.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#reset_brk">reset_brk</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="set_irq"></A> <A NAME="ss3.178">3.178</A> <A HREF="#toc3.178">set_irq</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Set the C level interrupt request vector to the given address.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#6502.h">6502.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ set_irq (irq_handler f, void *stack_addr, size_t stack_size);</CODE></P>
<DT><B>Description</B><DD>
<P><CODE>set_irq</CODE> allows a user program to handle interrupt requests
(IRQs) within the program code by letting the vector point to a user written C
function. The runtime library installs a small stub that saves the zero page
registers used by the C runtime before calling the handler function and restores
them after the handler function returns. Additionally the stub temporarily switches
the C runtime stack to the stack area provided as parameter. If the handler function
was set up to handle a "private", "exclusive" interrupt request source it must
return the value <CODE>IRQ_HANDLED</CODE> if and only if it has verified that the current
interrupt request actually stems from that source. In all other cases it must return
the value <CODE>IRQ_NOT_HANDLED</CODE>.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
<LI>The stub saves the registers and zero page locations used by the C runtime
and switches to the provided stack area. As a consequence, there is some
runtime overhead, but it it is safe to execute C code, even if other C code
was interrupted. Be careful however not to call C library functions, and do not
enable stack checks for the handler function or any other function called from
it.</LI>
<LI>The interrupt vector is reset on function termination, so it's not
strictly necessary to call <CODE>
<A HREF="#reset_irq">reset_irq</A></CODE> as part
of the cleanup when the program terminates.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#reset_brk">reset_brk</A>,
<A HREF="#reset_irq">reset_irq</A>,
<A HREF="#set_brk">set_brk</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="setjmp"></A> <A NAME="ss3.179">3.179</A> <A HREF="#toc3.179">setjmp</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Save the context for use with <CODE>longjmp</CODE>.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#setjmp.h">setjmp.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>int __fastcall__ setjmp (jmp_buf buf);</CODE></P>
<DT><B>Description</B><DD>
<P>The <CODE>setjmp</CODE> function saves the current context in <CODE>buf</CODE>
for subsequent use by the <CODE>
<A HREF="#longjmp">longjmp</A></CODE> function and
returns zero.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
<LI><CODE>setjmp</CODE> is actually a macro as required by the ISO standard.</LI>
<LI><CODE>setjmp</CODE> will not save the signal context.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>ISO 9899</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#longjmp">longjmp</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="setlocale"></A> <A NAME="ss3.180">3.180</A> <A HREF="#toc3.180">setlocale</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Selects a locale.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#locale.h">locale.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>char* __fastcall__ setlocale (int category, const char* locale);</CODE></P>
<DT><B>Description</B><DD>
<P><CODE>setlocale</CODE> sets or queries the program's locale.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
<LI>cc65 supports only the "C" locale, so calling this function to set a
different locale has no effect.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>ISO 9899</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#localeconv">localeconv</A>,
<A HREF="#strcoll">strcoll</A>
<A HREF="#strxfrm">strxfrm</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="signal"></A> <A NAME="ss3.181">3.181</A> <A HREF="#toc3.181">signal</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Install a signal handler.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#signal.h">signal.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>__sigfunc __fastcall__ signal (int sig, __sigfunc func);</CODE></P>
<DT><B>Description</B><DD>
<P><CODE>signal</CODE> installs a handler for the given signal. The
handler may either be a user supplied function, or one of the predefined
signal handlers <CODE>SIG_IGN</CODE> or <CODE>SIG_DFL</CODE>. The function returns the
previous value if the signal , or the special function vector SIG_ERR in
case of an error.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>ISO 9899</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#abort">abort</A>,
<A HREF="#raise">raise</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="sleep"></A> <A NAME="ss3.182">3.182</A> <A HREF="#toc3.182">sleep</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Sleep for a specified amount of time.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#unistd.h">unistd.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ sleep (unsigned seconds);</CODE></P>
<DT><B>Description</B><DD>
<P>The function will return after the specified number of
seconds have elapsed.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>POSIX 1003.1</P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="slow"></A> <A NAME="ss3.183">3.183</A> <A HREF="#toc3.183">slow</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Switch the C128 into 1MHz mode.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#c128.h">c128.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void slow (void);</CODE></P>
<DT><B>Description</B><DD>
<P>The function will switch the clock of the C128 to 1MHz. This
will halve the speed compared to fast mode.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is specific to the C128.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>C128</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#fast">fast</A>,
<A HREF="#toggle_videomode">toggle_videomode</A>,
<A HREF="#videomode">videomode</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="srand"></A> <A NAME="ss3.184">3.184</A> <A HREF="#toc3.184">srand</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Initialize the pseudo random number generator.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#stdlib.h">stdlib.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ srand (unsigned seed);</CODE></P>
<DT><B>Description</B><DD>
<P>The function initializes the random number generator using
the given seed. On program startup, the generator behaves as if <CODE>srand</CODE> has
been called with an argument of 1.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>ISO 9899</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#_randomize">_randomize</A>,
<A HREF="#rand">rand</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="strcasecmp"></A> <A NAME="ss3.185">3.185</A> <A HREF="#toc3.185">strcasecmp</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Compare two strings case insensitive.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#string.h">string.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>int __fastcall__ strcasecmp (const char* s1, const char* s2);</CODE></P>
<DT><B>Description</B><DD>
<P>The <CODE>strcasecmp</CODE> function compares the two strings passed
as parameters without case sensitivity. It returns a value that is less than
zero if <CODE>s1</CODE> is less than <CODE>s2</CODE>, zero if <CODE>s1</CODE> is the same as <CODE>s2</CODE>,
and a value greater than zero if <CODE>s1</CODE> is greater than <CODE>s2</CODE>.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
<LI>The function is not available in strict ANSI mode.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#strcmp">strcmp</A>,
<A HREF="#strcoll">strcoll</A>,
<A HREF="#stricmp">stricmp</A>,
<A HREF="#strncmp">strncmp</A>,
<A HREF="#strxfrm">strxfrm</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="strcat"></A> <A NAME="ss3.186">3.186</A> <A HREF="#toc3.186">strcat</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Concatentate two strings.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#string.h">string.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>char* __fastcall__ strcat (char* s1, const char* s2);</CODE></P>
<DT><B>Description</B><DD>
<P>The <CODE>strcat</CODE> function appends a copy of the string
pointed to by s2 (including the terminating null byte) to the end of the
string pointed to by s1. The initial byte of s2 overwrites the null byte at
the end of s1.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
<LI>If copying takes place between objects that overlap, the behaviour
is undefined.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>ISO 9899</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#strcpy">strcpy</A>,
<A HREF="#strncat">strncat</A>,
<A HREF="#strncpy">strncpy</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="strchr"></A> <A NAME="ss3.187">3.187</A> <A HREF="#toc3.187">strchr</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Search for a character in a string.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#string.h">string.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>char* __fastcall__ strchr (const char* s, int c);</CODE></P>
<DT><B>Description</B><DD>
<P>The <CODE>strchr</CODE> function locates the first occurrence of <CODE>c</CODE>
(converted to a char) in the string pointed to by <CODE>s</CODE>. The terminating null
byte is considered to be part of the string. Upon completion, the function
returns a pointer to the byte, or a null pointer if the byte was not found.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>ISO 9899</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#memchr">memchr</A>,
<A HREF="#strrchr">strrchr</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="strcmp"></A> <A NAME="ss3.188">3.188</A> <A HREF="#toc3.188">strcmp</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Compare two strings.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#string.h">string.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>int __fastcall__ strcmp (const char* s1, const char* s2);</CODE></P>
<DT><B>Description</B><DD>
<P>The <CODE>strcmp</CODE> function compares the two strings passed as
parameters. It returns a value that is less than zero if <CODE>s1</CODE> is less than
<CODE>s2</CODE>, zero if <CODE>s1</CODE> is the same as <CODE>s2</CODE>, and a value greater than zero
if <CODE>s1</CODE> is greater than <CODE>s2</CODE>.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>ISO 9899</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#strcasecmp">strcasecmp</A>,
<A HREF="#strcoll">strcoll</A>,
<A HREF="#stricmp">stricmp</A>,
<A HREF="#strncmp">strncmp</A>
<A HREF="#strxfrm">strxfrm</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="strcoll"></A> <A NAME="ss3.189">3.189</A> <A HREF="#toc3.189">strcoll</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Compare two strings.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#string.h">string.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>int __fastcall__ strcoll (const char* s1, const char* s2);</CODE></P>
<DT><B>Description</B><DD>
<P>The <CODE>strcoll</CODE> function compares the two strings passed as
parameters, according to the collating sequence set by <CODE>
<A HREF="#setlocale">setlocale</A></CODE>. It returns a value that is less than zero if <CODE>s1</CODE> is
less than <CODE>s2</CODE>, zero if <CODE>s1</CODE> is the same as <CODE>s2</CODE>, and a value greater
than zero if <CODE>s1</CODE> is greater than <CODE>s2</CODE>.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>ISO 9899</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#setlocale">setlocale</A>,
<A HREF="#strcasecmp">strcasecmp</A>,
<A HREF="#strcmp">strcmp</A>,
<A HREF="#stricmp">stricmp</A>,
<A HREF="#strncmp">strncmp</A>,
<A HREF="#strxfrm">strxfrm</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="strcpy"></A> <A NAME="ss3.190">3.190</A> <A HREF="#toc3.190">strcpy</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Copy a string.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#string.h">string.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>char* __fastcall__ strcpy (char* s1, const char* s2);</CODE></P>
<DT><B>Description</B><DD>
<P>The <CODE>strcpy</CODE> function copies the string pointed to by
<CODE>s2</CODE> (including the terminating null byte) into the array pointed to by
<CODE>s1</CODE>. The function will always return <CODE>s1</CODE>.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
<LI>If copying takes place between objects that overlap, the behaviour
is undefined.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>ISO 9899</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#strcat">strcat</A>,
<A HREF="#strncat">strncat</A>,
<A HREF="#strncpy">strncpy</A></P>
<DT><B>Example</B><DD>
<P>
<PRE>
#include &lt;string.h&gt;

static char hello[14];

strcpy (hello, "Hello world!\n");
</PRE>
</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="strcspn"></A> <A NAME="ss3.191">3.191</A> <A HREF="#toc3.191">strcspn</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Compute the length of a substring.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#string.h">string.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>size_t __fastcall__ strcspn (const char* s, const char* set);</CODE></P>
<DT><B>Description</B><DD>
<P>The <CODE>strcspn</CODE> function computes and returns the length of
the substring pointed to by <CODE>s</CODE> which does <EM>not</EM> consist of
characters contained in the string <CODE>set</CODE>.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>ISO 9899</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#strqtok">strqtok</A>,
<A HREF="#strspn">strspn</A>,
<A HREF="#strstr">strstr</A>,
<A HREF="#strtok">strtok</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="strdup"></A> <A NAME="ss3.192">3.192</A> <A HREF="#toc3.192">strdup</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Allocate a copy of a string on the heap.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#string.h">string.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>char* __fastcall__ strdup (const char* s);</CODE></P>
<DT><B>Description</B><DD>
<P><CODE>strdup</CODE> allocates a memory block on the heap, big enough
to hold a copy of <CODE>s</CODE> including the terminating zero. If the allocation
fails, <CODE>NULL</CODE> is returned, otherwise <CODE>s</CODE> is copied into the allocated
memory block, and a pointer to the block is returned.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
<LI>It is up to the caller to free the allocated memory block.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>ISO 9899</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#free">free</A>,
<A HREF="#malloc">malloc</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="strerror"></A> <A NAME="ss3.193">3.193</A> <A HREF="#toc3.193">strerror</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Return a string describing an error code.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#string.h">string.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>char* __fastcall__ strerror (int errcode);</CODE></P>
<DT><B>Description</B><DD>
<P>The <CODE>strerror</CODE> function returns a string describing the
given error code. If an invalid error code is passed, the string "Unknown
error" is returned, and <CODE>errno</CODE> is set to <CODE>EINVAL</CODE>. In all other cases,
<CODE>errno</CODE> is left untouched.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
<LI>While the return type of the function is a <CODE>char*</CODE>, the returned
string must not be modified by the caller!</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>ISO 9899</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#_stroserror">_stroserror</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="stricmp"></A> <A NAME="ss3.194">3.194</A> <A HREF="#toc3.194">stricmp</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Compare two strings case insensitive.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#string.h">string.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>int __fastcall__ stricmp (const char* s1, const char* s2);</CODE></P>
<DT><B>Description</B><DD>
<P>The <CODE>stricmp</CODE> function compares the two strings passed as
parameters without case sensitivity. It returns a value that is less than zero
if <CODE>s1</CODE> is less than <CODE>s2</CODE>, zero if <CODE>s1</CODE> is the same as <CODE>s2</CODE>, and a
value greater than zero if <CODE>s1</CODE> is greater than <CODE>s2</CODE>.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
<LI>The function is not available in strict ANSI mode.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#strcasecmp">strcasecmp</A>,
<A HREF="#strcmp">strcmp</A>,
<A HREF="#strcoll">strcoll</A>,
<A HREF="#strncmp">strncmp</A>,
<A HREF="#strxfrm">strxfrm</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="strlen"></A> <A NAME="ss3.195">3.195</A> <A HREF="#toc3.195">strlen</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Return the length of a string.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#string.h">string.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>size_t __fastcall__ strlen (const char* s);</CODE></P>
<DT><B>Description</B><DD>
<P>The <CODE>strlen</CODE> function computes the number of bytes in the
string to which s points, not including the terminating null byte.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
<LI>When compiling with <CODE>-Os</CODE> (inline known standard functions), the
function does not work correctly for strings with more than 255 characters.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>ISO 9899</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#strcpy">strcpy</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="strlower"></A> <A NAME="ss3.196">3.196</A> <A HREF="#toc3.196">strlower</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Make a string lower case.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#string.h">string.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>char* __fastcall__ strlower (char* s);</CODE></P>
<DT><B>Description</B><DD>
<P>The <CODE>strlower</CODE> function will apply the <CODE>tolower</CODE>
function to each character of a string. The function will always return <CODE>s</CODE>.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
<LI>The function prototype is unavailable when compiling in strict ANSI mode.</LI>
<LI>An alias name for this function is <CODE>strlwr</CODE>.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#strupper">strupper</A>,
<A HREF="#tolower">tolower</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="strlwr"></A> <A NAME="ss3.197">3.197</A> <A HREF="#toc3.197">strlwr</A>
</H2>


<P>
<BLOCKQUOTE>
See <CODE>strlower</CODE>.
</BLOCKQUOTE>
</P>


<H2><A NAME="strncat"></A> <A NAME="ss3.198">3.198</A> <A HREF="#toc3.198">strncat</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Concatentate two strings.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#string.h">string.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>char* __fastcall__ strncat (char* s1, const char* s2, size_t n);</CODE></P>
<DT><B>Description</B><DD>
<P>The <CODE>strncat</CODE> function appends not more than n characters
of the string pointed to by s2 to the end of the string pointed to by s1. The
terminating null character at the end of s1 is overwritten. A terminating null
character is appended to the result, even if not all of s2 is appended to s1.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
<LI>If copying takes place between objects that overlap, the behaviour
is undefined.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>ISO 9899</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#strcpy">strcpy</A>,
<A HREF="#strncat">strncat</A>,
<A HREF="#strncpy">strncpy</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="strncmp"></A> <A NAME="ss3.199">3.199</A> <A HREF="#toc3.199">strncmp</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Compare two strings.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#string.h">string.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>int __fastcall__ strncmp (const char* s1, const char* s2, size_t count);</CODE></P>
<DT><B>Description</B><DD>
<P>The <CODE>strncmp</CODE> function compares not more than <CODE>count</CODE>
characters of the two strings passed as parameters. It returns a value that is
less than zero if the first <CODE>count</CODE> characters of <CODE>s1</CODE> are less than
<CODE>s2</CODE>, zero if they are identical, and a value greater than zero they are
greater.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>ISO 9899</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#strcasecmp">strcasecmp</A>,
<A HREF="#strcmp">strcmp</A>,
<A HREF="#strcoll">strcoll</A>,
<A HREF="#stricmp">stricmp</A>,
<A HREF="#strxfrm">strxfrm</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="strncpy"></A> <A NAME="ss3.200">3.200</A> <A HREF="#toc3.200">strncpy</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Copy part of a string.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#string.h">string.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>char* __fastcall__ strncpy (char* s1, const char* s2, size_t n);</CODE></P>
<DT><B>Description</B><DD>
<P>The <CODE>strncpy</CODE> function copies not more than <CODE>n</CODE> bytes from
the array pointed to by <CODE>s2</CODE> to the array pointed to by <CODE>s1</CODE>. If the array
pointed to by <CODE>s2</CODE> is a string that is shorter than <CODE>n</CODE> bytes, null bytes are
appended to the copy in the array pointed to by <CODE>s1</CODE>, until <CODE>n</CODE> bytes are
written. The function always will return <CODE>s1</CODE>.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is available only as a fastcall function; so, it may be used
only in the presence of a prototype.</LI>
<LI>If there is no null byte in the first <CODE>n</CODE> bytes of the array pointed
to by <CODE>s2</CODE>, the result is <EM>not</EM> null-terminated!</LI>
<LI>If copying takes place between objects that overlap, the behaviour is
undefined.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>ISO 9899</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#memcpy">memcpy</A>,
<A HREF="#strcat">strcat</A>,
<A HREF="#strcpy">strcpy</A>,
<A HREF="#strncat">strncat</A></P>
<DT><B>Example</B><DD>
<P>
<PRE>
#include &lt;string.h>

static char hello[6];

strncpy (hello, "Hello world!\n", sizeof hello - 1)[5] = '\0';
</PRE>
</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="strqtok"></A> <A NAME="ss3.201">3.201</A> <A HREF="#toc3.201">strqtok</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Break a string into tokens.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#string.h">string.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>char* __fastcall__ strqtok (char* s1, const char* s2);</CODE></P>
<DT><B>Description</B><DD>
<P><CODE>strqtok()</CODE> will break the string <CODE>s1</CODE> into a sequence of
tokens, which are delimited by either quotation marks or characters from the
string <CODE>s2</CODE>. Tokens inside quotation marks may contain characters from <CODE>s2</CODE>
(they aren't delimiters there). The first call to <CODE>strqtok()</CODE> will return a
pointer to the first token in the string <CODE>s1</CODE>. The following calls must pass
a <CODE>NULL</CODE> pointer as <CODE>s1</CODE>, in order to get the next token in the string.
Different sets of delimiters may be used for the subsequent calls to <CODE>strqtok()</CODE>.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is available only as a fastcall function; so, it may be used
only in the presence of a prototype.</LI>
<LI><CODE>strqtok()</CODE> will modify the string <CODE>s1</CODE>.</LI>
<LI>The function will forget where it is in the <CODE>s1</CODE> string if it is given
a second <CODE>s1</CODE> string before it finishes the first one.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#strcspn">strcspn</A>,
<A HREF="#strspn">strspn</A>,
<A HREF="#strtok">strtok</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="strrchr"></A> <A NAME="ss3.202">3.202</A> <A HREF="#toc3.202">strrchr</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Search for a character in a string.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#string.h">string.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>char* __fastcall__ strrchr (const char* s, int c);</CODE></P>
<DT><B>Description</B><DD>
<P>The <CODE>strrchr</CODE> function locates the last occurrence of <CODE>c</CODE>
(converted to a char) in the string pointed to by <CODE>s</CODE>. The terminating null
byte is considered to be part of the string. Upon completion, the function
returns a pointer to the byte, or a null pointer if the byte was not found.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>ISO 9899</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#strchr">strchr</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="strspn"></A> <A NAME="ss3.203">3.203</A> <A HREF="#toc3.203">strspn</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Compute the length of a substring.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#string.h">string.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>size_t __fastcall__ strspn (const char* s, const char* set);</CODE></P>
<DT><B>Description</B><DD>
<P>The <CODE>strspn</CODE> function computes and returns the length of
the substring pointed to by <CODE>s</CODE> which does consist only of characters
contained in the string <CODE>set</CODE>.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>ISO 9899</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#strcspn">strcspn</A>,
<A HREF="#strstr">strstr</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="strstr"></A> <A NAME="ss3.204">3.204</A> <A HREF="#toc3.204">strstr</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Find a substring.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#string.h">string.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>char* __fastcall__ strstr (const char* str, const char* substr);</CODE></P>
<DT><B>Description</B><DD>
<P><CODE>strstr</CODE> searches for the first occurance of the string
<CODE>substr</CODE> within <CODE>str</CODE>. If found, it returns a pointer to the copy,
otherwise it returns <CODE>NULL</CODE>.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>ISO 9899</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#strcspn">strcspn</A>,
<A HREF="#strspn">strspn</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="strtok"></A> <A NAME="ss3.205">3.205</A> <A HREF="#toc3.205">strtok</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Break a string into tokens.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#string.h">string.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>char* __fastcall__ strtok (char* s1, const char* s2);</CODE></P>
<DT><B>Description</B><DD>
<P><CODE>strtok()</CODE> will break the string <CODE>s1</CODE> into a sequence of
tokens, which are delimited by characters from the string <CODE>s2</CODE>. The first call
to <CODE>strtok()</CODE> will return a pointer to the first token in the string <CODE>s1</CODE>.
The following calls must pass a <CODE>NULL</CODE> pointer as <CODE>s1</CODE>, in order to get
the next token in the string. Different sets of delimiters may be used for the
subsequent calls to <CODE>strtok()</CODE>.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
<LI><CODE>strtok()</CODE> will modify the string <CODE>s1</CODE>.</LI>
<LI>The function will forget where it is in the <CODE>s1</CODE> string if it is given
a second <CODE>s1</CODE> string before it finishes the first one.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>ISO 9899</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#strcspn">strcspn</A>,
<A HREF="#strqtok">strqtok</A>,
<A HREF="#strspn">strspn</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="strxfrm"></A> <A NAME="ss3.206">3.206</A> <A HREF="#toc3.206">strxfrm</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Transform a string.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#string.h">string.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>size_t __fastcall__ strxfrm (char* s1, const char* s2, size_t n);</CODE></P>
<DT><B>Description</B><DD>
<P>The <CODE>strxfrm</CODE> function transforms the string pointed to by
s2 and places the resulting string into the string pointed to by s1. The
transformation is such that if the <CODE>strcmp</CODE> function is applied to two
transformed strings, it returns a value greater than, equal to, or less than
zero, corresponding to the result of the <CODE>strcoll</CODE> function applied to the
same two original strings. No more than n characters are placed into the
resulting array pointed to by s1, including the terminating null character.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI><CODE>s1</CODE> and <CODE>s2</CODE> must not point to the same memory area, otherwise
the behaviour is undefined.</LI>
<LI>If <CODE>n</CODE> is zero, <CODE>s1</CODE> may be a NULL pointer.</LI>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
<LI>Since cc65 doesn't support different charcter sets, <CODE>strxfrm</CODE> will
just copy s2 to s1 using <CODE>
<A HREF="#strncpy">strncpy</A></CODE>.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>ISO 9899</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#strcmp">strcmp</A>,
<A HREF="#strcoll">strcoll</A>,
<A HREF="#strncpy">strncpy</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="strupper"></A> <A NAME="ss3.207">3.207</A> <A HREF="#toc3.207">strupper</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Make a string upper case.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#string.h">string.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>char* __fastcall__ strupper (char* s);</CODE></P>
<DT><B>Description</B><DD>
<P>The <CODE>strupper</CODE> function will apply the <CODE>toupper</CODE>
function to each character of a string. The function will always return <CODE>s</CODE>.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
<LI>The function prototype is unavailable when compiling in strict ANSI mode.</LI>
<LI>An alias name for this function is <CODE>strupr</CODE>.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#strlower">strlower</A>
<A HREF="#toupper">toupper</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="strupr"></A> <A NAME="ss3.208">3.208</A> <A HREF="#toc3.208">strupr</A>
</H2>


<P>
<BLOCKQUOTE>
See <CODE>strupper</CODE>.
</BLOCKQUOTE>
</P>


<H2><A NAME="telldir"></A> <A NAME="ss3.209">3.209</A> <A HREF="#toc3.209">telldir</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Return the current position of a directory stream.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#dirent.h">dirent.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>long __fastcall__ telldir (DIR* dir);</CODE></P>
<DT><B>Description</B><DD>
<P><CODE>telldir</CODE> returns the current position of a directory
stream. The return value may be used in subsequent calls to
<CODE>
<A HREF="#seekdir">seekdir</A></CODE>.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>POSIX 1003.1</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#seekdir">seekdir</A>,
<A HREF="#telldir">telldir</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="textcolor"></A> <A NAME="ss3.210">3.210</A> <A HREF="#toc3.210">textcolor</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Set the text color.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#conio.h">conio.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>unsigned char __fastcall__ textcolor (unsigned char color);</CODE></P>
<DT><B>Description</B><DD>
<P>The function will set a new text color. It returns the old
(current) text color. Text output using any <CODE>conio.h</CODE> function will use
the color set by this function.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>Text colors are system dependent. The function may have no effect
on systems where the text color cannot be changed.</LI>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#bgcolor">bgcolor</A>,
<A HREF="#bordercolor">bordercolor</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="tgi_arc"></A> <A NAME="ss3.211">3.211</A> <A HREF="#toc3.211">tgi_arc</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Draw an elliptic arc in the current color.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#tgi.h">tgi.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ tgi_arc (int x, int y,
unsigned char rx, unsigned char ry, unsigned sa, unsigned ea);</CODE></P>
<DT><B>Description</B><DD>
<P>The function draws an elliptic arc with center at x/y and
radii rx/ry using the current drawing color. The arc covers the angle
between sa and ea (startangle and endangle), which must be in the range
0..360.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
<LI>The function behaves unexpectedly or may crash if the angles are out
of range.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#tgi_bar">tgi_bar</A>,
<A HREF="#tgi_circle">tgi_circle</A>,
<A HREF="#tgi_ellipse">tgi_ellipse</A>,
<A HREF="#tgi_pieslice">tgi_pieslice</A>,
<A HREF="#tgi_setcolor">tgi_setcolor</A></P>
<DT><B>Example</B><DD>
<P>
<PRE>
/* Draw the upper half of an ellipse */
tgi_setcolor(TGI_COLOR_BLUE);
tgi_arc (50, 50, 40, 20, 0, 180);
</PRE>
</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="tgi_bar"></A> <A NAME="ss3.212">3.212</A> <A HREF="#toc3.212">tgi_bar</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>The function fills a rectangle on the drawpage with the current
color.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#tgi.h">tgi.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ tgi_bar (int x1, int y1, int x2, int y2);</CODE></P>
<DT><B>Description</B><DD>
<P>The function fills a rectangle on the drawpage with the current
color.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>Other tgi function</P>
<DT><B>Example</B><DD>
<P>
<PRE>
tgi_setcolor(TGI_COLOR_GREEN);
tgi_bar(10, 10, 100, 60);
</PRE>
</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="tgi_circle"></A> <A NAME="ss3.213">3.213</A> <A HREF="#toc3.213">tgi_circle</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>The function draws a circle in the current color.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#tgi.h">tgi.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ tgi_circle (int x, int y, unsigned char radius);</CODE></P>
<DT><B>Description</B><DD>
<P>The function draws a circle in the current color.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#tgi_arc">tgi_arc</A>,
<A HREF="#tgi_bar">tgi_bar</A>,
<A HREF="#tgi_ellipse">tgi_ellipse</A>,
<A HREF="#tgi_pieslice">tgi_pieslice</A>,
<A HREF="#tgi_setcolor">tgi_setcolor</A></P>
<DT><B>Example</B><DD>
<P>
<PRE>
tgi_setcolor(TGI_COLOR_BLACK);
tgi_circle(50, 40, 40);
</PRE>
</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="tgi_clear"></A> <A NAME="ss3.214">3.214</A> <A HREF="#toc3.214">tgi_clear</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Clear the drawpage</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#tgi.h">tgi.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void tgi_clear (void);</CODE></P>
<DT><B>Description</B><DD>
<P>Clear the drawpage</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>Other tgi functions</P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="tgi_done"></A> <A NAME="ss3.215">3.215</A> <A HREF="#toc3.215">tgi_done</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>End graphics mode, switch back to text mode.
Will NOT uninstall or unload the driver!</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#tgi.h">tgi.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void tgi_done (void);</CODE></P>
<DT><B>Description</B><DD>
<P>End graphics mode, switch back to text mode.
Will NOT uninstall or unload the driver!</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>Other tgi functions</P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="tgi_ellipse"></A> <A NAME="ss3.216">3.216</A> <A HREF="#toc3.216">tgi_ellipse</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>The function draws an ellipse in the current color.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#tgi.h">tgi.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ tgi_ellipse (int x, int y, unsigned char rx, unsigned char ry);</CODE></P>
<DT><B>Description</B><DD>
<P>The function draws an ellipse at position x/y with radii
rx and ry, using the current drawing color.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#tgi_arc">tgi_arc</A>,
<A HREF="#tgi_bar">tgi_bar</A>,
<A HREF="#tgi_circle">tgi_circle</A>,
<A HREF="#tgi_pieslice">tgi_pieslice</A>,
<A HREF="#tgi_setcolor">tgi_setcolor</A></P>
<DT><B>Example</B><DD>
<P>
<PRE>
tgi_setcolor(TGI_COLOR_RED);
tgi_ellipse (50, 40, 40, 20);
</PRE>
</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="tgi_free_vectorfont"></A> <A NAME="ss3.217">3.217</A> <A HREF="#toc3.217">tgi_free_vectorfont</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Free a vector font that was previously loaded into memory.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#tgi.h">tgi.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ tgi_free_vectorfont (const tgi_vectorfont* font);</CODE></P>
<DT><B>Description</B><DD>
<P>Free a vector font that was previously loaded into memory.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#tgi_load_vectorfont">tgi_load_vectorfont</A>,
<A HREF="#tgi_install_vectorfont">tgi_install_vectorfont</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="tgi_getaspectratio"></A> <A NAME="ss3.218">3.218</A> <A HREF="#toc3.218">tgi_getaspectratio</A>
</H2>


<P>
<BLOCKQUOTE>
 
<DL>
<DT><B>Function</B><DD>
<P>Return the pixel aspect ratio.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#tgi.h">tgi.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>unsigned tgi_getaspectratio (void);</CODE></P>
<DT><B>Description</B><DD>
<P>The function returns the pixel aspect ratio for the current
driver and display as an 8.8 fixed point value. It may be used to correct
geometric shapes so they look correct on the display. As an example, a circle
with a radius of 100 pixels may look elliptic on some driver/display
combinations if the aspect ratio is not 1.00.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The aspect ratio is encoded in the TGI driver which assumes a "standard"
monitor for the given platform. The aspect ratio may be wrong if another
monitor is used.</LI>
<LI>No TGI function will use the aspect ratio. It is up to the programmer to
make use of it.</LI>
<LI>The 
<A HREF="#tgi_setaspectratio">tgi_setaspectratio</A> function can
be used to change the aspect ratio for a loaded driver. The value is not reset
by 
<A HREF="#tgi_init">tgi_init</A>, so if a driver is linked statically to
an application, switching into and out of graphics mode will not restore the
original aspect ratio.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#tgi_setaspectratio">tgi_setaspectratio</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="tgi_getcolor"></A> <A NAME="ss3.219">3.219</A> <A HREF="#toc3.219">tgi_getcolor</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Return the current drawing color.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#tgi.h">tgi.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>unsigned char tgi_getcolor (void);</CODE></P>
<DT><B>Description</B><DD>
<P>The actual color is an index to a palette. During tgi_init
you will get a default palette. The number of colors depend on the platform.
All platforms recognize at least TGI_COLOR_BLACK and TGI_COLOR_WHITE. But some
platforms have many more predefined colors. If you paint using TGI_COLOR_GREEN
and then you change the green of the palette to blue using tgi_setpalette then
after this painting in TGI_COLOR_GREEN will actually be blue.</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>Other tgi functions</P>
<DT><B>Example</B><DD>
<P>
<PRE>
color = tgi_getcolor();
</PRE>
</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="tgi_getcolorcount"></A> <A NAME="ss3.220">3.220</A> <A HREF="#toc3.220">tgi_getcolorcount</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Get the number of available colors.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#tgi.h">tgi.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>unsigned char tgi_getcolorcount (void);</CODE></P>
<DT><B>Description</B><DD>
<P>Tgi platforms use indexed color palettes. This function
returns the number of entries we can use in the palette.</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>Other tgi functions</P>
<DT><B>Example</B><DD>
<P>
<PRE>
if (tgi_getcolorcount() == 2) {
  printf("Only monochrome graphics is supported\n");
}
</PRE>
</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="tgi_getdefpalette"></A> <A NAME="ss3.221">3.221</A> <A HREF="#toc3.221">tgi_getdefpalette</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Get the palette installed by default.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#tgi.h">tgi.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>const unsigned char* tgi_getdefpalette (void);</CODE></P>
<DT><B>Description</B><DD>
<P>The tgi driver has a default palette that is active at startup.
The named colors TGI_COLOR_BLACK, TGI_COLOR_WHITE, TGI_COLOR_RED... need this
palette to work correctly.</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>Other tgi functions</P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="tgi_geterror"></A> <A NAME="ss3.222">3.222</A> <A HREF="#toc3.222">tgi_geterror</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Return the error code for the last operation.
This will also clear the error.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#tgi.h">tgi.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>unsigned char tgi_geterror (void);</CODE></P>
<DT><B>Description</B><DD>
<P>Return the error code for the last operation.
This will also clear the error.</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>Other tgi functions</P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="tgi_geterrormsg"></A> <A NAME="ss3.223">3.223</A> <A HREF="#toc3.223">tgi_geterrormsg</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Get an error message describing the error.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#tgi.h">tgi.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>const char* __fastcall__ tgi_geterrormsg (unsigned char code);</CODE></P>
<DT><B>Description</B><DD>
<P>Get an error message describing the error.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>Other tgi functions</P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="tgi_getmaxcolor"></A> <A NAME="ss3.224">3.224</A> <A HREF="#toc3.224">tgi_getmaxcolor</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Get the highest index of the palette.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#tgi.h">tgi.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>unsigned char tgi_getmaxcolor (void);</CODE></P>
<DT><B>Description</B><DD>
<P>Get the highest index of the palette.</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>Other tgi functions</P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="tgi_getmaxx"></A> <A NAME="ss3.225">3.225</A> <A HREF="#toc3.225">tgi_getmaxx</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Get the maximum x coordinate that can be used on this screen.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#tgi.h">tgi.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>unsigned tgi_getmaxx (void);</CODE></P>
<DT><B>Description</B><DD>
<P>Get the maximum x coordinate that can be used on this screen.</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>Other tgi functions</P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="tgi_getmaxy"></A> <A NAME="ss3.226">3.226</A> <A HREF="#toc3.226">tgi_getmaxy</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Get the maximum y coordinate that can be used on this screen.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#tgi.h">tgi.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>unsigned tgi_getmaxy (void);</CODE></P>
<DT><B>Description</B><DD>
<P>Get the maximum y coordinate that can be used on this screen.</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>Other tgi functions</P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="tgi_getpagecount"></A> <A NAME="ss3.227">3.227</A> <A HREF="#toc3.227">tgi_getpagecount</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Return the number of screen pages available.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#tgi.h">tgi.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>unsigned tgi_getpagecount (void);</CODE></P>
<DT><B>Description</B><DD>
<P>Return the number of screen pages available.</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#tgi_setdrawpage">tgi_setdrawpage</A>,
<A HREF="#tgi_setviewpage">tgi_setviewpage</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="tgi_getpalette"></A> <A NAME="ss3.228">3.228</A> <A HREF="#toc3.228">tgi_getpalette</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Get the palette installed.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#tgi.h">tgi.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>const unsigned char* tgi_getpalette (void);</CODE></P>
<DT><B>Description</B><DD>
<P>Get the palette installed.</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>Other tgi functions</P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="tgi_getpixel"></A> <A NAME="ss3.229">3.229</A> <A HREF="#toc3.229">tgi_getpixel</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Get the color of a pixel from the viewpage.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#tgi.h">tgi.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>unsigned char __fastcall__ tgi_getpixel (int x, int y);</CODE></P>
<DT><B>Description</B><DD>
<P>Get the color of a pixel from the viewpage.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>Other tgi functions.</P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="tgi_getxres"></A> <A NAME="ss3.230">3.230</A> <A HREF="#toc3.230">tgi_getxres</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Get number of horisontal pixels on the screen.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#tgi.h">tgi.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>unsigned tgi_getxres (void);</CODE></P>
<DT><B>Description</B><DD>
<P>Get number of horisontal pixels on the screen.
This is same as tgi_maxx()+1.</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>Other tgi functions.</P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="tgi_getyres"></A> <A NAME="ss3.231">3.231</A> <A HREF="#toc3.231">tgi_getyres</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Get number of vertical pixels on the screen.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#tgi.h">tgi.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>unsigned tgi_getyres (void);</CODE></P>
<DT><B>Description</B><DD>
<P>Get number of vertical pixels on the screen.
This is same as tgi_maxy()+1.</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>Other tgi functions.</P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="tgi_gotoxy"></A> <A NAME="ss3.232">3.232</A> <A HREF="#toc3.232">tgi_gotoxy</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Set graphics cursor at x, y.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#tgi.h">tgi.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ tgi_gotoxy (int x, int y);</CODE></P>
<DT><B>Description</B><DD>
<P>Set graphics cursor at x, y.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>Other tgi functions.</P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="tgi_init"></A> <A NAME="ss3.233">3.233</A> <A HREF="#toc3.233">tgi_init</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Initialize the already loaded graphics driver.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#tgi.h">tgi.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void tgi_init (void);</CODE></P>
<DT><B>Description</B><DD>
<P>The tgi_init function will set the default palette to the
hardware.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI><CODE>tgi_init</CODE> will not clear the screen. This allows switching between
text and graphics mode on platforms that have separate memory areas for the
screens. If you want the screen cleared, call <CODE>
<A HREF="#tgi_clear">tgi_clear</A></CODE> after <CODE>tgi_init</CODE>.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>Other tgi functions.</P>
<DT><B>Example</B><DD>
<P>
<PRE>
tgi_install(tgi_static_stddrv); //Include the driver statically instead of loading it.
tgi_init(); //Set up the default palette and clear the screen.
</PRE>
</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="tgi_install"></A> <A NAME="ss3.234">3.234</A> <A HREF="#toc3.234">tgi_install</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Install an already loaded driver and return an error code.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#tgi.h">tgi.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>unsigned char __fastcall__ tgi_install (void* driver);</CODE></P>
<DT><B>Description</B><DD>
<P>The function installs a driver that was already loaded into
memory (or linked statically to the program). It returns an error code
(<CODE>TGI_ERR_OK</CODE> in case of success).</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only be
used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#tgi_load_driver">tgi_load_driver</A>,
<A HREF="#tgi_uninstall">tgi_uninstall</A>,
<A HREF="#tgi_unload">tgi_unload</A></P>
<DT><B>Example</B><DD>
<P>
<PRE>
tgi_install(tgi_static_stddrv); //Include the driver statically instead of loading it.
tgi_init(); //Set up the default palette and clear the screen.
</PRE>
</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="tgi_install_vectorfont"></A> <A NAME="ss3.235">3.235</A> <A HREF="#toc3.235">tgi_install_vectorfont</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Install an already loaded driver and return an error code.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#tgi.h">tgi.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ tgi_install_vectorfont (const tgi_vectorfont* font);</CODE></P>
<DT><B>Description</B><DD>
<P>Install a vector font for use. More than one vector font can be loaded,
but only one can be active. This function is used to tell which one. Call
with a NULL pointer to uninstall the currently installed font.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only be
used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#tgi_load_vectorfont">tgi_load_vectorfont</A>,
<A HREF="#tgi_free_vectorfont">tgi_free_vectorfont</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="tgi_ioctl"></A> <A NAME="ss3.236">3.236</A> <A HREF="#toc3.236">tgi_ioctl</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Platform dependent code extensions.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#tgi.h">tgi.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>unsigned __fastcall__ tgi_ioctl (unsigned char code, void* data);</CODE></P>
<DT><B>Description</B><DD>
<P>Some platforms have extra display hardware that is not
supported by standard tgi functions. You can extend the driver to support
this extra hardware using tgi_ioctl functions.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
<LI>These functions are not easily portable to other cc65 platforms.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>Other tgi functions.</P>
<DT><B>Example</B><DD>
<P>
<PRE>
#define tgi_sprite(spr) tgi_ioctl(0, (void*)(spr))
#define tgi_flip() tgi_ioctl(1, (void*)0)
#define tgi_setbgcolor(bgcol) tgi_ioctl(2, (void*)(bgcol))
#define tgi_setframerate(rate) tgi_ioctl(3, (void*)(rate))
#define tgi_busy() tgi_ioctl(4, (void*)0)
#define tgi_updatedisplay() tgi_ioctl(4, (void*)1)
if (!tgi_busy()) {
  tgi_sprite(&amp;background);
  tgi_setcolor(TGI_COLOR_BLUE);
  tgi_outttextxy(20,40,"Hello World");
  tgi_updatedisplay();
}
</PRE>
</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="tgi_line"></A> <A NAME="ss3.237">3.237</A> <A HREF="#toc3.237">tgi_line</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Draw a line in the current drawing color.
The graphics cursor will be set to x2/y2 by this call.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#tgi.h">tgi.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ tgi_line (int x1, int y1, int x2, int y2);</CODE></P>
<DT><B>Description</B><DD>
<P>Draw a line in the current drawing color.
The graphics cursor will be set to x2/y2 by this call.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>Other tgi functions.</P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="tgi_lineto"></A> <A NAME="ss3.238">3.238</A> <A HREF="#toc3.238">tgi_lineto</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Draw a line in the current drawing color from the graphics
cursor to the new end point. The graphics cursor will be updated to x2/y2.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#tgi.h">tgi.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ tgi_lineto (int x2, int y2);</CODE></P>
<DT><B>Description</B><DD>
<P>Draw a line in the current drawing color from the graphics
cursor to the new end point. The graphics cursor will be updated to x2/y2.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>Other tgi functions.</P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="tgi_load_driver"></A> <A NAME="ss3.239">3.239</A> <A HREF="#toc3.239">tgi_load_driver</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Load and install the given driver.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#tgi.h">tgi.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ tgi_load_driver (const char *name);</CODE></P>
<DT><B>Description</B><DD>
<P>Load and install the driver by name.
Will just load the driver and check if loading was successful.
Will not switch to graphics mode.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>Other tgi functions.</P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="tgi_load_vectorfont"></A> <A NAME="ss3.240">3.240</A> <A HREF="#toc3.240">tgi_load_vectorfont</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Load the given vector font.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#tgi.h">tgi.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>const tgi_vectorfont* __fastcall__ tgi_load_vectorfont (const char* name);</CODE></P>
<DT><B>Description</B><DD>
<P>Load a vector font into memory and return it. In case of errors, NULL is
returned and an error is set, which can be retrieved using tgi_geterror.
To use the font, it has to be installed using tgi_install_vectorfont.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#tgi_install_vectorfont">tgi_install_vectorfont</A>,
<A HREF="#tgi_free_vectorfont">tgi_free_vectorfont</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="tgi_outtext"></A> <A NAME="ss3.241">3.241</A> <A HREF="#toc3.241">tgi_outtext</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Output text at the current graphics cursor position.
The graphics cursor is moved to the end of the text.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#tgi.h">tgi.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ tgi_outtext (const char* s);</CODE></P>
<DT><B>Description</B><DD>
<P>Output text at the current graphics cursor position.
The graphics cursor is moved to the end of the text.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>Other tgi functions.</P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="tgi_outtextxy"></A> <A NAME="ss3.242">3.242</A> <A HREF="#toc3.242">tgi_outtextxy</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Output text at the given cursor position.
The graphics cursor is moved to the end of the text.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#tgi.h">tgi.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ tgi_outtextxy (int x, int y, const char* s);</CODE></P>
<DT><B>Description</B><DD>
<P>Output text at the given cursor position.
The graphics cursor is moved to the end of the text.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>Other tgi functions.</P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="tgi_pieslice"></A> <A NAME="ss3.243">3.243</A> <A HREF="#toc3.243">tgi_pieslice</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Draw an elliptic pie slice in the current color.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#tgi.h">tgi.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ tgi_pie slice (int x, int y,
unsigned char rx, unsigned char ry, unsigned sa, unsigned ea);</CODE></P>
<DT><B>Description</B><DD>
<P>The function draws an elliptic pie slice with center at x/y
and radii rx/ry using the current drawing color. The pie slice covers the angle
between sa and ea (startangle and endangle), which must be in the range
0..360.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
<LI>The function behaves unexpectedly or may crash if the angles are out
of range.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#tgi_bar">tgi_arc</A>,
<A HREF="#tgi_bar">tgi_bar</A>,
<A HREF="#tgi_circle">tgi_circle</A>,
<A HREF="#tgi_ellipse">tgi_ellipse</A>,
<A HREF="#tgi_setcolor">tgi_setcolor</A></P>
<DT><B>Example</B><DD>
<P>
<PRE>
/* Draw the closed upper half of an ellipse */
tgi_setcolor(TGI_COLOR_BLUE);
tgi_pieslice (50, 50, 40, 20, 0, 180);
</PRE>
</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="tgi_setaspectratio"></A> <A NAME="ss3.244">3.244</A> <A HREF="#toc3.244">tgi_setaspectratio</A>
</H2>


<P>
<BLOCKQUOTE>
 
<DL>
<DT><B>Function</B><DD>
<P>Set the pixel aspect ratio.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#tgi.h">tgi.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ tgi_setaspectratio (unsigned ratio);</CODE></P>
<DT><B>Description</B><DD>
<P>The function sets the pixel aspect ratio for the current
driver and display. The argument is an 8.8 fixed point value. The aspect ratio
may be used to correct geometric shapes so they look correct on a given
display. As an example, a circle with a radius of 100 pixels may look elliptic
on some driver/display combinations if the aspect ratio is not 1.00.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The aspect ratio is encoded in the TGI driver which assumes a "standard"
monitor for the given platform. The aspect ratio may be wrong if another
monitor is used.</LI>
<LI>No TGI function will use the aspect ratio. It is up to the programmer to
make use of it.</LI>
<LI>The <CODE>tgi_setaspectratio</CODE> function can be used to change the aspect
ratio for a loaded driver. The value is not reset by 
<A HREF="#tgi_init">tgi_init</A>, so if a driver is linked statically to an application,
switching into and out of graphics mode will not restore the original aspect
ratio.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#tgi_getaspectratio">tgi_getaspectratio</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="tgi_setcolor"></A> <A NAME="ss3.245">3.245</A> <A HREF="#toc3.245">tgi_setcolor</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Set color to be used in future draw operations.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#tgi.h">tgi.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ tgi_setcolor (unsigned char color);</CODE></P>
<DT><B>Description</B><DD>
<P>Set color to be used in future draw operations.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>Other tgi functions.</P>
<DT><B>Example</B><DD>
<P>
<PRE>
tgi_setcolor(TGI_COLOR_BLACK);
tgi_bar(0,0,30,30);
tgi_setcolor(TGI_COLOR_WHITE);
tgi_bar(10,10,20,20);
</PRE>
</P>
</DL>
</BLOCKQUOTE>
</P>

<H2><A NAME="tgi_setdrawpage"></A> <A NAME="ss3.246">3.246</A> <A HREF="#toc3.246">tgi_setdrawpage</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Set the page for drawing.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#tgi.h">tgi.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ tgi_setdrawpage (unsigned char page);</CODE></P>
<DT><B>Description</B><DD>
<P>If the drawpage and the viewpage are the same then all drawing
is seen immediately as it is drawn. For double buffered games you can set the
drawpage to a different page than the viewpage. This lets you draw the next
screen in the background and when the screen is ready you display it.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>Other tgi functions.</P>
<DT><B>Example</B><DD>
<P>
<PRE>
tgi_setdrawpage(1);
tgi_outtextxy(10, 10, "Hello World");
tgi_setviewpage(1); // Show page 1
tgi_setdrawpage(0);
tgi_outtextxy(10, 10, "Creating next frame");
...
tgi_setviewpage(0); // Show page 0
</PRE>
</P>
</DL>
</BLOCKQUOTE>
</P>

<H2><A NAME="tgi_setpalette"></A> <A NAME="ss3.247">3.247</A> <A HREF="#toc3.247">tgi_setpalette</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Set the palette (not available with all drivers/hardware).
Palette is a pointer to as many entries as there are colors.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#tgi.h">tgi.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ tgi_setpalette (const unsigned char* palette);</CODE></P>
<DT><B>Description</B><DD>
<P>Set the palette (not available with all drivers/hardware).
Palette is a pointer to as many entries as there are colors.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>Other tgi functions.</P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>

<H2><A NAME="tgi_setpixel"></A> <A NAME="ss3.248">3.248</A> <A HREF="#toc3.248">tgi_setpixel</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Plot a pixel on the drawpage with the current color.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#tgi.h">tgi.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ tgi_setpixel (int x, int y);</CODE></P>
<DT><B>Description</B><DD>
<P>Plot a pixel on the drawpage with the current color.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>Other tgi functions.</P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>

<H2><A NAME="tgi_setviewpage"></A> <A NAME="ss3.249">3.249</A> <A HREF="#toc3.249">tgi_setviewpage</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Set page to be visible on screen.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#tgi.h">tgi.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ tgi_setviewpage (unsigned char page);</CODE></P>
<DT><B>Description</B><DD>
<P>If the drawpage and the viewpage are the same then all drawing
is seen immediately as it is drawn. For double buffered games you can set the
drawpage to a different page than the viewpage. This lets you draw the next
screen in the background and when the screen is ready you display it.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>Other tgi functions.</P>
<DT><B>Example</B><DD>
<P>
<PRE>
tgi_setdrawpage(1);
tgi_outtextxy(10, 10, "Hello World");
tgi_setviewpage(1); // Show page 1
tgi_setdrawpage(0);
tgi_outtextxy(10, 10, "Creating next frame");
...
tgi_setviewpage(0); // Show page 0
</PRE>
</P>
</DL>
</BLOCKQUOTE>
</P>

<H2><A NAME="tgi_gettextheight"></A> <A NAME="ss3.250">3.250</A> <A HREF="#toc3.250">tgi_gettextheight</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Calculate the height of the text in pixels according to
the current text style.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#tgi.h">tgi.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>unsigned __fastcall__ tgi_gettextheight (const char* s);</CODE></P>
<DT><B>Description</B><DD>
<P>Calculate the height of the text in pixels according to
the current text style.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>Other tgi functions.</P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>

<H2><A NAME="tgi_settextscale"></A> <A NAME="ss3.251">3.251</A> <A HREF="#toc3.251">tgi_settextscale</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Set the scaling for text output.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#tgi.h">tgi.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ tgi_settextscale (unsigned width, unsigned height);</CODE></P>
<DT><B>Description</B><DD>
<P>Set the scaling for text output. The scaling factors for width and height
are 8.8 fixed point values. This means that $100 = 1 $200 = 2 etc.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#tgi_settextstyle">tgi_settextstyle</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>

<H2><A NAME="tgi_settextstyle"></A> <A NAME="ss3.252">3.252</A> <A HREF="#toc3.252">tgi_settextstyle</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Set the style for text output.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#tgi.h">tgi.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ tgi_settextstyle (unsigned char magx, unsigned char magy, unsigned char dir, unsigned char font);</CODE></P>
<DT><B>Description</B><DD>
<P>Set the style for text output.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#tgi_settextscale">tgi_settextscale</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>

<H2><A NAME="tgi_gettextwidth"></A> <A NAME="ss3.253">3.253</A> <A HREF="#toc3.253">tgi_gettextwidth</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Calculate the width of the text in pixels according to the current text style.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#tgi.h">tgi.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>unsigned __fastcall__ tgi_gettextwidth (const char* s);</CODE></P>
<DT><B>Description</B><DD>
<P>Calculate the width of the text in pixels according to the current text style.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>Other tgi functions.</P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>

<H2><A NAME="tgi_uninstall"></A> <A NAME="ss3.254">3.254</A> <A HREF="#toc3.254">tgi_uninstall</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Uninstall the currently loaded driver but do not unload it.
Will call tgi_done if necessary.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#tgi.h">tgi.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void tgi_uninstall (void);</CODE></P>
<DT><B>Description</B><DD>
<P>Uninstall the currently loaded driver but do not unload it.
Will call tgi_done if necessary.</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>Other tgi functions.</P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>

<H2><A NAME="tgi_unload"></A> <A NAME="ss3.255">3.255</A> <A HREF="#toc3.255">tgi_unload</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Uninstall, then unload the currently loaded driver.
Will call tgi_done if necessary.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#tgi.h">tgi.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void tgi_unload (void);</CODE></P>
<DT><B>Description</B><DD>
<P>Uninstall, then unload the currently loaded driver.
Will call tgi_done if necessary.</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>Other tgi functions.</P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>

<H2><A NAME="time"></A> <A NAME="ss3.256">3.256</A> <A HREF="#toc3.256">time</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Get the time.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#time.h">time.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>time_t __fastcall__ time (time_t* t);</CODE></P>
<DT><B>Description</B><DD>
<P>The function returns the time since the 1970-01-01 00:00:00
measured in seconds. If the pointer <CODE>t</CODE> is not <CODE>NULL</CODE>, the function
result will also be stored there. If no time is available, <CODE>(time_t)-1</CODE> is
returned and <CODE>errno</CODE> is set to <CODE>ENOSYS</CODE>.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may
only be used in presence of a prototype.</LI>
<LI>Many platforms supported by cc65 do not have a realtime clock, so the
returned value may not be valid.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>ISO 9899</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#clock">clock</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="toggle_videomode"></A> <A NAME="ss3.257">3.257</A> <A HREF="#toc3.257">toggle_videomode</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Toggle between 40 and 80 column mode.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#c128.h">c128.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void toggle_videomode (void);</CODE></P>
<DT><B>Description</B><DD>
<P>Toggle between 40 and 80 column mode. The settings for the
old mode (cursor position, color and so on) are saved and restored together
with the mode.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is specific to the C128.</LI>
<LI>This function is deprecated. Please use 
<A HREF="#videomode">videomode</A> instead!</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>C128</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#fast">fast</A>,
<A HREF="#slow">slow</A>,
<A HREF="#videomode">videomode</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="tolower"></A> <A NAME="ss3.258">3.258</A> <A HREF="#toc3.258">tolower</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Convert a character into its lower case representation.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#ctype.h">ctype.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>int __fastcall__ tolower (int c);</CODE></P>
<DT><B>Description</B><DD>
<P>The function returns the given character converted to lower
case. If the given character is not a letter, it is returned unchanged.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may
only be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>ISO 9899</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#islower">islower</A>,
<A HREF="#isupper">isupper</A>,
<A HREF="#toupper">toupper</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="toupper"></A> <A NAME="ss3.259">3.259</A> <A HREF="#toc3.259">toupper</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Convert a character into its upper case representation.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#ctype.h">ctype.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>int __fastcall__ toupper (int c);</CODE></P>
<DT><B>Description</B><DD>
<P>The function returns the given character converted to upper
case. If the given character is not a letter, it is returned unchanged.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may
only be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>ISO 9899</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#islower">islower</A>,
<A HREF="#isupper">isupper</A>,
<A HREF="#tolower">tolower</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="ultoa"></A> <A NAME="ss3.260">3.260</A> <A HREF="#toc3.260">ultoa</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Convert an unsigned long integer into a string.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#stdlib.h">stdlib.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>char* __fastcall__ ultoa (unsigned long val, char* buf, int radix);</CODE></P>
<DT><B>Description</B><DD>
<P><CODE>itoa</CODE> converts the unsigned long integer <CODE>val</CODE> into a
string using <CODE>radix</CODE> as the base.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>There are no provisions to prevent a buffer overflow.</LI>
<LI>The function is non standard, so it is not available in strict ANSI mode.
You should probably use <CODE>sprintf</CODE> instead.</LI>
<LI>The function is only available as fastcall function, so it may only be
used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#atoi">atoi</A>,
<A HREF="#atol">atol</A>,
<A HREF="#itoa">itoa</A>,
<A HREF="#ltoa">ltoa</A>,
<A HREF="#utoa">utoa</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="unlink"></A> <A NAME="ss3.261">3.261</A> <A HREF="#toc3.261">unlink</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Delete a file.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#unistd.h">unistd.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>int __fastcall__ unlink (const char* name);</CODE></P>
<DT><B>Description</B><DD>
<P><CODE>unlink</CODE> deletes the file with the given name. On success,
zero is returned. On error, -1 is returned and <CODE>errno</CODE> is set to an error
code describing the reason for the failure.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The use of this function is discouraged. Please use <CODE>
<A HREF="#remove">remove</A></CODE> instead, which is a native ANSI C function and does the same.</LI>
<LI>This function is not available on all cc65 targets (depends on the
availability of file I/O).</LI>
<LI>The function is only available as fastcall function, so it may only
be used in presence of a prototype.</LI>
<LI>Instead of <CODE>unlink</CODE>, <CODE>
<A HREF="#remove">remove</A></CODE> should be
used, which has the same semantics, but is more portable, because it conforms
to the ISO C standard.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>POSIX 1003.1</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#remove">remove</A></P>
<DT><B>Example</B><DD>
<P>
<PRE>
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

#define FILENAME "helloworld"

if (unlink (FILENAME) == 0) {
    printf ("We deleted %s successfully\n", FILENAME);
} else {
    printf ("There was a problem deleting %s\n", FILENAME);
}
</PRE>
</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="utoa"></A> <A NAME="ss3.262">3.262</A> <A HREF="#toc3.262">utoa</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Convert an unsigned integer into a string.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#stdlib.h">stdlib.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>char* __fastcall__ utoa (unsigned val, char* buf, int radix);</CODE></P>
<DT><B>Description</B><DD>
<P><CODE>itoa</CODE> converts the unsigned integer <CODE>val</CODE> into a string
using <CODE>radix</CODE> as the base.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>There are no provisions to prevent a buffer overflow.</LI>
<LI>The function is non standard, so it is not available in strict ANSI mode.
You should probably use <CODE>sprintf</CODE> instead.</LI>
<LI>The function is only available as fastcall function, so it may only be
used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#atoi">atoi</A>,
<A HREF="#atol">atol</A>,
<A HREF="#itoa">itoa</A>,
<A HREF="#ltoa">ltoa</A>,
<A HREF="#ultoa">ultoa</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="vcprintf"></A> <A NAME="ss3.263">3.263</A> <A HREF="#toc3.263">vcprintf</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Formatted output to the console.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#conio.h">conio.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>int __fastcall__ vcprintf (const char* format, va_list ap);</CODE></P>
<DT><B>Description</B><DD>
<P>The arguments specified as a <CODE>va_list</CODE> are converted to
text where necessary and formatted according to the format string given. The
resulting string is output to the console. <CODE>vcprintf</CODE> supports the same
format specifiers as <CODE>vprintf</CODE>. </P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>Like all other <CODE>conio</CODE> output functions, <CODE>vcprintf</CODE> distinguishes
between <CODE>\r</CODE> and <CODE>\n</CODE>.</LI>
<LI>The function is only available as fastcall function, so it may only be
used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#cprintf">cprintf</A>,
<A HREF="#cputc">cputc</A>,
<A HREF="#cputcxy">cputcxy</A>,
<A HREF="#cputs">cputs</A>,
<A HREF="#cputsxy">cputsxy</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="videomode"></A> <A NAME="ss3.264">3.264</A> <A HREF="#toc3.264">videomode</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Switch to either 40 or 80 column mode.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#apple2enh.h">apple2enh.h</A>,
<A HREF="#c128.h">c128.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>unsigned __fastcall__ videomode (unsigned Mode);</CODE></P>
<DT><B>Description</B><DD>
<P>Switch to 40 or 80 column mode depending on the argument. If
the requested mode is already active, nothing happens. The old mode is returned
from the call.</P>
<DT><B>Limits</B><DD>
<P>
<UL>
<LI>The function is specific to the C128 and enhanced Apple //e.</LI>
<LI>This function replaces 
<A HREF="#toggle_videomode">toggle_videomode</A>.</LI>
<LI>The function is only available as fastcall function, so it may only be
used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>C128 and enhanced Apple //e</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#fast">fast</A>,
<A HREF="#slow">slow</A>,
<A HREF="#toggle_videomode">toggle_videomode</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="wherex"></A> <A NAME="ss3.265">3.265</A> <A HREF="#toc3.265">wherex</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Return the current X position of the text mode cursor.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#conio.h">conio.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>unsigned char wherex (void);</CODE></P>
<DT><B>Description</B><DD>
<P>The function returns the current X position of the text mode
cursor. Zero is returned for the leftmost screen position.</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#gotox">gotox</A>,
<A HREF="#gotoy">gotoy</A>,
<A HREF="#gotoxy">gotoxy</A>,
<A HREF="#wherey">wherey</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


<H2><A NAME="wherey"></A> <A NAME="ss3.266">3.266</A> <A HREF="#toc3.266">wherey</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Return the current Y position of the text mode cursor.</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#conio.h">conio.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>unsigned char wherey (void);</CODE></P>
<DT><B>Description</B><DD>
<P>The function returns the current Y position of the text mode
cursor. Zero is returned for the uppermost screen position.</P>
<DT><B>Availability</B><DD>
<P>cc65</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#gotox">gotox</A>,
<A HREF="#gotoy">gotoy</A>,
<A HREF="#gotoxy">gotoxy</A>,
<A HREF="#wherex">wherex</A></P>
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>


</BODY>
</HTML>
