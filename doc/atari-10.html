<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="LinuxDoc-Tools 0.9.69">
 <TITLE>Atari specific information for cc65: Other hints</TITLE>
 <LINK HREF="atari-11.html" REL=next>
 <LINK HREF="atari-9.html" REL=previous>
 <LINK HREF="atari.html#toc10" REL=contents>
</HEAD>
<BODY>
<A HREF="atari-11.html">Next</A>
<A HREF="atari-9.html">Previous</A>
<A HREF="atari.html#toc10">Contents</A>
<HR>
<H2><A NAME="s10">10.</A> <A HREF="atari.html#toc10">Other hints</A></H2>




<H2><A NAME="ss10.1">10.1</A> <A HREF="atari.html#toc10.1">Function keys</A>
</H2>


<P>Function keys are mapped to Atari + number key.</P>


<H2><A NAME="ss10.2">10.2</A> <A HREF="atari.html#toc10.2">Passing arguments to the program</A>
</H2>


<P>Command line arguments can be passed to <CODE>main()</CODE> when DOS supports it.</P>
<P>
<OL>
<LI>Arguments are separated by spaces.</LI>
<LI>Leading and trailing spaces around an argument are ignored.</LI>
<LI>The first argument passed to <CODE>main</CODE> is the program name.</LI>
<LI>A maximum number of 16 arguments (including the program name) are
supported.                                                       </LI>
</OL>
</P>


<H2><A NAME="ss10.3">10.3</A> <A HREF="atari.html#toc10.3">Interrupts</A>
</H2>


<P>The runtime for the Atari uses routines marked as <CODE>.INTERRUPTOR</CODE> for
interrupt handlers. Such routines must be written as simple machine language
subroutines and will be called automatically by the VBI handler code
when they are linked into a program. See the discussion of the <CODE>.CONDES</CODE>
feature in the 
<A HREF="ca65.html">assembler manual</A>.</P>


<H2><A NAME="memhole"></A> <A NAME="ss10.4">10.4</A> <A HREF="atari.html#toc10.4">Reserving a memory area inside a program</A>
</H2>


<P>(This section is primarily applicable to the <CODE>atari</CODE> target, but the
principles apply to <CODE>atatixl</CODE> as well.)</P>
<P>The Atari 130XE maps its additional memory into CPU memory in 16K
chunks at address $4000 to $7FFF. One might want to
prevent this memory area from being used by cc65. Other reasons to
prevent the use of some memory area could be to reserve space for the
buffers for display lists and screen memory.</P>
<P>The Atari executable format allows holes inside a program, e.g. one
part loads into $2E00 to $3FFF, going below the reserved
memory area (assuming a reserved area from $4000 to
$7FFF), and another part loads into $8000 to
$BC1F.</P>
<P>Each load chunk of the executable starts with a 4 byte header which
defines its load address and size. In the following linker config files
these headers are named HEADER and SECHDR (for the MEMORY layout), and
accordingly NEXEHDR and CHKHDR (for the SEGMENTS layout).</P>

<H3>Low code and high data example</H3>

<P>Goal: Create an executable with 2 load chunks which doesn't use the
memory area from $4000 to $7FFF. The CODE segment of
the program should go below $4000 and the DATA and RODATA
segments should go above $7FFF.</P>
<P>The main problem is that the EXE header generated by the cc65 runtime
lib is wrong. It defines a single load chunk with the sizes/addresses
of the STARTUP, LOWCODE, INIT, CODE, RODATA, and DATA segments, in 
fact, the whole user program (we're disregarding the "system check"
load chunk here).</P>
<P>The contents of the EXE header come from the EXEHDR and MAINHDR segments.
The EXEHDR segment just contains the $FFFF value which is required
to be the first bytes of the EXE file.<BR>
The MAINHDR are defined in in crt0.s. This cannot be changed without
modifying and recompiling the cc65 atari runtime library. Therefore
the original contents of this segment must be discarded and be
replaced by a user created one. This discarding is done by assigning the
MAINHDR segment to the (new introduced) DISCARD memory area. The DISCARD memory area is
thrown away in the new linker config file (written to file "").
We add a new FSTHDR segment for the chunk header of the first chunk.</P>
<P>The user needs to create a customized linker config file which adds
new memory areas and segments to hold the new header data for the first load
chunk and the header data for the second load chunk. Also an assembly source file
needs to be created which defines the contents of the new header data
for the two load chunks.</P>

<P>This is an example of a modified cc65 Atari linker configuration file
(split.cfg):
<BLOCKQUOTE><CODE>
<PRE>
SYMBOLS {
    __STACKSIZE__:       value = $800   type = weak;    # 2K stack
    __RESERVED_MEMORY__: value = $0000, type = weak;
}
FEATURES {
    STARTADDRESS: default = $2E00;
}
MEMORY {
    ZP: start = $82, size = $7E, type = rw, define = yes;

    HEADER: start = $0000, size = $2, file = %O;        # first load chunk

    FSTHDR: start = $0000, size = $4, file = %O;        # second load chunk
    RAMLO: start = %S, size = $4000 - %S, file = %O;

    DISCARD: start = $4000, size = $4000, file = "";

    SECHDR: start = $0000, size = $4, file = %O;        # second load chunk
    RAM: start = $8000, size = $3C20, file = %O;        # $3C20: matches upper bound $BC1F
}
SEGMENTS {
    EXEHDR: load = HEADER, type = ro;

    MAINHDR: load = DISCARD, type = ro;

    NEXEHDR: load = FSTHDR, type = ro;                  # first load chunk
    STARTUP: load = RAMLO, type = ro, define = yes;
    LOWCODE: load = RAMLO, type = ro, define = yes, optional = yes;
    INIT: load = RAMLO, type = ro, optional = yes;
    CODE: load = RAMLO, type = ro, define = yes;

    CHKHDR: load = SECHDR, type = ro;                   # second load chunk
    RODATA: load = RAM, type = ro, define = yes;
    DATA: load = RAM, type = rw, define = yes;
    BSS: load = RAM, type = bss, define = yes;

    ZEROPAGE: load = ZP, type = zp;
    AUTOSTRT: load = RAM, type = ro;                    # defines program entry point
}
FEATURES {
    CONDES: segment = RODATA,
            type = constructor,
            label = __CONSTRUCTOR_TABLE__,
            count = __CONSTRUCTOR_COUNT__;
    CONDES: segment = RODATA,
            type = destructor,
            label = __DESTRUCTOR_TABLE__,
            count = __DESTRUCTOR_COUNT__;
}
</PRE>
</CODE></BLOCKQUOTE>
</P>

<P>A new memory area DISCARD was added.
It gets loaded with the contents of the (now unused) MAINHDR segment. But the
memory area isn't written to the output file. This way the contents of
the MAINHDR segment get discarded.</P>
<P>The newly added NEXEHDR segment defines the correct chunk header for the
first intended load chunk. It
puts the STARTUP, LOWCODE, INIT, and CODE segments, which are the
segments containing only code, into load chunk #1 (RAMLO memory area).</P>
<P>The header for the second load chunk comes from the new CHKHDR
segment. It puts the RODATA, DATA, BSS, and ZPSAVE segments into load
chunk #2 (RAM memory area).</P>

<P>The contents of the new NEXEHDR and CHKHDR segments come from this
file (split.s):
<BLOCKQUOTE><CODE>
<PRE>
        .import __CODE_LOAD__, __BSS_LOAD__, __CODE_SIZE__
        .import __DATA_LOAD__, __RODATA_LOAD__, __STARTUP_LOAD__

        .segment "NEXEHDR"
        .word    __STARTUP_LOAD__
        .word    __CODE_LOAD__ + __CODE_SIZE__ - 1

        .segment "CHKHDR"
        .word    __RODATA_LOAD__
        .word    __BSS_LOAD__ - 1
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>Compile with
<BLOCKQUOTE><CODE>
<PRE>
cl65 -t atari -C split.cfg -o prog.com prog.c split.s
</PRE>
</CODE></BLOCKQUOTE>
</P>

<H3>Low data and high code example</H3>



<P>Goal: Put RODATA and DATA into low memory and STARTUP, LOWCODE, INIT,
CODE, BSS, ZPSAVE into high memory (split2.cfg):</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
SYMBOLS {
    __STACKSIZE__:       value = $800   type = weak;    # 2K stack
    __RESERVED_MEMORY__: value = $0000, type = weak;
}
FEATURES {
    STARTADDRESS: default = $2E00;
}
MEMORY {
    ZP: start = $82, size = $7E, type = rw, define = yes;

    HEADER: start = $0000, size = $2, file = %O;        # first load chunk

    FSTHDR: start = $0000, size = $4, file = %O;        # second load chunk
    RAMLO: start = %S, size = $4000 - %S, file = %O;

    DISCARD: start = $4000, size = $4000, file = "";

    SECHDR: start = $0000, size = $4, file = %O;        # second load chunk
    RAM: start = $8000, size = $3C20, file = %O;        # $3C20: matches upper bound $BC1F
}
SEGMENTS {
    EXEHDR: load = HEADER, type = ro;                     # discarded old EXE header

    MAINHDR: load = DISCARD, type = ro;

    NEXEHDR: load = FSTHDR, type = ro;                  # first load chunk
    RODATA: load = RAMLO, type = ro, define = yes;
    DATA: load = RAMLO, type = rw, define = yes;

    CHKHDR: load = SECHDR, type = ro;                   # second load chunk
    STARTUP: load = RAM, type = ro, define = yes;
    INIT: load = RAM, type = ro, optional = yes;
    CODE: load = RAM, type = ro, define = yes;
    BSS: load = RAM, type = bss, define = yes;

    ZEROPAGE: load = ZP, type = zp;
    AUTOSTRT: load = RAM, type = ro;                    # defines program entry point
}
FEATURES {
    CONDES: segment = RODATA,
            type = constructor,
            label = __CONSTRUCTOR_TABLE__,
            count = __CONSTRUCTOR_COUNT__;
    CONDES: segment = RODATA,
            type = destructor,
            label = __DESTRUCTOR_TABLE__,
            count = __DESTRUCTOR_COUNT__;
}
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>New contents for NEXEHDR and CHKHDR are needed (split2.s):
<BLOCKQUOTE><CODE>
<PRE>
        .import __STARTUP_LOAD__, __BSS_LOAD__, __DATA_SIZE__
        .import __DATA_LOAD__, __RODATA_LOAD__

        .segment "NEXEHDR"
        .word    __RODATA_LOAD__
        .word    __DATA_LOAD__ + __DATA_SIZE__ - 1

        .segment "CHKHDR"
        .word    __STARTUP_LOAD__
        .word    __BSS_LOAD__ - 1
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>Compile with
<BLOCKQUOTE><CODE>
<PRE>
cl65 -t atari -C split2.cfg -o prog.com prog.c split2.s
</PRE>
</CODE></BLOCKQUOTE>
</P>

<H3><A NAME="memhole_final_note"></A> Final note</H3>


<P>There are two other memory areas which don't appear directly in the
linker config file. They are the stack and the heap.</P>
<P>The cc65 runtime lib places the stack location at the end of available
memory. This is dynamically set from the MEMTOP system variable at
startup. The heap is located in the area between the end of the BSS
segment and the top of the stack as defined by __STACKSIZE__.</P>
<P>If BSS and/or the stack shouldn't stay at the end of the program,
some parts of the cc65 runtime lib need to be replaced/modified.</P>
<P>common/_heap.s defines the location of the heap and atari/crt0.s
defines the location of the stack by initializing sp.</P>


<H2><A NAME="ss10.5">10.5</A> <A HREF="atari.html#toc10.5">Upgrading from an older cc65 version</A>
</H2>


<P>If you are using a customized linker config file you might get some errors
regarding the MAINHDR segment. Like this:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
ld65: Error: Missing memory area assignment for segment `MAINHDR'
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>The old "HEADER" memory description contained six bytes: $FFFF
and the first and last memory addess of the program. For the "system
check" load chunk this had to be split into two memory assigments. The
"HEADER" now only contains the $FFFF. The main program's first
and last memory address were moved to a new segment, called "MAINHDR",
which in the new linker config file goes into its own memory area (also
called "MAINHDR").<BR><BR>
A simple way to adapt your old linker config file is to add the
following line to the "SEGMENTS" section:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
MAINHDR: load = HEADER, type = ro;
</PRE>
</CODE></BLOCKQUOTE>
</P>



<H2><A NAME="ss10.6">10.6</A> <A HREF="atari.html#toc10.6">Getting rid of the "system check" load chunk</A>
</H2>


<P>If, for some reason, you don't want to include the "system check" load
chunk, you can do so by defining the symbol <CODE>syschk</CODE> when linking the
program. The "system check" chunk doesn't include vital parts of the
program. So if you don't want the system checks, it is save to leave them out.
This is probably mostly interesting for debugging.</P>
<P>When using cl65, you can leave it out with this command line:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
cl65 -Wl -Dsyschk=1 &lt;arguments>
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>The value you assign to <CODE>syschk</CODE> doesn't matter. If the <CODE>syschk</CODE>
symbol is defined, the load chunk won't be included.</P>


<HR>
<A HREF="atari-11.html">Next</A>
<A HREF="atari-9.html">Previous</A>
<A HREF="atari.html#toc10">Contents</A>
</BODY>
</HTML>
