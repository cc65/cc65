<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <LINK REL="stylesheet" TYPE="text/css" HREF="doc.css">
 <META NAME="GENERATOR" CONTENT="LinuxDoc-Tools 0.9.66">
 <TITLE>co65 Users Guide</TITLE>
</HEAD>
<BODY>
<H1>co65 Users Guide</H1>

<H2>
<A HREF="mailto:uz@cc65.org">Ullrich von Bassewitz</A></H2>12.02.2003
<HR>
<EM>co65 is an object file conversion utility. It converts o65 object files into
the native object file format used by the cc65 tool chain. Since o65 is the
file format used by cc65 for loadable drivers, the co65 utility allows (among
other things) to link drivers statically to the generated executables instead
of loading them from disk.</EM>
<HR>
<P>
<H2><A NAME="toc1">1.</A> <A HREF="co65.html#s1">Overview</A></H2>

<P>
<H2><A NAME="toc2">2.</A> <A HREF="co65.html#s2">Usage</A></H2>

<UL>
<LI><A NAME="toc2.1">2.1</A> <A HREF="co65.html#ss2.1">Command line option overview</A>
<LI><A NAME="toc2.2">2.2</A> <A HREF="co65.html#ss2.2">Command line options in detail</A>
</UL>
<P>
<H2><A NAME="toc3">3.</A> <A HREF="co65.html#s3">Input and output</A></H2>

<P>
<H2><A NAME="toc4">4.</A> <A HREF="co65.html#s4">Converting loadable drivers</A></H2>

<UL>
<LI><A NAME="toc4.1">4.1</A> <A HREF="co65.html#ss4.1">Differences between static linking and runtime loading</A>
<LI><A NAME="toc4.2">4.2</A> <A HREF="co65.html#ss4.2">Additional requirements</A>
<LI><A NAME="toc4.3">4.3</A> <A HREF="co65.html#ss4.3">Example - Convert and link a graphics driver</A>
</UL>
<P>
<H2><A NAME="toc5">5.</A> <A HREF="co65.html#s5">Copyright</A></H2>


<HR>
<H2><A NAME="s1">1.</A> <A HREF="#toc1">Overview</A></H2>


<P>co65 is an object file conversion utility. It converts o65 object files into
assembler files, which may be translated by ca65 to generate object files in
the native object file format used by the cc65 tool chain.</P>
<P>Since loadable drivers used by the library that comes with cc65 use the o65
relocatable object code format, using the co65 utility allows to link these
drivers statically. This enables the use of these drivers without loading
additional files from a disk or other secondary storage.</P>
<P>Another use would be to link object files generated by other development tools
to projects using the cc65 tool chain, but this has not been tested until now,
since such tools are currently rare.</P>



<H2><A NAME="s2">2.</A> <A HREF="#toc2">Usage</A></H2>


<P>The co65 utility converts one o65 file per run into one assembler files in
ca65 format. The utility tries to autodetect the type of the o65 input file
using the operating system identifier contained in the o65 option list.</P>


<H2><A NAME="ss2.1">2.1</A> <A HREF="#toc2.1">Command line option overview</A>
</H2>


<P>The converter may be called as follows:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
---------------------------------------------------------------------------
Usage: co65 [options] file
Short options:
  -V                    Print the version number
  -g                    Add debug info to object file
  -h                    Help (this text)
  -m model              Override the o65 model
  -n                    Don't generate an output file
  -o name               Name the output file
  -v                    Increase verbosity

Long options:
  --bss-label name      Define and export a BSS segment label
  --bss-name seg        Set the name of the BSS segment
  --code-label name     Define and export a CODE segment label
  --code-name seg       Set the name of the CODE segment
  --data-label name     Define and export a DATA segment label
  --data-name seg       Set the name of the DATA segment
  --debug-info          Add debug info to object file
  --help                Help (this text)
  --no-output           Don't generate an output file
  --o65-model model     Override the o65 model
  --verbose             Increase verbosity
  --version             Print the version number
  --zeropage-label name Define and export a ZEROPAGE segment label
  --zeropage-name seg   Set the name of the ZEROPAGE segment
---------------------------------------------------------------------------
</PRE>
</CODE></BLOCKQUOTE>
</P>


<H2><A NAME="ss2.2">2.2</A> <A HREF="#toc2.2">Command line options in detail</A>
</H2>


<P>Here is a description of all the command line options:</P>
<P>
<DL>

<DT><B><CODE>--bss-label name</CODE></B><DD>
<P>Set the label used to mark the start of the bss segment. When this option is
given, the label is also exported and may be accessed from other code. When
accessing such a label from C code, be sure to include the leading
underscore. If you don't need to access the bss segment, there's no need to
use this option.</P>


<DT><B><CODE>--bss-name seg</CODE></B><DD>
<P>Set the name of the bss segment. The default name is "BSS" which is
compatible with the standard ld65 linker configurations.</P>


<DT><B><CODE>--code-label name</CODE></B><DD>
<P>Set the label used to mark the start of the code segment. When this option
is given, the label is also exported and may be accessed from other code.
When accessing such a label from C code, be sure to include the leading
underscore. If you don't need to access the code segment, there's no need to
use this option.</P>


<DT><B><CODE>--code-name seg</CODE></B><DD>
<P>Set the name of the code segment. The default name is "CODE" which is
compatible with the standard ld65 linker configurations.</P>


<DT><B><CODE>--data-label name</CODE></B><DD>
<P>Set the label used to mark the start of the data segment. When this option
is given, the label is also exported and may be accessed from other code.
When accessing such a label from C code, be sure to include the leading
underscore. If you don't need to access the data segment, there's no need to
use this option.</P>


<DT><B><CODE>--data-name seg</CODE></B><DD>
<P>Set the name of the data segment. The default name is "DATA" which is
compatible with the standard ld65 linker configurations.</P>


<DT><B><CODE>-d, --debug</CODE></B><DD>
<P>Enables debug mode, something that should not be needed for mere mortals.
Currently the converter does only accept cc65 loadable modules generated by
ld65 when not in debug mode. Please note that correct conversion has never
been tested for o65 files from other sources, so be careful when using
<CODE>-d</CODE>.</P>


<DT><B><CODE>-g, --debug-info</CODE></B><DD>
<P>This will cause the converter to insert a <CODE>.DEBUGINFO</CODE> command into the
generated assembler code. This will cause the assembler to include all
symbols in a special section in the object file.</P>


<DT><B><CODE>-h, --help</CODE></B><DD>
<P>Print the short option summary shown above.</P>


<DT><B><CODE>-m model, --o65-model model</CODE></B><DD>
<P>Set an o65 model. This option changes the way, output is generated for the
given o65 file. For example, cc65 loadable drivers have a zero page segment,
but this segment must not be defined in the file itself, because the
standard module loader will overlay it with the zeropage space used by the
application that loads this module. So instead of allocating space in the
zero page segment, the converter will reference the start of the zero page
area used by the application.</P>
<P>Currently, the following models are defined:</P>
<P>
<UL>
<LI>lunix</LI>
<LI>os/a65</LI>
<LI>cc65-module</LI>
</UL>
</P>
<P>The default is to autodetect the model to use from the input file, so
there's rarely a need to use this option.</P>


<DT><B><CODE>-n, --no-output</CODE></B><DD>
<P>Don't do the actual conversion, just read in the o65 file checking for
problems. This option may be used in conjunction with <CODE>--verbose</CODE> to
view some information about the input file.</P>


<DT><B><CODE>-o name</CODE></B><DD>
<P>Specify the name of the output file. If you don't specify a name, the
name of the o65 input file is used, with the extension replaced by ".s".</P>


<DT><B><CODE>-v, --verbose</CODE></B><DD>
<P>Using this option, the converter will be somewhat more verbose and print
some information about the o65 input file (among other things). You may use
this option together with <CODE>--no-output</CODE> to just get the o65 info.</P>


<DT><B><CODE>-V, --version</CODE></B><DD>
<P>Print the version number of the compiler. When submitting a bug report,
please include the operating system you're using, and the compiler
version.</P>


<DT><B><CODE>--zeropage-label name</CODE></B><DD>
<P>Set the label used to mark the start of the zeropage segment. When this
option is given, the label is also exported and may be accessed from other
code. When accessing such a label from C code, be sure to include the
leading underscore. If you don't need to access the zeropage segment,
there's no need to use this option.</P>


<DT><B><CODE>--zeropage-name seg</CODE></B><DD>
<P>Set the name of the zeropage segment. The default name is "ZEROPAGE" which is
compatible with the standard ld65 linker configurations.</P>

</DL>
</P>


<H2><A NAME="s3">3.</A> <A HREF="#toc3">Input and output</A></H2>


<P>The converter will accept one o65 file per invocation and create a file with
the same base name, but with the extension replaced by ".s". The output
file contains assembler code suitable for the use with the ca65 macro
assembler.</P>


<H2><A NAME="s4">4.</A> <A HREF="#toc4">Converting loadable drivers</A></H2>



<H2><A NAME="ss4.1">4.1</A> <A HREF="#toc4.1">Differences between static linking and runtime loading</A>
</H2>


<P>One main use of the utility is conversion of loadable drivers, so they may be
linked statically to an application. Statically linking will cause a few
things to be different from runtime loading:</P>
<P>
<UL>
<LI>  Without changing the segment names, all segments take the default
names used by the standard linker configurations. This means that the
driver code is no longer contingous in memory, instead the code
segment is placed somewhere in between all other code segments, the
data segment is placed with all other data segments and so on. If the
driver doesn't do strange things this shouldn't be a problem.
</LI>
<LI>  With statically linked code, data and bss segments will get intialized
once (when the application is loaded), while a loadable driver will
get its initialization each time the driver is loaded into memory
(which may be more than once in the lifetime of a program). It depends
on the driver if this is a problem. Currently, most drivers supplied
with cc65 behave correctly when linked statically.
</LI>
</UL>
</P>


<H2><A NAME="ss4.2">4.2</A> <A HREF="#toc4.2">Additional requirements</A>
</H2>


<P>All loadable drivers used by cc65 have a header and a jump table at the start
of the code segment. The header is needed to detect the driver (it may also
contain some data that is necessary to access the driver). The jump table is
used to access the functions in the driver code.</P>
<P>When loading a driver at runtime, the load address of the driver is also the
address of the code segment, so the locations of the header and jump table are
known. However, when linking the driver statically, it is up to the programmer
to provide this information to the driver API.</P>
<P>For this purpose, it is necessary to define a code segment label that can be
accessed from the outside later. Please note that the converter does currently
<EM>not</EM> create such a label without being ordered to do so, even if the input
file is a cc65 module.</P>
<P>To create such a label, use the <CODE>--code-label</CODE> option when calling the
converter. Be sure to begin the label with a leading underscore when accessing
it from C code. In your code, define an arbitrary variable with this name. Use
the address of this variable as the address of the code segment of the driver.
Be sure to never modify the variable which is in reality the start of your
driver!</P>


<H2><A NAME="ss4.3">4.3</A> <A HREF="#toc4.3">Example - Convert and link a graphics driver</A>
</H2>


<P>As an example, here are some instructions to convert and use the c64-hi.tgi
graphics driver:</P>
<P>First, convert the driver, generating a label named "_c64_hi" for the code
segment. Use the assembler to generate an object file from the assembler
output.</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
        co65 --code-label _c64_hi c64-hi.tgi
        ca65 c64-hi.s
  
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>Next, change your C code to declare a variable that is actually the address
of the driver:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
        extern void c64_hi[];
  
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>Instead of loading and unloading the driver, change the code to install and
uninstall the driver, which will be already in memory after linking:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
        /* Install the driver */
        tgi_install (c64_hi);

        ...

        /* Uninstall the driver */
        tgi_uninstall ();
  
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>Don't forget to link the driver object file to your application, otherwise you
will get an "undefined external" error for the _c64_hi symbol.</P>




<H2><A NAME="s5">5.</A> <A HREF="#toc5">Copyright</A></H2>


<P>co65 is (C) Copyright 2003 Ullrich von Bassewitz. For usage of the binaries
and/or sources the following conditions apply:</P>
<P>This software is provided 'as-is', without any expressed or implied
warranty.  In no event will the authors be held liable for any damages
arising from the use of this software.</P>
<P>Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:</P>
<P>
<OL>
<LI>    The origin of this software must not be misrepresented; you must not
claim that you wrote the original software. If you use this software
in a product, an acknowledgment in the product documentation would be
appreciated but is not required.</LI>
<LI>    Altered source versions must be plainly marked as such, and must not
be misrepresented as being the original software.</LI>
<LI>    This notice may not be removed or altered from any source
distribution.</LI>
</OL>
</P>

</BODY>
</HTML>
