<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="LinuxDoc-Tools 0.9.66">
 <TITLE>ca65 Users Guide: Symbols and labels</TITLE>
 <LINK HREF="ca65-7.html" REL=next>
 <LINK HREF="ca65-5.html" REL=previous>
 <LINK HREF="ca65.html#toc6" REL=contents>
</HEAD>
<BODY>
<A HREF="ca65-7.html">Next</A>
<A HREF="ca65-5.html">Previous</A>
<A HREF="ca65.html#toc6">Contents</A>
<HR>
<H2><A NAME="s6">6.</A> <A HREF="ca65.html#toc6">Symbols and labels</A></H2>


<P>A symbol or label is an identifier that starts with a letter and is followed
by letters and digits. Depending on some features enabled (see
<CODE>
<A HREF="ca65-11.html#at_in_identifiers">at_in_identifiers</A></CODE>,
<CODE>
<A HREF="ca65-11.html#dollar_in_identifiers">dollar_in_identifiers</A></CODE> and
<CODE>
<A HREF="ca65-11.html#leading_dot_in_identifiers">leading_dot_in_identifiers</A></CODE>)
other characters may be present. Use of identifiers consisting of a single
character will not work in all cases, because some of these identifiers are
reserved keywords (for example "A" is not a valid identifier for a label,
because it is the keyword for the accumulator).</P>
<P>The assembler allows you to use symbols instead of naked values to make
the source more readable. There are a lot of different ways to define and
use symbols and labels, giving a lot of flexibility.</P>

<H2><A NAME="ss6.1">6.1</A> <A HREF="ca65.html#toc6.1">Numeric constants</A>
</H2>


<P>Numeric constants are defined using the equal sign or the label assignment
operator. After doing</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
        two = 2
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>may use the symbol "two" in every place where a number is expected, and it is
evaluated to the value 2 in this context. The label assignment operator is
almost identical, but causes the symbol to be marked as a label, so it may be
handled differently in a debugger:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
        io := $d000
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>The right side can of course be an expression:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
        four = two * two
</PRE>
</CODE></BLOCKQUOTE>
</P>

<P>
<A NAME="variables"></A> </P>
<H2><A NAME="ss6.2">6.2</A> <A HREF="ca65.html#toc6.2">Numeric variables</A>
</H2>


<P>Within macros and other control structures (<CODE>
<A HREF="ca65-11.html#.REPEAT">.REPEAT</A></CODE>, ...) it is sometimes useful to have some sort of
variable. This can be achieved by the <CODE>.SET</CODE> operator. It creates a
symbol that may get assigned a different value later:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
        four .set 4
        lda     #four           ; Loads 4 into A
        four .set 3
        lda     #four           ; Loads 3 into A
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>Since the value of the symbol can change later, it must be possible to
evaluate it when used (no delayed evaluation as with normal symbols). So the
expression used as the value must be constant.</P>
<P>Following is an example for a macro that generates a different label each time
it is used. It uses the <CODE>
<A HREF="ca65-10.html#.SPRINTF">.SPRINTF</A></CODE> function
and a numeric variable named <CODE>lcount</CODE>.</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
        .lcount .set 0          ; Initialize the counter

        .macro  genlab
                .ident (.sprintf ("L%04X", lcount)):
                lcount .set lcount + 1
        .endmacro
</PRE>
</CODE></BLOCKQUOTE>
</P>


<H2><A NAME="ss6.3">6.3</A> <A HREF="ca65.html#toc6.3">Standard labels</A>
</H2>


<P>A label is defined by writing the name of the label at the start of the line
(before any instruction mnemonic, macro or pseudo directive), followed by a
colon. This will declare a symbol with the given name and the value of the
current program counter.</P>


<H2><A NAME="ss6.4">6.4</A> <A HREF="ca65.html#toc6.4">Local labels and symbols</A>
</H2>


<P>Using the <CODE>
<A HREF="ca65-11.html#.PROC">.PROC</A></CODE> directive, it is possible to
create regions of code where the names of labels and symbols are local to this
region. They are not known outside of this region and cannot be accessed from
there. Such regions may be nested like PROCEDUREs in Pascal.</P>
<P>See the description of the <CODE>
<A HREF="ca65-11.html#.PROC">.PROC</A></CODE>
directive for more information.</P>


<H2><A NAME="ss6.5">6.5</A> <A HREF="ca65.html#toc6.5">Cheap local labels</A>
</H2>


<P>Cheap local labels are defined like standard labels, but the name of the
label must begin with a special symbol (usually '@', but this can be
changed by the <CODE>
<A HREF="ca65-11.html#.LOCALCHAR">.LOCALCHAR</A></CODE>
directive).</P>
<P>Cheap local labels are visible only between two non cheap labels. As soon as a
standard symbol is encountered (this may also be a local symbol if inside a
region defined with the <CODE>
<A HREF="ca65-11.html#.PROC">.PROC</A></CODE> directive), the
cheap local symbol goes out of scope.</P>
<P>You may use cheap local labels as an easy way to reuse common label
names like "Loop". Here is an example:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
        Clear:  lda    #$00             ; Global label
                ldy    #$20
        @Loop:  sta    Mem,y            ; Local label
                dey
                bne    @Loop            ; Ok
                rts
        Sub:    ...                     ; New global label
                bne    @Loop            ; ERROR: Unknown identifier!
</PRE>
</CODE></BLOCKQUOTE>
</P>

<H2><A NAME="ss6.6">6.6</A> <A HREF="ca65.html#toc6.6">Unnamed labels</A>
</H2>


<P>If you really want to write messy code, there are also unnamed labels. These
labels do not have a name (you guessed that already, didn't you?). A colon is
used to mark the absence of the name.</P>
<P>Unnamed labels may be accessed by using the colon plus several minus or plus
characters as a label designator. Using the '-' characters will create a back
reference (use the n'th label backwards), using '+' will create a forward
reference (use the n'th label in forward direction). An example will help to
understand this:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
        :       lda     (ptr1),y        ; #1
                cmp     (ptr2),y
                bne     :+              ; -> #2
                tax
                beq     :+++            ; -> #4
                iny
                bne     :-              ; -> #1
                inc     ptr1+1
                inc     ptr2+1
                bne     :-              ; -> #1

        :       bcs     :+              ; #2 -> #3
                ldx     #$FF
                rts

        :       ldx     #$01            ; #3
        :       rts                     ; #4
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>As you can see from the example, unnamed labels will make even short
sections of code hard to understand, because you have to count labels
to find branch targets (this is the reason why I for my part do
prefer the "cheap" local labels). Nevertheless, unnamed labels are
convenient in some situations, so it's your decision.</P>
<P><B>Note:</B> 
<A HREF="ca65-7.html#scopes">Scopes</A> organize named symbols, not
unnamed ones, so scopes don't have an effect on unnamed labels.</P>



<H2><A NAME="ss6.7">6.7</A> <A HREF="ca65.html#toc6.7">Using macros to define labels and constants</A>
</H2>


<P>While there are drawbacks with this approach, it may be handy in a few rare
situations. Using <CODE>
<A HREF="ca65-11.html#.DEFINE">.DEFINE</A></CODE>, it is possible
to define symbols or constants that may be used elsewhere. One of the
advantages is that you can use it to define string constants (this is not
possible with the other symbol types).</P>
<P>Please note: <CODE>.DEFINE</CODE> style macros do token replacements on a low level,
so the names do not adhere to scoping, diagnostics may be misleading, there
are no symbols to look up in the map file, and there is no debug info.
Especially the first problem in the list can lead to very nasty programming
errors. Because of these problems, the general advice is, <B>NOT</B> do use
<CODE>.DEFINE</CODE> if you don't have to.</P>
<P>Example:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
        .DEFINE two     2
        .DEFINE version "SOS V2.3"

        four = two * two        ; Ok
        .byte   version         ; Ok

        .PROC                   ; Start local scope
        two = 3                 ; Will give "2 = 3" - invalid!
        .ENDPROC
</PRE>
</CODE></BLOCKQUOTE>
</P>


<H2><A NAME="ss6.8">6.8</A> <A HREF="ca65.html#toc6.8">Symbols and <CODE>.DEBUGINFO</CODE></A>
</H2>


<P>If <CODE>
<A HREF="ca65-11.html#.DEBUGINFO">.DEBUGINFO</A></CODE> is enabled (or 
<A HREF="ca65-2.html#option-g">-g</A> is given on the command line), global, local and
cheap local labels are written to the object file and will be available in the
symbol file via the linker. Unnamed labels are not written to the object file,
because they don't have a name which would allow to access them.</P>



<HR>
<A HREF="ca65-7.html">Next</A>
<A HREF="ca65-5.html">Previous</A>
<A HREF="ca65.html#toc6">Contents</A>
</BODY>
</HTML>
