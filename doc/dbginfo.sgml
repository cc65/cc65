<!doctype linuxdoc system>

<article>
<title>cc65 Debug Info File Format
<author>
<url url="mailto:willis.blackburn@gmail.com" name="Willis Blackburn">

<abstract>
The debug info file format used by the cc65 compiler suite.
</abstract>

<!-- Table of contents -->
<toc>

<!-- Begin the document -->

<sect>Overview<p>

The debug info file (usually with extension <tt>.dbg</tt>) is generated by the compiler and linker when the <tt>-g</tt> option is used. It contains information about the source code, symbols, types, and memory layout of the program, which can be used by debuggers and other tools.

The file is a text file. Each line starts with a keyword identifying the type of information, followed by a list of <tt>key=value</tt> pairs separated by commas. The keys are specific to the type of information.

The canonical API for reading and writing debug info files is provided by the src/dbg/dbginfo.c and src/dbg/dbginfo.h files. If possible, use this API instead of parsing the file directly.
See the src/dbg/dbgsh.c file for an example of how to use the API.

<sect1>Object Relationships<p>

The following diagram shows the relationships between the different object types in the debug info file.

<figure>
<eps file="dbginfo.eps">
<img src="dbginfo.png">
</figure>

<sect>Syntax and Structure<p>
The debug info format is designed to be human-readable and line-oriented, making it easy to parse with simple tools or scripts. It relies on a flat record structure where each line represents a single node in the debug information graph.

The file consists of a sequence of records. Each record is a single line of text.
<tscreen><verb>
record_type key1=value1,key2=value2,key3="string_value",...
</verb></tscreen>
<itemize>
<item><tt>record_type</tt>: The first token on the line determines the semantic category of the record (e.g., <tt>file</tt>, <tt>sym</tt>). Whitespace (either tab or space) separates the record type from the attributes.
<item>Attributes: A comma-separated list of key-value pairs follows the record type.
<item>Data Types:
    <itemize>
    <item>Integers: Decimal or Hexadecimal (prefixed with <tt>0x</tt> or <tt>$</tt>).
    <item>Strings: Enclosed in double quotes.
    <item>References: Integer fields acting as foreign keys referencing the unique <tt>id</tt> of another record.
    </itemize>
</itemize>

The first line of a valid .dbg file is always a version directive:
<tscreen><verb>
version major=M,minor=m
</verb></tscreen>
<itemize>
<item>Major Version: Incremented for breaking structural changes that would prevent a parser from correctly reading the file.
<item>Minor Version: Incremented for additive, backward-compatible changes (e.g., adding a new attribute to an existing record type).
</itemize>

The current version of the debug info format is <tt>version major=2,minor=0</tt>.

Following the version line, the file typically starts with an info line giving counts of the various elements, and then the remaining elements.

<sect>Elements<p>

<sect1>csym<p>

Describes a C symbol (variable or function) and its location in memory or on the stack. This record handles the mapping between high-level C variable names and their runtime storage locations.

Since the 6502 hardware stack is limited to 256 bytes, cc65 implements a software stack (often referred to as the "soft stack") in main memory to handle recursion and local variables. The software stack pointer is typically maintained in a zero-page location (often referenced as <tt>sp</tt>).

Local (auto) variables are allocated on this soft stack. The <tt>sc=auto</tt> attribute indicates a stack-allocated variable, and the <tt>offs</tt> attribute specifies the offset from the current soft stack pointer.
<tscreen><verb>
Variable Address = SoftStackPointer + offs
</verb></tscreen>

<itemize>
<item><tt>id</tt>: Unique identifier for the symbol.
<item><tt>name</tt>: Name of the symbol.
<item><tt>scope</tt>: The scope ID where this symbol is defined.
<item><tt>type</tt>: The type ID of the symbol.
<item><tt>sc</tt>: Storage class. Can be <tt>auto</tt>, <tt>register</tt>, <tt>static</tt>, or <tt>extern</tt>.
<item><tt>offs</tt>: Offset (for auto/register variables).
<item><tt>sym</tt>: The associated assembler symbol ID (for static/extern variables).
</itemize>


<sect1>file<p>

Describes the source code files (.c, .s, .asm, .h) used to build the application.The size and modification time can be used by debuggers to detect "source drift" (when the source file on disk is newer than the debug info).

<itemize>
<item><tt>id</tt>: Unique identifier for the file.
<item><tt>name</tt>: Path to the source file. This is the name as the compiler saw it, e.g., <tt>cl65 src/main.c</tt> will result in a name of <tt>src/main.c</tt>.
<item><tt>size</tt>: Size of the file in bytes.
<item><tt>mtime</tt>: Last modification time (Unix timestamp).
<item><tt>mod</tt>: List of module IDs that use this file.
</itemize>


<sect1>info<p>

The <tt>info</tt> line provides the count of each type of element in the file. This can be used by parsers to pre-allocate memory.

Attributes correspond to the element types: <tt>csym</tt>, <tt>file</tt>, <tt>lib</tt>, <tt>line</tt>, <tt>mod</tt>, <tt>scope</tt>, <tt>seg</tt>, <tt>span</tt>, <tt>sym</tt>, <tt>type</tt>.


<sect1>lib<p>

Describes a static library (.lib) created by ar65 that was linked into the final executable. This acts as a container for object modules.

<itemize>
<item><tt>id</tt>: Unique identifier for the library.
<item><tt>name</tt>: Name of the library file.
</itemize>


<sect1>line<p>

Links a specific line in a source file to one or more <tt>span</tt> records, which in turn define the memory range of the generated code.

<itemize>
<item><tt>id</tt>: Unique identifier for the line info.
<item><tt>file</tt>: The file ID.
<item><tt>line</tt>: The line number.
<item><tt>span</tt>: List of span IDs covered by this line. Note that a single line may be broken into multiple spans; the canonical example is the C for statement.
<item><tt>type</tt>: Type of line (<tt>0</tt>=assembly, <tt>1</tt>=externally-supplied (e.g., C), <tt>2</tt>=macro expansion).
<item><tt>count</tt>: Nesting counter for macros.
</itemize>


<sect1>mod<p>

Represents a single translation unit (typically an object file) that was linked into the final executable. It links the object code back to its primary source file and optionally the library it came from.

<itemize>
<item><tt>id</tt>: Unique identifier for the module.
<item><tt>name</tt>: Name of the module.
<item><tt>file</tt>: The main source file ID for this module.
<item><tt>lib</tt>: The library ID if the module comes from a library.
</itemize>


<sect1>scope<p>

Defines the visibility rules for symbols, following the block structure of the source language (C blocks/functions or assembler .proc/.scope directives). Scopes form a hierarchy, with the <tt>parent</tt> attribute referencing the enclosing scope.

<itemize>
<item><tt>id</tt>: Unique identifier for the scope.
<item><tt>name</tt>: Name of the scope.
<item><tt>type</tt>: Type of scope (<tt>global</tt>, <tt>file</tt>, <tt>scope</tt>, <tt>struct</tt>, <tt>enum</tt>).
<item><tt>parent</tt>: The parent scope ID.
<item><tt>mod</tt>: The module ID this scope belongs to.
<item><tt>size</tt>: Size of the scope (e.g., for structs).
<item><tt>sym</tt>: Symbol ID associated with the scope (e.g., function label).
<item><tt>span</tt>: List of span IDs covered by this scope.
</itemize>


<sect1>seg<p>

Reflects the memory configuration defined in the linker script (.cfg). Each segment is a contiguous block of memory with specific attributes (read-only, read-write, bank).

<itemize>
<item><tt>id</tt>: Unique identifier for the segment.
<item><tt>name</tt>: Name of the segment.
<item><tt>start</tt>: Start address.
<item><tt>size</tt>: Size in bytes.
<item><tt>type</tt>: Segment type (<tt>ro</tt> = read-only, <tt>rw</tt> = read-write).
<item><tt>bank</tt>: Memory bank.
<item><tt>addrsize</tt>: The default address size (<tt>zeropage</tt> = 1 byte, <tt>absolute</tt> = 2 bytes, <tt>far</tt> = 3 bytes, <tt>long</tt> = 4 bytes) for this segment.
<item><tt>oname</tt>: Name of the output file this segment was written to.
<item><tt>ooffs</tt>: Offset within the output file.
</itemize>


<sect1>span<p>

Defines the placement of code or data within a segment. While a <tt>segment</tt> defines an area of memory, a <tt>span</tt> defines the exact range of bytes occupied by a function or data object within that area.
<tscreen><verb>
Absolute Address = Segment[span.seg].start + span.start
</verb></tscreen>

<itemize>
<item><tt>id</tt>: Unique identifier for the span.
<item><tt>seg</tt>: Segment ID the span belongs to.
<item><tt>start</tt>: Start address (relative to the start of the segment).
<item><tt>size</tt>: Size in bytes.
<item><tt>type</tt>: Type ID.
</itemize>


<sect1>sym<p>

Represents a raw assembler label or symbol. Unlike <tt>csym</tt>, which provides high-level type information, <tt>sym</tt> provides the low-level address or constant value.

<itemize>
<item><tt>id</tt>: Unique identifier for the symbol.
<item><tt>name</tt>: Name of the symbol.
<item><tt>val</tt>: Value of the symbol.
<item><tt>type</tt>: Type of symbol (<tt>equ</tt>, <tt>lab</tt>, <tt>imp</tt>).
<item><tt>seg</tt>: Segment ID.
<item><tt>size</tt>: Size of the symbol.
<item><tt>scope</tt>: Scope ID.
<item><tt>file</tt>: File ID where the symbol is defined.
<item><tt>addrsize</tt>: Address size (<tt>zeropage</tt> = 1 byte, <tt>absolute</tt> = 2 bytes, <tt>far</tt> = 3 bytes, <tt>long</tt> = 4 bytes).
<item><tt>exp</tt>: Export ID (if it's an import).
<item><tt>def</tt>: List of line IDs where the symbol is defined.
<item><tt>ref</tt>: List of line IDs where the symbol is referenced.
<item><tt>parent</tt>: Parent symbol ID (for local labels).
</itemize>


<sect1>type<p>

Serializes the compiler's internal type graph. This allows the debugger to correctly format and display complex data structures like structs, unions, arrays, and pointers.

<itemize>
<item><tt>id</tt>: Unique identifier for the type.
<item><tt>val</tt>: Hexadecimal string representing the type definition.
</itemize>

The type string is a sequence of hexadecimal bytes that describe the data type.

The type description doesn't attempt to mirror C. Instead it tries to describe the type as represented on the machine.
The reasoning behing this type is to allow a debugger to represent the data to the user, independent of the actual source.
C data types may be mapped to generic ones, but attributes like const or volatile are (of course) lost.

Each byte is encoded as two hexadecimal digits. The basic structure of a type identifier byte is:

<tscreen><verb>
7 6 5 4 3 2 1 0
T T T E S Z Z Z
</verb></tscreen>

<itemize>
<item><tt>TTT</tt>: Type code (bits 5-7)
<item><tt>E</tt>: Endianness (bit 4, 0 = Little, 1 = Big)
<item><tt>S</tt>: Sign (bit 3, 0 = Unsigned, 1 = Signed)
<item><tt>ZZZ</tt>: Size code (bits 0-2, actual size is value + 1)
</itemize>

<bf>Common Types:</bf>

<descrip>
<tag><tt>0x00 (GT_VOID)</tt></tag> Void type.
<tag><tt>0x20 (GT_BYTE)</tt></tag> 1-byte unsigned integer (unsigned char).
<tag><tt>0x21 (GT_WORD)</tt></tag> 2-byte unsigned integer (unsigned short/int).
<tag><tt>0x23 (GT_DWORD)</tt></tag> 4-byte unsigned integer (unsigned long).
<tag><tt>0x41 (GT_PTR)</tt></tag> 2-byte little-endian pointer.
<tag><tt>0x42 (GT_FAR_PTR)</tt></tag> 3-byte little-endian far pointer.
<tag><tt>0x51 (GT_DBYTE)</tt></tag> 2-byte big-endian pointer/integer.
</descrip>

<bf>Arrays:</bf>
Arrays are encoded with the type code <tt>0x80</tt> (GT_ARRAY). The lower 3 bits of the array token indicate the number of bytes that follow to specify the array size.
<p>Format: <tt>[Array Token] [Size Byte(s)] [Element Type]</tt>
<p>Example: An array of 10 (<tt>0x0A</tt>) bytes.
<itemize>
<item>Array Token: <tt>0x80 | (1 - 1) = 0x80</tt> (Size fits in 1 byte).
<item>Size: <tt>0x0A</tt>.
<item>Element Type: <tt>0x20</tt> (GT_BYTE).
<item>Resulting String: <tt>"800A20"</tt>
</itemize>

<sect1>version<p>

The <tt>version</tt> line specifies the version of the debug info format.

<itemize>
<item><tt>major</tt>: Major version number.
<item><tt>minor</tt>: Minor version number.
</itemize>

Example: <tt>version major=2, minor=0</tt>

</article>
