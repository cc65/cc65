<!doctype linuxdoc system>

<article>
<title>Commodore 510 (aka P500) specific information for cc65
<author>
<url url="mailto:uz@cc65.org" name="Ullrich von Bassewitz">,<newline>
<url url="mailto:polluks@sdf.lonestar.org" name="Stefan A. Haubenthal">,<newline>
<url url="mailto:greg.king5@verizon.net" name="Greg King">

<abstract>
An overview over the Commodore 510 runtime system as it is implemented for the
cc65 C compiler.
</abstract>

<!-- Table of contents -->
<toc>

<!-- Begin the document -->

<sect>Overview<p>

This file contains an overview of the CBM 510 runtime system as it comes with
the cc65 C compiler. It describes the memory layout, CBM 510-specific header
files, available drivers, and any pitfalls specific to that platform.

Please note that CBM 510-specific functions are just mentioned here, they are
described in detail in the separate <url url="funcref.html" name="function
reference">. Even functions marked as "platform dependent" may be available on
more than one platform. Please see the function reference for more
information.

In addition to the Commodore 510 (named P128 in the U.S.), no other
machines are supported by this cc65 target.



<sect>Binary format<p>

The standard binary output format generated by the linker for the Commodore
510 target is a machine language program with a one-line BASIC stub, which
transfers control to the machine language running in bank 0. That means that a
program can be loaded as a BASIC program, and started with RUN. It is, of course,
possible to change that behaviour by using a modified startup file and linker
config.



<sect>Memory layout<p>

cc65 generated programs for the Commodore 510 run in bank 0, the memory bank
reserved for BASIC programs. Since there are no ROMs in this memory bank,
kernal subroutines are either emulated or called by bank switching, which has
the disadvantage of being slow compared to a direct call.

The default memory configuration for the CBM 510 allocates all memory between
&dollar;0002 and &dollar;FFF0 in bank 0 for the compiled program. Some space
in low memory is lost, because a separate hardware stack is set up in page 1,
and the kernal replacement functions need some more memory locations. A few
more pages are lost in high memory, because the runtime sets up a copy of the
character ROM, a text screen, and a CBM-compatible jump table at &dollar;FF81.
The main startup code is located at &dollar;0400, so about 54K of the complete
bank are actually usable for applications.

Special locations:

<descrip>
  <tag/Stack/
  The C runtime stack is located at &dollar;FEC2, and grows downwards.

  <tag/Heap/
  The C heap is located at the end of the program, and grows towards the C
  runtime stack.
</descrip><p>



<sect>Platform-specific header files<p>

Programs containing CBM 510-specific code may use the <tt/cbm510.h/ or
<tt/cbm.h/ header files. Using the later may be an option when writing code
for more than one CBM platform, since it includes <tt/cbm510.h/, and declares
several functions common to all CBM platforms.

<sect1>CBM 510-specific functions<p>

The functions listed below are special for the CBM 510. See the <url
url="funcref.html" name="function reference"> for declaration and usage.

<itemize>
<item>peekbsys
<item>peekwsys
<item>pokebsys
<item>pokewsys
</itemize>


<sect1>CBM-specific functions<p>

Some functions are available for all (or at least most) of the Commodore
machines. See the <url url="funcref.html" name="function reference"> for
declaration and usage.


<itemize>
<item>cbm_close
<item>cbm_closedir
<item>cbm_k_setlfs
<item>cbm_k_setnam
<item>cbm_k_load
<item>cbm_k_save
<item>cbm_k_open
<item>cbm_k_close
<item>cbm_k_readst
<item>cbm_k_chkin
<item>cbm_k_ckout
<item>cbm_k_basin
<item>cbm_k_bsout
<item>cbm_k_clrch
<item>cbm_k_tksa
<item>cbm_k_second
<item>cbm_load
<item>cbm_open
<item>cbm_opendir
<item>cbm_read
<item>cbm_readdir
<item>cbm_save
<item>cbm_write
<item>get_tv
</itemize>



<sect1>Hardware access<p>

The following pseudo variables declared in the <tt/cbm510.h/ header file do
allow access to hardware located in the address space. Some variables are
structures; accessing the struct fields will access the chip registers.

<em/Note:/ All I/O chips are located in the system bank (bank 15); and can
therefore not be accessed like on other platforms. Please use one of the
<tt/peekbsys/, <tt/peekwsys/, <tt/pokebsys/, and <tt/pokewsys/ functions to
access the I/O chips. Direct reads and writes to the structures named below
will <em>not</em> work!

<descrip>

  <tag><tt/VIC/</tag>
  The <tt/VIC/ structure allows access to the VIC II (the graphics
  controller). See the <tt/_vic2.h/ header file located in the include
  directory for the declaration of the structure.

  <tag><tt/SID/</tag>
  The <tt/SID/ structure allows access to the SID (the sound interface
  device). See the <tt/_sid.h/ header file located in the include directory
  for the declaration of the structure.

  <tag><tt/ACIA/</tag>
  Access to the ACIA (the RS232 chip) is available via the <tt/ACIA/ variable.
  See the <tt/_6551.h/ header file located in the include directory for the
  declaration of the structure.

  <tag><tt/CIA/</tag>
  Access to the CIA chip is available via the <tt/CIA/ variable. See the
  <tt/_6526.h/ header file located in the include directory for the
  declaration of the structure.

  <tag><tt/TPI1, TPI2/</tag>
  The two 6525 triport chips may be accessed by using these variables. See the
  <tt/_6525.h/ header file located in the include directory for the
  declaration of the structure.

</descrip><p>



<sect>Loadable drivers<p>

The names in the parentheses denote the symbols to be used for static linking of the drivers.


<sect1>Graphics drivers<p>

No graphics drivers are currently available for the Commodore 510.


<sect1>Extended memory drivers<p>

<descrip>
  <tag><tt/cbm510-ram.emd (cbm510_ram_emd)/</tag>
  A driver for the RAM in bank 1. Supports up to 255 pages with 256 bytes
  each.
</descrip><p>


<sect1>Joystick drivers<p>

<descrip>

  <tag><tt/cbm510-std.joy (cbm510_std_joy)/</tag>
  Supports up to two standard joysticks connected to the joysticks ports of
  the Commodore 510.

</descrip><p>


<sect1>Mouse drivers<p>

The default drivers, <tt/mouse_stddrv (mouse_static_stddrv)/, point to <tt/cbm510-joy.mou (cbm510_joy_mou)/.

<descrip>

  <tag><tt/cbm510-joy.mou (cbm510_joy_mou)/</tag>
  Supports a mouse that is emulated by a standard joystick, e.g. 1350
  mouse, in joystick port #2 of the CBM510. That stick's fire button acts as
  the left mouse button. The fire button of a stick in joystick port #1 can
  act as the right mouse button.

  <tag><tt/cbm510-inkwl.mou (cbm510_inkwl_mou)/</tag>
  Supports the Inkwell Systems lightpens, connected to port #1 of the CBM510.
  It can read both the 170-C and one button of the 184-C pens.  (It can
  read other lightpens and light-guns that send their button signal to the
  joystick left-button pin.)

</descrip><p>


<sect1>RS232 device drivers<p>

<descrip>

  <tag><tt/cbm510-std.ser (cbm510_std_ser)/</tag>
  Driver for the 6551 ACIA chip built into the Commodore 510. Supports up to
  19200 BPS, hardware flow control (RTS/CTS), and interrupt-driven receives.
  Note that, because of the peculiarities of the 6551 chip, transmits are not
  interrupt driven; and, the transceiver blocks if the receiver asserts flow
  control because of a full buffer.

</descrip><p>



<sect>Limitations<label id="limitations"><p>


<sect1>Kernal and hardware access<p>

Since the program runs in bank 0, and the kernal and all I/O chips are located
in bank 15, calling ROM routines or accessing hardware needs special code. The
cc65 runtime implements wrappers for all functions in the kernal jump table.
While this simplifies things, it should be noted that the wrappers do have
quite an impact on performance: A cross-bank call has an extra 300&micro;s
penalty added by the wrapper.


<sect1>Interrupts<p>

Compiled programs contain an interrupt handler that runs in the program bank.
This has several advantages, one of them being performance (see cross-bank
call overhead mentioned above). However, this introduces one problem:
Interrupts are lost while the CPU executes code in the kernal bank. As a
result, the clock may go wrong; and (worse), serial interrupts may get lost.

Since the cc65 runtime does only call the kernal for disk I/O, this means that
a program should not do file I/O while it depends on interrupts.



<sect>Other hints<p>


<sect1>Passing arguments to the program<p>

Command-line arguments can be passed to <tt/main()/. Since that is not
supported directly by BASIC, the following syntax was chosen:

<tscreen><verb>
    RUN:REM ARG1 " ARG2 IS QUOTED" ARG3 "" ARG5
</verb></tscreen>

<enum>
<item>Arguments are separated by spaces.
<item>Arguments may be quoted.
<item>Leading and trailing spaces around an argument are ignored. Spaces within
      a quoted argument are allowed.
<item>The first argument passed to <tt/main()/ is the program name.
<item>A maximum number of 10 arguments (including the program name) are
      supported.
</enum>


<sect1>Program return code<p>

The program return code (signed char) is passed back to BASIC by use of the
<tt/ST/ variable.


<sect1>Interrupt handlers<p>

The runtime for the Commodore 510 uses routines marked as <tt/.INTERRUPTOR/
for interrupt handlers. Such routines must be written as simple machine
language subroutines and will be called automatically by the interrupt handler
code when they are linked into a program. See the discussion of the
<tt/.CONDES/ feature in the <url url="ca65.html" name="assembler manual">.



<sect>License<p>

This software is provided 'as-is', without any expressed or implied
warranty.  In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

<enum>
<item>	The origin of this software must not be misrepresented; you must not
	claim that you wrote the original software. If you use this software
	in a product, an acknowledgment in the product documentation would be
	appreciated but is not required.
<item>	Altered source versions must be plainly marked as such, and must not
	be misrepresented as being the original software.
<item>	This notice may not be removed or altered from any source
	distribution.
</enum>

</article>
